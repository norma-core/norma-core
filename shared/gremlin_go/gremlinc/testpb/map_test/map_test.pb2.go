// Code generated by gremlin. DO NOT EDIT.
// source: map_test.proto

package map_test

import gremlin "github.com/norma-core/norma-core/shared/gremlin_go"

type TestMap_EnumValue int32

const (
	TestMap_FOO TestMap_EnumValue = 0
	TestMap_BAR TestMap_EnumValue = 1
	TestMap_BAZ TestMap_EnumValue = 2
	TestMap_QUX TestMap_EnumValue = 3
)

func (e TestMap_EnumValue) String() string {
	switch e {
	case TestMap_FOO:
		return "FOO"
	case TestMap_BAR:
		return "BAR"
	case TestMap_BAZ:
		return "BAZ"
	case TestMap_QUX:
		return "QUX"
	default:
		return ""
	}
}

type ReservedAsMapFieldWithEnumValue_SampleEnum int32

const (
	ReservedAsMapFieldWithEnumValue_A ReservedAsMapFieldWithEnumValue_SampleEnum = 0
	ReservedAsMapFieldWithEnumValue_B ReservedAsMapFieldWithEnumValue_SampleEnum = 1
)

func (e ReservedAsMapFieldWithEnumValue_SampleEnum) String() string {
	switch e {
	case ReservedAsMapFieldWithEnumValue_A:
		return "A"
	case ReservedAsMapFieldWithEnumValue_B:
		return "B"
	default:
		return ""
	}
}

const (
	wireTestMap_Int32ToInt32Field gremlin.ProtoWireNumber = 1
	wireTestMap_Int32ToStringField gremlin.ProtoWireNumber = 2
	wireTestMap_Int32ToBytesField gremlin.ProtoWireNumber = 3
	wireTestMap_Int32ToEnumField gremlin.ProtoWireNumber = 4
	wireTestMap_Int32ToMessageField gremlin.ProtoWireNumber = 5
	wireTestMap_StringToInt32Field gremlin.ProtoWireNumber = 6
	wireTestMap_Uint32ToInt32Field gremlin.ProtoWireNumber = 7
	wireTestMap_Int64ToInt32Field gremlin.ProtoWireNumber = 8
)

type TestMapReader struct {
	buf *gremlin.Reader

	dataInt32ToInt32Field     map[int32]int32
	dataInt32ToStringField     map[int32]string
	dataInt32ToBytesField     map[int32][]byte
	dataInt32ToEnumField     map[int32]TestMap_EnumValue
	dataInt32ToMessageField     map[int32]*TestMap_MessageValueReader
	dataStringToInt32Field     map[string]int32
	dataUint32ToInt32Field     map[uint32]int32
	dataInt64ToInt32Field     map[int64]int32

	offsetInt32ToInt32Field   []int
	offsetInt32ToStringField   []int
	offsetInt32ToBytesField   []int
	offsetInt32ToEnumField   []int
	offsetInt32ToMessageField   []int
	offsetStringToInt32Field   []int
	offsetUint32ToInt32Field   []int
	offsetInt64ToInt32Field   []int

	parsedInt32ToInt32Field   bool
	parsedInt32ToStringField   bool
	parsedInt32ToBytesField   bool
	parsedInt32ToEnumField   bool
	parsedInt32ToMessageField   bool
	parsedStringToInt32Field   bool
	parsedUint32ToInt32Field   bool
	parsedInt64ToInt32Field   bool
}

func NewTestMapReader() *TestMapReader {
	return &TestMapReader{}
}

func (m *TestMapReader) GetInt32ToInt32Field() map[int32]int32 {
	if m == nil {
		return nil
	}
	return m.readInt32ToInt32Field()
}

func (m *TestMapReader) readInt32ToInt32Field() map[int32]int32 {
	if m.parsedInt32ToInt32Field {
		return m.dataInt32ToInt32Field
	}
	wOffset := m.offsetInt32ToInt32Field
	
	var entry = map[int32]int32{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData int32
		var valueData int32
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry int32
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry int32
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataInt32ToInt32Field = entry
	m.parsedInt32ToInt32Field = true
	return entry
}

func (m *TestMapReader) GetInt32ToStringField() map[int32]string {
	if m == nil {
		return nil
	}
	return m.readInt32ToStringField()
}

func (m *TestMapReader) readInt32ToStringField() map[int32]string {
	if m.parsedInt32ToStringField {
		return m.dataInt32ToStringField
	}
	wOffset := m.offsetInt32ToStringField
	
	var entry = map[int32]string{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData int32
		var valueData string
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry int32
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry string
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataInt32ToStringField = entry
	m.parsedInt32ToStringField = true
	return entry
}

func (m *TestMapReader) GetInt32ToBytesField() map[int32][]byte {
	if m == nil {
		return nil
	}
	return m.readInt32ToBytesField()
}

func (m *TestMapReader) readInt32ToBytesField() map[int32][]byte {
	if m.parsedInt32ToBytesField {
		return m.dataInt32ToBytesField
	}
	wOffset := m.offsetInt32ToBytesField
	
	var entry = map[int32][]byte{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData int32
		var valueData []byte
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry int32
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry []byte
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadBytes(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataInt32ToBytesField = entry
	m.parsedInt32ToBytesField = true
	return entry
}

func (m *TestMapReader) GetInt32ToEnumField() map[int32]TestMap_EnumValue {
	if m == nil {
		return nil
	}
	return m.readInt32ToEnumField()
}

func (m *TestMapReader) readInt32ToEnumField() map[int32]TestMap_EnumValue {
	if m.parsedInt32ToEnumField {
		return m.dataInt32ToEnumField
	}
	wOffset := m.offsetInt32ToEnumField
	
	var entry = map[int32]TestMap_EnumValue{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData int32
		var valueData TestMap_EnumValue
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry int32
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry TestMap_EnumValue
				var valueEntrySize int
				if wOffset > 0 {
					rawEntry, size := m.buf.SizedReadInt32(wOffset)
					valueEntry = TestMap_EnumValue(rawEntry)
					valueEntrySize = size
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataInt32ToEnumField = entry
	m.parsedInt32ToEnumField = true
	return entry
}

func (m *TestMapReader) GetInt32ToMessageField() map[int32]*TestMap_MessageValueReader {
	if m == nil {
		return nil
	}
	return m.readInt32ToMessageField()
}

func (m *TestMapReader) readInt32ToMessageField() map[int32]*TestMap_MessageValueReader {
	if m.parsedInt32ToMessageField {
		return m.dataInt32ToMessageField
	}
	wOffset := m.offsetInt32ToMessageField
	
	var entry = map[int32]*TestMap_MessageValueReader{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData int32
		var valueData *TestMap_MessageValueReader
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry int32
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry *TestMap_MessageValueReader
				var valueEntrySize int
				if wOffset > 0 {
					var valueEntryData, valueEntryDataSize = m.buf.SizedReadBytes(wOffset)
					if len(valueEntryData) > 0 {
						valueEntry = NewTestMap_MessageValueReader()
						valueEntry.Unmarshal(valueEntryData)
					}
					valueEntrySize = valueEntryDataSize
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataInt32ToMessageField = entry
	m.parsedInt32ToMessageField = true
	return entry
}

func (m *TestMapReader) GetStringToInt32Field() map[string]int32 {
	if m == nil {
		return nil
	}
	return m.readStringToInt32Field()
}

func (m *TestMapReader) readStringToInt32Field() map[string]int32 {
	if m.parsedStringToInt32Field {
		return m.dataStringToInt32Field
	}
	wOffset := m.offsetStringToInt32Field
	
	var entry = map[string]int32{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData int32
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry int32
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataStringToInt32Field = entry
	m.parsedStringToInt32Field = true
	return entry
}

func (m *TestMapReader) GetUint32ToInt32Field() map[uint32]int32 {
	if m == nil {
		return nil
	}
	return m.readUint32ToInt32Field()
}

func (m *TestMapReader) readUint32ToInt32Field() map[uint32]int32 {
	if m.parsedUint32ToInt32Field {
		return m.dataUint32ToInt32Field
	}
	wOffset := m.offsetUint32ToInt32Field
	
	var entry = map[uint32]int32{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData uint32
		var valueData int32
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry uint32
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadUint32(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry int32
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataUint32ToInt32Field = entry
	m.parsedUint32ToInt32Field = true
	return entry
}

func (m *TestMapReader) GetInt64ToInt32Field() map[int64]int32 {
	if m == nil {
		return nil
	}
	return m.readInt64ToInt32Field()
}

func (m *TestMapReader) readInt64ToInt32Field() map[int64]int32 {
	if m.parsedInt64ToInt32Field {
		return m.dataInt64ToInt32Field
	}
	wOffset := m.offsetInt64ToInt32Field
	
	var entry = map[int64]int32{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData int64
		var valueData int32
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry int64
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadInt64(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry int32
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataInt64ToInt32Field = entry
	m.parsedInt64ToInt32Field = true
	return entry
}

func (m *TestMapReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestMap_Int32ToInt32Field:
			m.offsetInt32ToInt32Field = append(m.offsetInt32ToInt32Field, offset)
		case wireTestMap_Int32ToStringField:
			m.offsetInt32ToStringField = append(m.offsetInt32ToStringField, offset)
		case wireTestMap_Int32ToBytesField:
			m.offsetInt32ToBytesField = append(m.offsetInt32ToBytesField, offset)
		case wireTestMap_Int32ToEnumField:
			m.offsetInt32ToEnumField = append(m.offsetInt32ToEnumField, offset)
		case wireTestMap_Int32ToMessageField:
			m.offsetInt32ToMessageField = append(m.offsetInt32ToMessageField, offset)
		case wireTestMap_StringToInt32Field:
			m.offsetStringToInt32Field = append(m.offsetStringToInt32Field, offset)
		case wireTestMap_Uint32ToInt32Field:
			m.offsetUint32ToInt32Field = append(m.offsetUint32ToInt32Field, offset)
		case wireTestMap_Int64ToInt32Field:
			m.offsetInt64ToInt32Field = append(m.offsetInt64ToInt32Field, offset)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestMapReader) ToStruct() *TestMap {
	if m == nil {
		return nil
	}
	res := &TestMap{}
	res.Int32ToInt32Field = m.GetInt32ToInt32Field()
	res.Int32ToStringField = m.GetInt32ToStringField()
	res.Int32ToBytesField = m.GetInt32ToBytesField()
	res.Int32ToEnumField = m.GetInt32ToEnumField()

	{
		var data = m.GetInt32ToMessageField()
		var structData map[int32]*TestMap_MessageValue
		if len(data) > 0 {
			structData = make(map[int32]*TestMap_MessageValue, len(data))
			for k,v := range data {
				if v != nil {
					structData[k] = v.ToStruct()
				}
			}
		}
		res.Int32ToMessageField = structData
	}
	res.StringToInt32Field = m.GetStringToInt32Field()
	res.Uint32ToInt32Field = m.GetUint32ToInt32Field()
	res.Int64ToInt32Field = m.GetInt64ToInt32Field()

	return res
}

func (s *TestMapReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestMap struct {
	Int32ToInt32Field	map[int32]int32	`json:"int32_to_int32_field,omitempty"`
	Int32ToStringField	map[int32]string	`json:"int32_to_string_field,omitempty"`
	Int32ToBytesField	map[int32][]byte	`json:"int32_to_bytes_field,omitempty"`
	Int32ToEnumField	map[int32]TestMap_EnumValue	`json:"int32_to_enum_field,omitempty"`
	Int32ToMessageField	map[int32]*TestMap_MessageValue	`json:"int32_to_message_field,omitempty"`
	StringToInt32Field	map[string]int32	`json:"string_to_int32_field,omitempty"`
	Uint32ToInt32Field	map[uint32]int32	`json:"uint32_to_int32_field,omitempty"`
	Int64ToInt32Field	map[int64]int32	`json:"int64_to_int32_field,omitempty"`
}

func (s *TestMap) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestMap) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if len(s.Int32ToInt32Field) > 0 {
		for k, v := range s.Int32ToInt32Field {
			var keySize, valueSize int
			keySize = gremlin.SizeTag(1) + gremlin.SizeInt32(k)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(v)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireTestMap_Int32ToInt32Field, mapEntrySize)
			res.AppendInt32(1, k)
			res.AppendInt32(2, v)
		}
	}
	if len(s.Int32ToStringField) > 0 {
		for k, v := range s.Int32ToStringField {
			var keySize, valueSize int
			keySize = gremlin.SizeTag(1) + gremlin.SizeInt32(k)
			valueSize = gremlin.SizeString(v)
			valueSize += gremlin.SizeUint64(uint64(valueSize)) + gremlin.SizeTag(2)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireTestMap_Int32ToStringField, mapEntrySize)
			res.AppendInt32(1, k)
			res.AppendString(2, v)
		}
	}
	if len(s.Int32ToBytesField) > 0 {
		for k, v := range s.Int32ToBytesField {
			var keySize, valueSize int
			keySize = gremlin.SizeTag(1) + gremlin.SizeInt32(k)
			valueSize = gremlin.SizeBytes(v)
			valueSize += gremlin.SizeUint64(uint64(valueSize)) + gremlin.SizeTag(2)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireTestMap_Int32ToBytesField, mapEntrySize)
			res.AppendInt32(1, k)
			res.AppendBytes(2, v)
		}
	}
	if len(s.Int32ToEnumField) > 0 {
		for k, v := range s.Int32ToEnumField {
			var keySize, valueSize int
			keySize = gremlin.SizeTag(1) + gremlin.SizeInt32(k)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(int32(v))
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireTestMap_Int32ToEnumField, mapEntrySize)
			res.AppendInt32(1, k)
			res.AppendInt32(2, int32(v))
		}
	}
	if len(s.Int32ToMessageField) > 0 {
		for k, v := range s.Int32ToMessageField {
			var keySize, valueSize int
			keySize = gremlin.SizeTag(1) + gremlin.SizeInt32(k)
			valueSize = v.XXX_PbContentSize()
			valueSize += gremlin.SizeUint64(uint64(valueSize)) + gremlin.SizeTag(2)
			
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireTestMap_Int32ToMessageField, mapEntrySize)
			res.AppendInt32(1, k)
			structSize := v.XXX_PbContentSize()
			res.AppendBytesTag(2, structSize)
			v.MarshalTo(res)
		}
	}
	if len(s.StringToInt32Field) > 0 {
		for k, v := range s.StringToInt32Field {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(v)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireTestMap_StringToInt32Field, mapEntrySize)
			res.AppendString(1, k)
			res.AppendInt32(2, v)
		}
	}
	if len(s.Uint32ToInt32Field) > 0 {
		for k, v := range s.Uint32ToInt32Field {
			var keySize, valueSize int
			keySize = gremlin.SizeTag(1) + gremlin.SizeUint32(k)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(v)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireTestMap_Uint32ToInt32Field, mapEntrySize)
			res.AppendUint32(1, k)
			res.AppendInt32(2, v)
		}
	}
	if len(s.Int64ToInt32Field) > 0 {
		for k, v := range s.Int64ToInt32Field {
			var keySize, valueSize int
			keySize = gremlin.SizeTag(1) + gremlin.SizeInt64(k)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(v)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireTestMap_Int64ToInt32Field, mapEntrySize)
			res.AppendInt64(1, k)
			res.AppendInt32(2, v)
		}
	}
}

func (s *TestMap) Copy() *TestMap {
	if s == nil {
		return nil
	}
	res := &TestMap{}
	res.Int32ToInt32Field = make(map[int32]int32, len(s.Int32ToInt32Field))
	for k, v := range s.Int32ToInt32Field {
		res.Int32ToInt32Field[k] = v
	}
	res.Int32ToStringField = make(map[int32]string, len(s.Int32ToStringField))
	for k, v := range s.Int32ToStringField {
		res.Int32ToStringField[k] = v
	}
	res.Int32ToBytesField = make(map[int32][]byte, len(s.Int32ToBytesField))
	for k, v := range s.Int32ToBytesField {
		res.Int32ToBytesField[k] = v
	}
	res.Int32ToEnumField = make(map[int32]TestMap_EnumValue, len(s.Int32ToEnumField))
	for k, v := range s.Int32ToEnumField {
		res.Int32ToEnumField[k] = v
	}
	res.Int32ToMessageField = make(map[int32]*TestMap_MessageValue, len(s.Int32ToMessageField))
	for k, v := range s.Int32ToMessageField {
		if v != nil {
			res.Int32ToMessageField[k] = v.Copy()
		}
	}
	res.StringToInt32Field = make(map[string]int32, len(s.StringToInt32Field))
	for k, v := range s.StringToInt32Field {
		res.StringToInt32Field[k] = v
	}
	res.Uint32ToInt32Field = make(map[uint32]int32, len(s.Uint32ToInt32Field))
	for k, v := range s.Uint32ToInt32Field {
		res.Uint32ToInt32Field[k] = v
	}
	res.Int64ToInt32Field = make(map[int64]int32, len(s.Int64ToInt32Field))
	for k, v := range s.Int64ToInt32Field {
		res.Int64ToInt32Field[k] = v
	}

	return res
}

func (s *TestMap) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if len(s.Int32ToInt32Field) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Int32ToInt32Field {
			var keySize, valueSize int
			keySize = gremlin.SizeTag(1) + gremlin.SizeInt32(k)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(v)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireTestMap_Int32ToInt32Field) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Int32ToStringField) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Int32ToStringField {
			var keySize, valueSize int
			keySize = gremlin.SizeTag(1) + gremlin.SizeInt32(k)
			valueSize = gremlin.SizeString(v)
			valueSize += gremlin.SizeUint64(uint64(valueSize)) + gremlin.SizeTag(2)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireTestMap_Int32ToStringField) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Int32ToBytesField) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Int32ToBytesField {
			var keySize, valueSize int
			keySize = gremlin.SizeTag(1) + gremlin.SizeInt32(k)
			valueSize = gremlin.SizeBytes(v)
			valueSize += gremlin.SizeUint64(uint64(valueSize)) + gremlin.SizeTag(2)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireTestMap_Int32ToBytesField) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Int32ToEnumField) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Int32ToEnumField {
			var keySize, valueSize int
			keySize = gremlin.SizeTag(1) + gremlin.SizeInt32(k)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(int32(v))
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireTestMap_Int32ToEnumField) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Int32ToMessageField) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Int32ToMessageField {
			var keySize, valueSize int
			keySize = gremlin.SizeTag(1) + gremlin.SizeInt32(k)
			valueSize = v.XXX_PbContentSize()
			valueSize += gremlin.SizeUint64(uint64(valueSize)) + gremlin.SizeTag(2)
			
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireTestMap_Int32ToMessageField) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.StringToInt32Field) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.StringToInt32Field {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(v)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireTestMap_StringToInt32Field) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Uint32ToInt32Field) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Uint32ToInt32Field {
			var keySize, valueSize int
			keySize = gremlin.SizeTag(1) + gremlin.SizeUint32(k)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(v)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireTestMap_Uint32ToInt32Field) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Int64ToInt32Field) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Int64ToInt32Field {
			var keySize, valueSize int
			keySize = gremlin.SizeTag(1) + gremlin.SizeInt64(k)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(v)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireTestMap_Int64ToInt32Field) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	return size
}

const (
	wireTestMap_MessageValue_Value gremlin.ProtoWireNumber = 1
)

type TestMap_MessageValueReader struct {
	buf *gremlin.Reader

	dataValue     int32

	offsetValue   int

	parsedValue   bool
}

func NewTestMap_MessageValueReader() *TestMap_MessageValueReader {
	return &TestMap_MessageValueReader{}
}

func (m *TestMap_MessageValueReader) GetValue() int32 {
	if m == nil {
		return 0
	}
	return m.readValue()
}

func (m *TestMap_MessageValueReader) readValue() int32 {
	if m.parsedValue {
		return m.dataValue
	}
	wOffset := m.offsetValue
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataValue = entry
	m.parsedValue = true
	return entry
}

func (m *TestMap_MessageValueReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestMap_MessageValue_Value:
			m.offsetValue = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestMap_MessageValueReader) ToStruct() *TestMap_MessageValue {
	if m == nil {
		return nil
	}
	res := &TestMap_MessageValue{}
	res.Value = m.GetValue()

	return res
}

func (s *TestMap_MessageValueReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestMap_MessageValue struct {
	Value	int32	`json:"value,omitempty"`
}

func (s *TestMap_MessageValue) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestMap_MessageValue) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Value != 0 {
		res.AppendInt32(wireTestMap_MessageValue_Value, s.Value)
	}
}

func (s *TestMap_MessageValue) Copy() *TestMap_MessageValue {
	if s == nil {
		return nil
	}
	res := &TestMap_MessageValue{}
	res.Value = s.Value

	return res
}

func (s *TestMap_MessageValue) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Value != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestMap_MessageValue_Value) + gremlin.SizeInt32(s.Value)
		size += entrySize
	}

	return size
}

const (
	wireTestOnChangeEventPropagation_OptionalMessage gremlin.ProtoWireNumber = 1
)

type TestOnChangeEventPropagationReader struct {
	buf *gremlin.Reader

	dataOptionalMessage     *TestMapReader

	offsetOptionalMessage   int

	parsedOptionalMessage   bool
}

func NewTestOnChangeEventPropagationReader() *TestOnChangeEventPropagationReader {
	return &TestOnChangeEventPropagationReader{}
}

func (m *TestOnChangeEventPropagationReader) GetOptionalMessage() *TestMapReader {
	if m == nil {
		return nil
	}
	return m.readOptionalMessage()
}

func (m *TestOnChangeEventPropagationReader) readOptionalMessage() *TestMapReader {
	if m.parsedOptionalMessage {
		return m.dataOptionalMessage
	}
	wOffset := m.offsetOptionalMessage
	
	var entry *TestMapReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestMapReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalMessage = entry
	m.parsedOptionalMessage = true
	return entry
}

func (m *TestOnChangeEventPropagationReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestOnChangeEventPropagation_OptionalMessage:
			m.offsetOptionalMessage = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestOnChangeEventPropagationReader) ToStruct() *TestOnChangeEventPropagation {
	if m == nil {
		return nil
	}
	res := &TestOnChangeEventPropagation{}

	{
		var data = m.GetOptionalMessage()
		var structData *TestMap
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalMessage = structData
	}

	return res
}

func (s *TestOnChangeEventPropagationReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestOnChangeEventPropagation struct {
	OptionalMessage	*TestMap	`json:"optional_message,omitempty"`
}

func (s *TestOnChangeEventPropagation) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestOnChangeEventPropagation) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.OptionalMessage != nil {
		structSize := s.OptionalMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestOnChangeEventPropagation_OptionalMessage, structSize)
		s.OptionalMessage.MarshalTo(res)
	}
}

func (s *TestOnChangeEventPropagation) Copy() *TestOnChangeEventPropagation {
	if s == nil {
		return nil
	}
	res := &TestOnChangeEventPropagation{}
	if s.OptionalMessage != nil {
		res.OptionalMessage = s.OptionalMessage.Copy()
	}

	return res
}

func (s *TestOnChangeEventPropagation) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.OptionalMessage != nil {
		var entrySize = 0
		entrySize = s.OptionalMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestOnChangeEventPropagation_OptionalMessage)
		
		size += entrySize
	}

	return size
}

const (
	wireBizarroTestMap_Int32ToInt32Field gremlin.ProtoWireNumber = 1
	wireBizarroTestMap_Int32ToStringField gremlin.ProtoWireNumber = 2
	wireBizarroTestMap_Int32ToBytesField gremlin.ProtoWireNumber = 3
	wireBizarroTestMap_Int32ToEnumField gremlin.ProtoWireNumber = 4
	wireBizarroTestMap_Int32ToMessageField gremlin.ProtoWireNumber = 5
	wireBizarroTestMap_StringToInt32Field gremlin.ProtoWireNumber = 6
)

type BizarroTestMapReader struct {
	buf *gremlin.Reader

	dataInt32ToInt32Field     map[int32][]byte
	dataInt32ToStringField     map[string]int32
	dataInt32ToBytesField     map[string]int32
	dataInt32ToEnumField     map[string][]byte
	dataInt32ToMessageField     map[string][]byte
	dataStringToInt32Field     map[string][]byte

	offsetInt32ToInt32Field   []int
	offsetInt32ToStringField   []int
	offsetInt32ToBytesField   []int
	offsetInt32ToEnumField   []int
	offsetInt32ToMessageField   []int
	offsetStringToInt32Field   []int

	parsedInt32ToInt32Field   bool
	parsedInt32ToStringField   bool
	parsedInt32ToBytesField   bool
	parsedInt32ToEnumField   bool
	parsedInt32ToMessageField   bool
	parsedStringToInt32Field   bool
}

func NewBizarroTestMapReader() *BizarroTestMapReader {
	return &BizarroTestMapReader{}
}

func (m *BizarroTestMapReader) GetInt32ToInt32Field() map[int32][]byte {
	if m == nil {
		return nil
	}
	return m.readInt32ToInt32Field()
}

func (m *BizarroTestMapReader) readInt32ToInt32Field() map[int32][]byte {
	if m.parsedInt32ToInt32Field {
		return m.dataInt32ToInt32Field
	}
	wOffset := m.offsetInt32ToInt32Field
	
	var entry = map[int32][]byte{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData int32
		var valueData []byte
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry int32
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry []byte
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadBytes(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataInt32ToInt32Field = entry
	m.parsedInt32ToInt32Field = true
	return entry
}

func (m *BizarroTestMapReader) GetInt32ToStringField() map[string]int32 {
	if m == nil {
		return nil
	}
	return m.readInt32ToStringField()
}

func (m *BizarroTestMapReader) readInt32ToStringField() map[string]int32 {
	if m.parsedInt32ToStringField {
		return m.dataInt32ToStringField
	}
	wOffset := m.offsetInt32ToStringField
	
	var entry = map[string]int32{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData int32
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry int32
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataInt32ToStringField = entry
	m.parsedInt32ToStringField = true
	return entry
}

func (m *BizarroTestMapReader) GetInt32ToBytesField() map[string]int32 {
	if m == nil {
		return nil
	}
	return m.readInt32ToBytesField()
}

func (m *BizarroTestMapReader) readInt32ToBytesField() map[string]int32 {
	if m.parsedInt32ToBytesField {
		return m.dataInt32ToBytesField
	}
	wOffset := m.offsetInt32ToBytesField
	
	var entry = map[string]int32{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData int32
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry int32
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataInt32ToBytesField = entry
	m.parsedInt32ToBytesField = true
	return entry
}

func (m *BizarroTestMapReader) GetInt32ToEnumField() map[string][]byte {
	if m == nil {
		return nil
	}
	return m.readInt32ToEnumField()
}

func (m *BizarroTestMapReader) readInt32ToEnumField() map[string][]byte {
	if m.parsedInt32ToEnumField {
		return m.dataInt32ToEnumField
	}
	wOffset := m.offsetInt32ToEnumField
	
	var entry = map[string][]byte{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData []byte
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry []byte
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadBytes(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataInt32ToEnumField = entry
	m.parsedInt32ToEnumField = true
	return entry
}

func (m *BizarroTestMapReader) GetInt32ToMessageField() map[string][]byte {
	if m == nil {
		return nil
	}
	return m.readInt32ToMessageField()
}

func (m *BizarroTestMapReader) readInt32ToMessageField() map[string][]byte {
	if m.parsedInt32ToMessageField {
		return m.dataInt32ToMessageField
	}
	wOffset := m.offsetInt32ToMessageField
	
	var entry = map[string][]byte{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData []byte
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry []byte
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadBytes(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataInt32ToMessageField = entry
	m.parsedInt32ToMessageField = true
	return entry
}

func (m *BizarroTestMapReader) GetStringToInt32Field() map[string][]byte {
	if m == nil {
		return nil
	}
	return m.readStringToInt32Field()
}

func (m *BizarroTestMapReader) readStringToInt32Field() map[string][]byte {
	if m.parsedStringToInt32Field {
		return m.dataStringToInt32Field
	}
	wOffset := m.offsetStringToInt32Field
	
	var entry = map[string][]byte{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData []byte
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry []byte
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadBytes(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataStringToInt32Field = entry
	m.parsedStringToInt32Field = true
	return entry
}

func (m *BizarroTestMapReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireBizarroTestMap_Int32ToInt32Field:
			m.offsetInt32ToInt32Field = append(m.offsetInt32ToInt32Field, offset)
		case wireBizarroTestMap_Int32ToStringField:
			m.offsetInt32ToStringField = append(m.offsetInt32ToStringField, offset)
		case wireBizarroTestMap_Int32ToBytesField:
			m.offsetInt32ToBytesField = append(m.offsetInt32ToBytesField, offset)
		case wireBizarroTestMap_Int32ToEnumField:
			m.offsetInt32ToEnumField = append(m.offsetInt32ToEnumField, offset)
		case wireBizarroTestMap_Int32ToMessageField:
			m.offsetInt32ToMessageField = append(m.offsetInt32ToMessageField, offset)
		case wireBizarroTestMap_StringToInt32Field:
			m.offsetStringToInt32Field = append(m.offsetStringToInt32Field, offset)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *BizarroTestMapReader) ToStruct() *BizarroTestMap {
	if m == nil {
		return nil
	}
	res := &BizarroTestMap{}
	res.Int32ToInt32Field = m.GetInt32ToInt32Field()
	res.Int32ToStringField = m.GetInt32ToStringField()
	res.Int32ToBytesField = m.GetInt32ToBytesField()
	res.Int32ToEnumField = m.GetInt32ToEnumField()
	res.Int32ToMessageField = m.GetInt32ToMessageField()
	res.StringToInt32Field = m.GetStringToInt32Field()

	return res
}

func (s *BizarroTestMapReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type BizarroTestMap struct {
	Int32ToInt32Field	map[int32][]byte	`json:"int32_to_int32_field,omitempty"`
	Int32ToStringField	map[string]int32	`json:"int32_to_string_field,omitempty"`
	Int32ToBytesField	map[string]int32	`json:"int32_to_bytes_field,omitempty"`
	Int32ToEnumField	map[string][]byte	`json:"int32_to_enum_field,omitempty"`
	Int32ToMessageField	map[string][]byte	`json:"int32_to_message_field,omitempty"`
	StringToInt32Field	map[string][]byte	`json:"string_to_int32_field,omitempty"`
}

func (s *BizarroTestMap) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *BizarroTestMap) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if len(s.Int32ToInt32Field) > 0 {
		for k, v := range s.Int32ToInt32Field {
			var keySize, valueSize int
			keySize = gremlin.SizeTag(1) + gremlin.SizeInt32(k)
			valueSize = gremlin.SizeBytes(v)
			valueSize += gremlin.SizeUint64(uint64(valueSize)) + gremlin.SizeTag(2)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireBizarroTestMap_Int32ToInt32Field, mapEntrySize)
			res.AppendInt32(1, k)
			res.AppendBytes(2, v)
		}
	}
	if len(s.Int32ToStringField) > 0 {
		for k, v := range s.Int32ToStringField {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(v)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireBizarroTestMap_Int32ToStringField, mapEntrySize)
			res.AppendString(1, k)
			res.AppendInt32(2, v)
		}
	}
	if len(s.Int32ToBytesField) > 0 {
		for k, v := range s.Int32ToBytesField {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(v)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireBizarroTestMap_Int32ToBytesField, mapEntrySize)
			res.AppendString(1, k)
			res.AppendInt32(2, v)
		}
	}
	if len(s.Int32ToEnumField) > 0 {
		for k, v := range s.Int32ToEnumField {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeBytes(v)
			valueSize += gremlin.SizeUint64(uint64(valueSize)) + gremlin.SizeTag(2)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireBizarroTestMap_Int32ToEnumField, mapEntrySize)
			res.AppendString(1, k)
			res.AppendBytes(2, v)
		}
	}
	if len(s.Int32ToMessageField) > 0 {
		for k, v := range s.Int32ToMessageField {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeBytes(v)
			valueSize += gremlin.SizeUint64(uint64(valueSize)) + gremlin.SizeTag(2)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireBizarroTestMap_Int32ToMessageField, mapEntrySize)
			res.AppendString(1, k)
			res.AppendBytes(2, v)
		}
	}
	if len(s.StringToInt32Field) > 0 {
		for k, v := range s.StringToInt32Field {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeBytes(v)
			valueSize += gremlin.SizeUint64(uint64(valueSize)) + gremlin.SizeTag(2)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireBizarroTestMap_StringToInt32Field, mapEntrySize)
			res.AppendString(1, k)
			res.AppendBytes(2, v)
		}
	}
}

func (s *BizarroTestMap) Copy() *BizarroTestMap {
	if s == nil {
		return nil
	}
	res := &BizarroTestMap{}
	res.Int32ToInt32Field = make(map[int32][]byte, len(s.Int32ToInt32Field))
	for k, v := range s.Int32ToInt32Field {
		res.Int32ToInt32Field[k] = v
	}
	res.Int32ToStringField = make(map[string]int32, len(s.Int32ToStringField))
	for k, v := range s.Int32ToStringField {
		res.Int32ToStringField[k] = v
	}
	res.Int32ToBytesField = make(map[string]int32, len(s.Int32ToBytesField))
	for k, v := range s.Int32ToBytesField {
		res.Int32ToBytesField[k] = v
	}
	res.Int32ToEnumField = make(map[string][]byte, len(s.Int32ToEnumField))
	for k, v := range s.Int32ToEnumField {
		res.Int32ToEnumField[k] = v
	}
	res.Int32ToMessageField = make(map[string][]byte, len(s.Int32ToMessageField))
	for k, v := range s.Int32ToMessageField {
		res.Int32ToMessageField[k] = v
	}
	res.StringToInt32Field = make(map[string][]byte, len(s.StringToInt32Field))
	for k, v := range s.StringToInt32Field {
		res.StringToInt32Field[k] = v
	}

	return res
}

func (s *BizarroTestMap) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if len(s.Int32ToInt32Field) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Int32ToInt32Field {
			var keySize, valueSize int
			keySize = gremlin.SizeTag(1) + gremlin.SizeInt32(k)
			valueSize = gremlin.SizeBytes(v)
			valueSize += gremlin.SizeUint64(uint64(valueSize)) + gremlin.SizeTag(2)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireBizarroTestMap_Int32ToInt32Field) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Int32ToStringField) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Int32ToStringField {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(v)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireBizarroTestMap_Int32ToStringField) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Int32ToBytesField) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Int32ToBytesField {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(v)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireBizarroTestMap_Int32ToBytesField) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Int32ToEnumField) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Int32ToEnumField {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeBytes(v)
			valueSize += gremlin.SizeUint64(uint64(valueSize)) + gremlin.SizeTag(2)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireBizarroTestMap_Int32ToEnumField) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Int32ToMessageField) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Int32ToMessageField {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeBytes(v)
			valueSize += gremlin.SizeUint64(uint64(valueSize)) + gremlin.SizeTag(2)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireBizarroTestMap_Int32ToMessageField) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.StringToInt32Field) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.StringToInt32Field {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeBytes(v)
			valueSize += gremlin.SizeUint64(uint64(valueSize)) + gremlin.SizeTag(2)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireBizarroTestMap_StringToInt32Field) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	return size
}

const (
	wireReservedAsMapField_If gremlin.ProtoWireNumber = 1
	wireReservedAsMapField_Const gremlin.ProtoWireNumber = 2
	wireReservedAsMapField_Private gremlin.ProtoWireNumber = 3
	wireReservedAsMapField_Class gremlin.ProtoWireNumber = 4
	wireReservedAsMapField_Int gremlin.ProtoWireNumber = 5
	wireReservedAsMapField_Void gremlin.ProtoWireNumber = 6
	wireReservedAsMapField_String gremlin.ProtoWireNumber = 7
	wireReservedAsMapField_Package gremlin.ProtoWireNumber = 8
	wireReservedAsMapField_Enum gremlin.ProtoWireNumber = 9
	wireReservedAsMapField_Null gremlin.ProtoWireNumber = 10
)

type ReservedAsMapFieldReader struct {
	buf *gremlin.Reader

	dataIf     map[string]uint32
	dataConst     map[string]uint32
	dataPrivate     map[string]uint32
	dataClass     map[string]uint32
	dataInt     map[string]uint32
	dataVoid     map[string]uint32
	dataString     map[string]uint32
	dataPackage     map[string]uint32
	dataEnum     map[string]uint32
	dataNull     map[string]uint32

	offsetIf   []int
	offsetConst   []int
	offsetPrivate   []int
	offsetClass   []int
	offsetInt   []int
	offsetVoid   []int
	offsetString   []int
	offsetPackage   []int
	offsetEnum   []int
	offsetNull   []int

	parsedIf   bool
	parsedConst   bool
	parsedPrivate   bool
	parsedClass   bool
	parsedInt   bool
	parsedVoid   bool
	parsedString   bool
	parsedPackage   bool
	parsedEnum   bool
	parsedNull   bool
}

func NewReservedAsMapFieldReader() *ReservedAsMapFieldReader {
	return &ReservedAsMapFieldReader{}
}

func (m *ReservedAsMapFieldReader) GetIf() map[string]uint32 {
	if m == nil {
		return nil
	}
	return m.readIf()
}

func (m *ReservedAsMapFieldReader) readIf() map[string]uint32 {
	if m.parsedIf {
		return m.dataIf
	}
	wOffset := m.offsetIf
	
	var entry = map[string]uint32{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData uint32
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry uint32
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadUint32(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataIf = entry
	m.parsedIf = true
	return entry
}

func (m *ReservedAsMapFieldReader) GetConst() map[string]uint32 {
	if m == nil {
		return nil
	}
	return m.readConst()
}

func (m *ReservedAsMapFieldReader) readConst() map[string]uint32 {
	if m.parsedConst {
		return m.dataConst
	}
	wOffset := m.offsetConst
	
	var entry = map[string]uint32{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData uint32
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry uint32
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadUint32(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataConst = entry
	m.parsedConst = true
	return entry
}

func (m *ReservedAsMapFieldReader) GetPrivate() map[string]uint32 {
	if m == nil {
		return nil
	}
	return m.readPrivate()
}

func (m *ReservedAsMapFieldReader) readPrivate() map[string]uint32 {
	if m.parsedPrivate {
		return m.dataPrivate
	}
	wOffset := m.offsetPrivate
	
	var entry = map[string]uint32{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData uint32
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry uint32
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadUint32(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataPrivate = entry
	m.parsedPrivate = true
	return entry
}

func (m *ReservedAsMapFieldReader) GetClass() map[string]uint32 {
	if m == nil {
		return nil
	}
	return m.readClass()
}

func (m *ReservedAsMapFieldReader) readClass() map[string]uint32 {
	if m.parsedClass {
		return m.dataClass
	}
	wOffset := m.offsetClass
	
	var entry = map[string]uint32{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData uint32
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry uint32
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadUint32(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataClass = entry
	m.parsedClass = true
	return entry
}

func (m *ReservedAsMapFieldReader) GetInt() map[string]uint32 {
	if m == nil {
		return nil
	}
	return m.readInt()
}

func (m *ReservedAsMapFieldReader) readInt() map[string]uint32 {
	if m.parsedInt {
		return m.dataInt
	}
	wOffset := m.offsetInt
	
	var entry = map[string]uint32{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData uint32
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry uint32
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadUint32(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataInt = entry
	m.parsedInt = true
	return entry
}

func (m *ReservedAsMapFieldReader) GetVoid() map[string]uint32 {
	if m == nil {
		return nil
	}
	return m.readVoid()
}

func (m *ReservedAsMapFieldReader) readVoid() map[string]uint32 {
	if m.parsedVoid {
		return m.dataVoid
	}
	wOffset := m.offsetVoid
	
	var entry = map[string]uint32{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData uint32
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry uint32
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadUint32(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataVoid = entry
	m.parsedVoid = true
	return entry
}

func (m *ReservedAsMapFieldReader) GetString() map[string]uint32 {
	if m == nil {
		return nil
	}
	return m.readString()
}

func (m *ReservedAsMapFieldReader) readString() map[string]uint32 {
	if m.parsedString {
		return m.dataString
	}
	wOffset := m.offsetString
	
	var entry = map[string]uint32{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData uint32
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry uint32
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadUint32(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataString = entry
	m.parsedString = true
	return entry
}

func (m *ReservedAsMapFieldReader) GetPackage() map[string]uint32 {
	if m == nil {
		return nil
	}
	return m.readPackage()
}

func (m *ReservedAsMapFieldReader) readPackage() map[string]uint32 {
	if m.parsedPackage {
		return m.dataPackage
	}
	wOffset := m.offsetPackage
	
	var entry = map[string]uint32{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData uint32
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry uint32
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadUint32(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataPackage = entry
	m.parsedPackage = true
	return entry
}

func (m *ReservedAsMapFieldReader) GetEnum() map[string]uint32 {
	if m == nil {
		return nil
	}
	return m.readEnum()
}

func (m *ReservedAsMapFieldReader) readEnum() map[string]uint32 {
	if m.parsedEnum {
		return m.dataEnum
	}
	wOffset := m.offsetEnum
	
	var entry = map[string]uint32{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData uint32
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry uint32
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadUint32(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataEnum = entry
	m.parsedEnum = true
	return entry
}

func (m *ReservedAsMapFieldReader) GetNull() map[string]uint32 {
	if m == nil {
		return nil
	}
	return m.readNull()
}

func (m *ReservedAsMapFieldReader) readNull() map[string]uint32 {
	if m.parsedNull {
		return m.dataNull
	}
	wOffset := m.offsetNull
	
	var entry = map[string]uint32{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData uint32
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry uint32
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadUint32(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataNull = entry
	m.parsedNull = true
	return entry
}

func (m *ReservedAsMapFieldReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireReservedAsMapField_If:
			m.offsetIf = append(m.offsetIf, offset)
		case wireReservedAsMapField_Const:
			m.offsetConst = append(m.offsetConst, offset)
		case wireReservedAsMapField_Private:
			m.offsetPrivate = append(m.offsetPrivate, offset)
		case wireReservedAsMapField_Class:
			m.offsetClass = append(m.offsetClass, offset)
		case wireReservedAsMapField_Int:
			m.offsetInt = append(m.offsetInt, offset)
		case wireReservedAsMapField_Void:
			m.offsetVoid = append(m.offsetVoid, offset)
		case wireReservedAsMapField_String:
			m.offsetString = append(m.offsetString, offset)
		case wireReservedAsMapField_Package:
			m.offsetPackage = append(m.offsetPackage, offset)
		case wireReservedAsMapField_Enum:
			m.offsetEnum = append(m.offsetEnum, offset)
		case wireReservedAsMapField_Null:
			m.offsetNull = append(m.offsetNull, offset)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *ReservedAsMapFieldReader) ToStruct() *ReservedAsMapField {
	if m == nil {
		return nil
	}
	res := &ReservedAsMapField{}
	res.If = m.GetIf()
	res.Const = m.GetConst()
	res.Private = m.GetPrivate()
	res.Class = m.GetClass()
	res.Int = m.GetInt()
	res.Void = m.GetVoid()
	res.String = m.GetString()
	res.Package = m.GetPackage()
	res.Enum = m.GetEnum()
	res.Null = m.GetNull()

	return res
}

func (s *ReservedAsMapFieldReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type ReservedAsMapField struct {
	If	map[string]uint32	`json:"if,omitempty"`
	Const	map[string]uint32	`json:"const,omitempty"`
	Private	map[string]uint32	`json:"private,omitempty"`
	Class	map[string]uint32	`json:"class,omitempty"`
	Int	map[string]uint32	`json:"int,omitempty"`
	Void	map[string]uint32	`json:"void,omitempty"`
	String	map[string]uint32	`json:"string,omitempty"`
	Package	map[string]uint32	`json:"package,omitempty"`
	Enum	map[string]uint32	`json:"enum,omitempty"`
	Null	map[string]uint32	`json:"null,omitempty"`
}

func (s *ReservedAsMapField) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *ReservedAsMapField) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if len(s.If) > 0 {
		for k, v := range s.If {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeUint32(v)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireReservedAsMapField_If, mapEntrySize)
			res.AppendString(1, k)
			res.AppendUint32(2, v)
		}
	}
	if len(s.Const) > 0 {
		for k, v := range s.Const {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeUint32(v)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireReservedAsMapField_Const, mapEntrySize)
			res.AppendString(1, k)
			res.AppendUint32(2, v)
		}
	}
	if len(s.Private) > 0 {
		for k, v := range s.Private {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeUint32(v)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireReservedAsMapField_Private, mapEntrySize)
			res.AppendString(1, k)
			res.AppendUint32(2, v)
		}
	}
	if len(s.Class) > 0 {
		for k, v := range s.Class {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeUint32(v)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireReservedAsMapField_Class, mapEntrySize)
			res.AppendString(1, k)
			res.AppendUint32(2, v)
		}
	}
	if len(s.Int) > 0 {
		for k, v := range s.Int {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeUint32(v)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireReservedAsMapField_Int, mapEntrySize)
			res.AppendString(1, k)
			res.AppendUint32(2, v)
		}
	}
	if len(s.Void) > 0 {
		for k, v := range s.Void {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeUint32(v)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireReservedAsMapField_Void, mapEntrySize)
			res.AppendString(1, k)
			res.AppendUint32(2, v)
		}
	}
	if len(s.String) > 0 {
		for k, v := range s.String {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeUint32(v)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireReservedAsMapField_String, mapEntrySize)
			res.AppendString(1, k)
			res.AppendUint32(2, v)
		}
	}
	if len(s.Package) > 0 {
		for k, v := range s.Package {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeUint32(v)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireReservedAsMapField_Package, mapEntrySize)
			res.AppendString(1, k)
			res.AppendUint32(2, v)
		}
	}
	if len(s.Enum) > 0 {
		for k, v := range s.Enum {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeUint32(v)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireReservedAsMapField_Enum, mapEntrySize)
			res.AppendString(1, k)
			res.AppendUint32(2, v)
		}
	}
	if len(s.Null) > 0 {
		for k, v := range s.Null {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeUint32(v)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireReservedAsMapField_Null, mapEntrySize)
			res.AppendString(1, k)
			res.AppendUint32(2, v)
		}
	}
}

func (s *ReservedAsMapField) Copy() *ReservedAsMapField {
	if s == nil {
		return nil
	}
	res := &ReservedAsMapField{}
	res.If = make(map[string]uint32, len(s.If))
	for k, v := range s.If {
		res.If[k] = v
	}
	res.Const = make(map[string]uint32, len(s.Const))
	for k, v := range s.Const {
		res.Const[k] = v
	}
	res.Private = make(map[string]uint32, len(s.Private))
	for k, v := range s.Private {
		res.Private[k] = v
	}
	res.Class = make(map[string]uint32, len(s.Class))
	for k, v := range s.Class {
		res.Class[k] = v
	}
	res.Int = make(map[string]uint32, len(s.Int))
	for k, v := range s.Int {
		res.Int[k] = v
	}
	res.Void = make(map[string]uint32, len(s.Void))
	for k, v := range s.Void {
		res.Void[k] = v
	}
	res.String = make(map[string]uint32, len(s.String))
	for k, v := range s.String {
		res.String[k] = v
	}
	res.Package = make(map[string]uint32, len(s.Package))
	for k, v := range s.Package {
		res.Package[k] = v
	}
	res.Enum = make(map[string]uint32, len(s.Enum))
	for k, v := range s.Enum {
		res.Enum[k] = v
	}
	res.Null = make(map[string]uint32, len(s.Null))
	for k, v := range s.Null {
		res.Null[k] = v
	}

	return res
}

func (s *ReservedAsMapField) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if len(s.If) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.If {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeUint32(v)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireReservedAsMapField_If) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Const) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Const {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeUint32(v)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireReservedAsMapField_Const) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Private) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Private {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeUint32(v)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireReservedAsMapField_Private) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Class) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Class {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeUint32(v)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireReservedAsMapField_Class) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Int) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Int {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeUint32(v)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireReservedAsMapField_Int) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Void) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Void {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeUint32(v)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireReservedAsMapField_Void) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.String) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.String {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeUint32(v)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireReservedAsMapField_String) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Package) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Package {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeUint32(v)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireReservedAsMapField_Package) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Enum) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Enum {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeUint32(v)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireReservedAsMapField_Enum) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Null) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Null {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeUint32(v)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireReservedAsMapField_Null) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	return size
}

const (
	wireReservedAsMapFieldWithEnumValue_If gremlin.ProtoWireNumber = 1
	wireReservedAsMapFieldWithEnumValue_Const gremlin.ProtoWireNumber = 2
	wireReservedAsMapFieldWithEnumValue_Private gremlin.ProtoWireNumber = 3
	wireReservedAsMapFieldWithEnumValue_Class gremlin.ProtoWireNumber = 4
	wireReservedAsMapFieldWithEnumValue_Int gremlin.ProtoWireNumber = 5
	wireReservedAsMapFieldWithEnumValue_Void gremlin.ProtoWireNumber = 6
	wireReservedAsMapFieldWithEnumValue_String gremlin.ProtoWireNumber = 7
	wireReservedAsMapFieldWithEnumValue_Package gremlin.ProtoWireNumber = 8
	wireReservedAsMapFieldWithEnumValue_Enum gremlin.ProtoWireNumber = 9
	wireReservedAsMapFieldWithEnumValue_Null gremlin.ProtoWireNumber = 10
)

type ReservedAsMapFieldWithEnumValueReader struct {
	buf *gremlin.Reader

	dataIf     map[string]ReservedAsMapFieldWithEnumValue_SampleEnum
	dataConst     map[string]ReservedAsMapFieldWithEnumValue_SampleEnum
	dataPrivate     map[string]ReservedAsMapFieldWithEnumValue_SampleEnum
	dataClass     map[string]ReservedAsMapFieldWithEnumValue_SampleEnum
	dataInt     map[string]ReservedAsMapFieldWithEnumValue_SampleEnum
	dataVoid     map[string]ReservedAsMapFieldWithEnumValue_SampleEnum
	dataString     map[string]ReservedAsMapFieldWithEnumValue_SampleEnum
	dataPackage     map[string]ReservedAsMapFieldWithEnumValue_SampleEnum
	dataEnum     map[string]ReservedAsMapFieldWithEnumValue_SampleEnum
	dataNull     map[string]ReservedAsMapFieldWithEnumValue_SampleEnum

	offsetIf   []int
	offsetConst   []int
	offsetPrivate   []int
	offsetClass   []int
	offsetInt   []int
	offsetVoid   []int
	offsetString   []int
	offsetPackage   []int
	offsetEnum   []int
	offsetNull   []int

	parsedIf   bool
	parsedConst   bool
	parsedPrivate   bool
	parsedClass   bool
	parsedInt   bool
	parsedVoid   bool
	parsedString   bool
	parsedPackage   bool
	parsedEnum   bool
	parsedNull   bool
}

func NewReservedAsMapFieldWithEnumValueReader() *ReservedAsMapFieldWithEnumValueReader {
	return &ReservedAsMapFieldWithEnumValueReader{}
}

func (m *ReservedAsMapFieldWithEnumValueReader) GetIf() map[string]ReservedAsMapFieldWithEnumValue_SampleEnum {
	if m == nil {
		return nil
	}
	return m.readIf()
}

func (m *ReservedAsMapFieldWithEnumValueReader) readIf() map[string]ReservedAsMapFieldWithEnumValue_SampleEnum {
	if m.parsedIf {
		return m.dataIf
	}
	wOffset := m.offsetIf
	
	var entry = map[string]ReservedAsMapFieldWithEnumValue_SampleEnum{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData ReservedAsMapFieldWithEnumValue_SampleEnum
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry ReservedAsMapFieldWithEnumValue_SampleEnum
				var valueEntrySize int
				if wOffset > 0 {
					rawEntry, size := m.buf.SizedReadInt32(wOffset)
					valueEntry = ReservedAsMapFieldWithEnumValue_SampleEnum(rawEntry)
					valueEntrySize = size
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataIf = entry
	m.parsedIf = true
	return entry
}

func (m *ReservedAsMapFieldWithEnumValueReader) GetConst() map[string]ReservedAsMapFieldWithEnumValue_SampleEnum {
	if m == nil {
		return nil
	}
	return m.readConst()
}

func (m *ReservedAsMapFieldWithEnumValueReader) readConst() map[string]ReservedAsMapFieldWithEnumValue_SampleEnum {
	if m.parsedConst {
		return m.dataConst
	}
	wOffset := m.offsetConst
	
	var entry = map[string]ReservedAsMapFieldWithEnumValue_SampleEnum{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData ReservedAsMapFieldWithEnumValue_SampleEnum
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry ReservedAsMapFieldWithEnumValue_SampleEnum
				var valueEntrySize int
				if wOffset > 0 {
					rawEntry, size := m.buf.SizedReadInt32(wOffset)
					valueEntry = ReservedAsMapFieldWithEnumValue_SampleEnum(rawEntry)
					valueEntrySize = size
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataConst = entry
	m.parsedConst = true
	return entry
}

func (m *ReservedAsMapFieldWithEnumValueReader) GetPrivate() map[string]ReservedAsMapFieldWithEnumValue_SampleEnum {
	if m == nil {
		return nil
	}
	return m.readPrivate()
}

func (m *ReservedAsMapFieldWithEnumValueReader) readPrivate() map[string]ReservedAsMapFieldWithEnumValue_SampleEnum {
	if m.parsedPrivate {
		return m.dataPrivate
	}
	wOffset := m.offsetPrivate
	
	var entry = map[string]ReservedAsMapFieldWithEnumValue_SampleEnum{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData ReservedAsMapFieldWithEnumValue_SampleEnum
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry ReservedAsMapFieldWithEnumValue_SampleEnum
				var valueEntrySize int
				if wOffset > 0 {
					rawEntry, size := m.buf.SizedReadInt32(wOffset)
					valueEntry = ReservedAsMapFieldWithEnumValue_SampleEnum(rawEntry)
					valueEntrySize = size
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataPrivate = entry
	m.parsedPrivate = true
	return entry
}

func (m *ReservedAsMapFieldWithEnumValueReader) GetClass() map[string]ReservedAsMapFieldWithEnumValue_SampleEnum {
	if m == nil {
		return nil
	}
	return m.readClass()
}

func (m *ReservedAsMapFieldWithEnumValueReader) readClass() map[string]ReservedAsMapFieldWithEnumValue_SampleEnum {
	if m.parsedClass {
		return m.dataClass
	}
	wOffset := m.offsetClass
	
	var entry = map[string]ReservedAsMapFieldWithEnumValue_SampleEnum{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData ReservedAsMapFieldWithEnumValue_SampleEnum
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry ReservedAsMapFieldWithEnumValue_SampleEnum
				var valueEntrySize int
				if wOffset > 0 {
					rawEntry, size := m.buf.SizedReadInt32(wOffset)
					valueEntry = ReservedAsMapFieldWithEnumValue_SampleEnum(rawEntry)
					valueEntrySize = size
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataClass = entry
	m.parsedClass = true
	return entry
}

func (m *ReservedAsMapFieldWithEnumValueReader) GetInt() map[string]ReservedAsMapFieldWithEnumValue_SampleEnum {
	if m == nil {
		return nil
	}
	return m.readInt()
}

func (m *ReservedAsMapFieldWithEnumValueReader) readInt() map[string]ReservedAsMapFieldWithEnumValue_SampleEnum {
	if m.parsedInt {
		return m.dataInt
	}
	wOffset := m.offsetInt
	
	var entry = map[string]ReservedAsMapFieldWithEnumValue_SampleEnum{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData ReservedAsMapFieldWithEnumValue_SampleEnum
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry ReservedAsMapFieldWithEnumValue_SampleEnum
				var valueEntrySize int
				if wOffset > 0 {
					rawEntry, size := m.buf.SizedReadInt32(wOffset)
					valueEntry = ReservedAsMapFieldWithEnumValue_SampleEnum(rawEntry)
					valueEntrySize = size
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataInt = entry
	m.parsedInt = true
	return entry
}

func (m *ReservedAsMapFieldWithEnumValueReader) GetVoid() map[string]ReservedAsMapFieldWithEnumValue_SampleEnum {
	if m == nil {
		return nil
	}
	return m.readVoid()
}

func (m *ReservedAsMapFieldWithEnumValueReader) readVoid() map[string]ReservedAsMapFieldWithEnumValue_SampleEnum {
	if m.parsedVoid {
		return m.dataVoid
	}
	wOffset := m.offsetVoid
	
	var entry = map[string]ReservedAsMapFieldWithEnumValue_SampleEnum{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData ReservedAsMapFieldWithEnumValue_SampleEnum
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry ReservedAsMapFieldWithEnumValue_SampleEnum
				var valueEntrySize int
				if wOffset > 0 {
					rawEntry, size := m.buf.SizedReadInt32(wOffset)
					valueEntry = ReservedAsMapFieldWithEnumValue_SampleEnum(rawEntry)
					valueEntrySize = size
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataVoid = entry
	m.parsedVoid = true
	return entry
}

func (m *ReservedAsMapFieldWithEnumValueReader) GetString() map[string]ReservedAsMapFieldWithEnumValue_SampleEnum {
	if m == nil {
		return nil
	}
	return m.readString()
}

func (m *ReservedAsMapFieldWithEnumValueReader) readString() map[string]ReservedAsMapFieldWithEnumValue_SampleEnum {
	if m.parsedString {
		return m.dataString
	}
	wOffset := m.offsetString
	
	var entry = map[string]ReservedAsMapFieldWithEnumValue_SampleEnum{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData ReservedAsMapFieldWithEnumValue_SampleEnum
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry ReservedAsMapFieldWithEnumValue_SampleEnum
				var valueEntrySize int
				if wOffset > 0 {
					rawEntry, size := m.buf.SizedReadInt32(wOffset)
					valueEntry = ReservedAsMapFieldWithEnumValue_SampleEnum(rawEntry)
					valueEntrySize = size
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataString = entry
	m.parsedString = true
	return entry
}

func (m *ReservedAsMapFieldWithEnumValueReader) GetPackage() map[string]ReservedAsMapFieldWithEnumValue_SampleEnum {
	if m == nil {
		return nil
	}
	return m.readPackage()
}

func (m *ReservedAsMapFieldWithEnumValueReader) readPackage() map[string]ReservedAsMapFieldWithEnumValue_SampleEnum {
	if m.parsedPackage {
		return m.dataPackage
	}
	wOffset := m.offsetPackage
	
	var entry = map[string]ReservedAsMapFieldWithEnumValue_SampleEnum{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData ReservedAsMapFieldWithEnumValue_SampleEnum
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry ReservedAsMapFieldWithEnumValue_SampleEnum
				var valueEntrySize int
				if wOffset > 0 {
					rawEntry, size := m.buf.SizedReadInt32(wOffset)
					valueEntry = ReservedAsMapFieldWithEnumValue_SampleEnum(rawEntry)
					valueEntrySize = size
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataPackage = entry
	m.parsedPackage = true
	return entry
}

func (m *ReservedAsMapFieldWithEnumValueReader) GetEnum() map[string]ReservedAsMapFieldWithEnumValue_SampleEnum {
	if m == nil {
		return nil
	}
	return m.readEnum()
}

func (m *ReservedAsMapFieldWithEnumValueReader) readEnum() map[string]ReservedAsMapFieldWithEnumValue_SampleEnum {
	if m.parsedEnum {
		return m.dataEnum
	}
	wOffset := m.offsetEnum
	
	var entry = map[string]ReservedAsMapFieldWithEnumValue_SampleEnum{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData ReservedAsMapFieldWithEnumValue_SampleEnum
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry ReservedAsMapFieldWithEnumValue_SampleEnum
				var valueEntrySize int
				if wOffset > 0 {
					rawEntry, size := m.buf.SizedReadInt32(wOffset)
					valueEntry = ReservedAsMapFieldWithEnumValue_SampleEnum(rawEntry)
					valueEntrySize = size
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataEnum = entry
	m.parsedEnum = true
	return entry
}

func (m *ReservedAsMapFieldWithEnumValueReader) GetNull() map[string]ReservedAsMapFieldWithEnumValue_SampleEnum {
	if m == nil {
		return nil
	}
	return m.readNull()
}

func (m *ReservedAsMapFieldWithEnumValueReader) readNull() map[string]ReservedAsMapFieldWithEnumValue_SampleEnum {
	if m.parsedNull {
		return m.dataNull
	}
	wOffset := m.offsetNull
	
	var entry = map[string]ReservedAsMapFieldWithEnumValue_SampleEnum{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData ReservedAsMapFieldWithEnumValue_SampleEnum
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry ReservedAsMapFieldWithEnumValue_SampleEnum
				var valueEntrySize int
				if wOffset > 0 {
					rawEntry, size := m.buf.SizedReadInt32(wOffset)
					valueEntry = ReservedAsMapFieldWithEnumValue_SampleEnum(rawEntry)
					valueEntrySize = size
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataNull = entry
	m.parsedNull = true
	return entry
}

func (m *ReservedAsMapFieldWithEnumValueReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireReservedAsMapFieldWithEnumValue_If:
			m.offsetIf = append(m.offsetIf, offset)
		case wireReservedAsMapFieldWithEnumValue_Const:
			m.offsetConst = append(m.offsetConst, offset)
		case wireReservedAsMapFieldWithEnumValue_Private:
			m.offsetPrivate = append(m.offsetPrivate, offset)
		case wireReservedAsMapFieldWithEnumValue_Class:
			m.offsetClass = append(m.offsetClass, offset)
		case wireReservedAsMapFieldWithEnumValue_Int:
			m.offsetInt = append(m.offsetInt, offset)
		case wireReservedAsMapFieldWithEnumValue_Void:
			m.offsetVoid = append(m.offsetVoid, offset)
		case wireReservedAsMapFieldWithEnumValue_String:
			m.offsetString = append(m.offsetString, offset)
		case wireReservedAsMapFieldWithEnumValue_Package:
			m.offsetPackage = append(m.offsetPackage, offset)
		case wireReservedAsMapFieldWithEnumValue_Enum:
			m.offsetEnum = append(m.offsetEnum, offset)
		case wireReservedAsMapFieldWithEnumValue_Null:
			m.offsetNull = append(m.offsetNull, offset)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *ReservedAsMapFieldWithEnumValueReader) ToStruct() *ReservedAsMapFieldWithEnumValue {
	if m == nil {
		return nil
	}
	res := &ReservedAsMapFieldWithEnumValue{}
	res.If = m.GetIf()
	res.Const = m.GetConst()
	res.Private = m.GetPrivate()
	res.Class = m.GetClass()
	res.Int = m.GetInt()
	res.Void = m.GetVoid()
	res.String = m.GetString()
	res.Package = m.GetPackage()
	res.Enum = m.GetEnum()
	res.Null = m.GetNull()

	return res
}

func (s *ReservedAsMapFieldWithEnumValueReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type ReservedAsMapFieldWithEnumValue struct {
	If	map[string]ReservedAsMapFieldWithEnumValue_SampleEnum	`json:"if,omitempty"`
	Const	map[string]ReservedAsMapFieldWithEnumValue_SampleEnum	`json:"const,omitempty"`
	Private	map[string]ReservedAsMapFieldWithEnumValue_SampleEnum	`json:"private,omitempty"`
	Class	map[string]ReservedAsMapFieldWithEnumValue_SampleEnum	`json:"class,omitempty"`
	Int	map[string]ReservedAsMapFieldWithEnumValue_SampleEnum	`json:"int,omitempty"`
	Void	map[string]ReservedAsMapFieldWithEnumValue_SampleEnum	`json:"void,omitempty"`
	String	map[string]ReservedAsMapFieldWithEnumValue_SampleEnum	`json:"string,omitempty"`
	Package	map[string]ReservedAsMapFieldWithEnumValue_SampleEnum	`json:"package,omitempty"`
	Enum	map[string]ReservedAsMapFieldWithEnumValue_SampleEnum	`json:"enum,omitempty"`
	Null	map[string]ReservedAsMapFieldWithEnumValue_SampleEnum	`json:"null,omitempty"`
}

func (s *ReservedAsMapFieldWithEnumValue) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *ReservedAsMapFieldWithEnumValue) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if len(s.If) > 0 {
		for k, v := range s.If {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(int32(v))
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireReservedAsMapFieldWithEnumValue_If, mapEntrySize)
			res.AppendString(1, k)
			res.AppendInt32(2, int32(v))
		}
	}
	if len(s.Const) > 0 {
		for k, v := range s.Const {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(int32(v))
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireReservedAsMapFieldWithEnumValue_Const, mapEntrySize)
			res.AppendString(1, k)
			res.AppendInt32(2, int32(v))
		}
	}
	if len(s.Private) > 0 {
		for k, v := range s.Private {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(int32(v))
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireReservedAsMapFieldWithEnumValue_Private, mapEntrySize)
			res.AppendString(1, k)
			res.AppendInt32(2, int32(v))
		}
	}
	if len(s.Class) > 0 {
		for k, v := range s.Class {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(int32(v))
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireReservedAsMapFieldWithEnumValue_Class, mapEntrySize)
			res.AppendString(1, k)
			res.AppendInt32(2, int32(v))
		}
	}
	if len(s.Int) > 0 {
		for k, v := range s.Int {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(int32(v))
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireReservedAsMapFieldWithEnumValue_Int, mapEntrySize)
			res.AppendString(1, k)
			res.AppendInt32(2, int32(v))
		}
	}
	if len(s.Void) > 0 {
		for k, v := range s.Void {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(int32(v))
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireReservedAsMapFieldWithEnumValue_Void, mapEntrySize)
			res.AppendString(1, k)
			res.AppendInt32(2, int32(v))
		}
	}
	if len(s.String) > 0 {
		for k, v := range s.String {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(int32(v))
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireReservedAsMapFieldWithEnumValue_String, mapEntrySize)
			res.AppendString(1, k)
			res.AppendInt32(2, int32(v))
		}
	}
	if len(s.Package) > 0 {
		for k, v := range s.Package {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(int32(v))
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireReservedAsMapFieldWithEnumValue_Package, mapEntrySize)
			res.AppendString(1, k)
			res.AppendInt32(2, int32(v))
		}
	}
	if len(s.Enum) > 0 {
		for k, v := range s.Enum {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(int32(v))
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireReservedAsMapFieldWithEnumValue_Enum, mapEntrySize)
			res.AppendString(1, k)
			res.AppendInt32(2, int32(v))
		}
	}
	if len(s.Null) > 0 {
		for k, v := range s.Null {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(int32(v))
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireReservedAsMapFieldWithEnumValue_Null, mapEntrySize)
			res.AppendString(1, k)
			res.AppendInt32(2, int32(v))
		}
	}
}

func (s *ReservedAsMapFieldWithEnumValue) Copy() *ReservedAsMapFieldWithEnumValue {
	if s == nil {
		return nil
	}
	res := &ReservedAsMapFieldWithEnumValue{}
	res.If = make(map[string]ReservedAsMapFieldWithEnumValue_SampleEnum, len(s.If))
	for k, v := range s.If {
		res.If[k] = v
	}
	res.Const = make(map[string]ReservedAsMapFieldWithEnumValue_SampleEnum, len(s.Const))
	for k, v := range s.Const {
		res.Const[k] = v
	}
	res.Private = make(map[string]ReservedAsMapFieldWithEnumValue_SampleEnum, len(s.Private))
	for k, v := range s.Private {
		res.Private[k] = v
	}
	res.Class = make(map[string]ReservedAsMapFieldWithEnumValue_SampleEnum, len(s.Class))
	for k, v := range s.Class {
		res.Class[k] = v
	}
	res.Int = make(map[string]ReservedAsMapFieldWithEnumValue_SampleEnum, len(s.Int))
	for k, v := range s.Int {
		res.Int[k] = v
	}
	res.Void = make(map[string]ReservedAsMapFieldWithEnumValue_SampleEnum, len(s.Void))
	for k, v := range s.Void {
		res.Void[k] = v
	}
	res.String = make(map[string]ReservedAsMapFieldWithEnumValue_SampleEnum, len(s.String))
	for k, v := range s.String {
		res.String[k] = v
	}
	res.Package = make(map[string]ReservedAsMapFieldWithEnumValue_SampleEnum, len(s.Package))
	for k, v := range s.Package {
		res.Package[k] = v
	}
	res.Enum = make(map[string]ReservedAsMapFieldWithEnumValue_SampleEnum, len(s.Enum))
	for k, v := range s.Enum {
		res.Enum[k] = v
	}
	res.Null = make(map[string]ReservedAsMapFieldWithEnumValue_SampleEnum, len(s.Null))
	for k, v := range s.Null {
		res.Null[k] = v
	}

	return res
}

func (s *ReservedAsMapFieldWithEnumValue) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if len(s.If) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.If {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(int32(v))
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireReservedAsMapFieldWithEnumValue_If) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Const) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Const {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(int32(v))
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireReservedAsMapFieldWithEnumValue_Const) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Private) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Private {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(int32(v))
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireReservedAsMapFieldWithEnumValue_Private) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Class) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Class {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(int32(v))
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireReservedAsMapFieldWithEnumValue_Class) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Int) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Int {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(int32(v))
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireReservedAsMapFieldWithEnumValue_Int) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Void) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Void {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(int32(v))
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireReservedAsMapFieldWithEnumValue_Void) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.String) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.String {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(int32(v))
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireReservedAsMapFieldWithEnumValue_String) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Package) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Package {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(int32(v))
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireReservedAsMapFieldWithEnumValue_Package) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Enum) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Enum {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(int32(v))
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireReservedAsMapFieldWithEnumValue_Enum) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if len(s.Null) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.Null {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeTag(2) + gremlin.SizeInt32(int32(v))
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireReservedAsMapFieldWithEnumValue_Null) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	return size
}

const (
	wireMapContainer_MyMap gremlin.ProtoWireNumber = 1
)

type MapContainerReader struct {
	buf *gremlin.Reader

	dataMyMap     map[string]string

	offsetMyMap   []int

	parsedMyMap   bool
}

func NewMapContainerReader() *MapContainerReader {
	return &MapContainerReader{}
}

func (m *MapContainerReader) GetMyMap() map[string]string {
	if m == nil {
		return nil
	}
	return m.readMyMap()
}

func (m *MapContainerReader) readMyMap() map[string]string {
	if m.parsedMyMap {
		return m.dataMyMap
	}
	wOffset := m.offsetMyMap
	
	var entry = map[string]string{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData string
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry string
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataMyMap = entry
	m.parsedMyMap = true
	return entry
}

func (m *MapContainerReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireMapContainer_MyMap:
			m.offsetMyMap = append(m.offsetMyMap, offset)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *MapContainerReader) ToStruct() *MapContainer {
	if m == nil {
		return nil
	}
	res := &MapContainer{}
	res.MyMap = m.GetMyMap()

	return res
}

func (s *MapContainerReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type MapContainer struct {
	MyMap	map[string]string	`json:"my_map,omitempty"`
}

func (s *MapContainer) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *MapContainer) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if len(s.MyMap) > 0 {
		for k, v := range s.MyMap {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeString(v)
			valueSize += gremlin.SizeUint64(uint64(valueSize)) + gremlin.SizeTag(2)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireMapContainer_MyMap, mapEntrySize)
			res.AppendString(1, k)
			res.AppendString(2, v)
		}
	}
}

func (s *MapContainer) Copy() *MapContainer {
	if s == nil {
		return nil
	}
	res := &MapContainer{}
	res.MyMap = make(map[string]string, len(s.MyMap))
	for k, v := range s.MyMap {
		res.MyMap[k] = v
	}

	return res
}

func (s *MapContainer) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if len(s.MyMap) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.MyMap {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeString(v)
			valueSize += gremlin.SizeUint64(uint64(valueSize)) + gremlin.SizeTag(2)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireMapContainer_MyMap) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	return size
}
