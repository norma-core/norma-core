// Code generated by gremlin. DO NOT EDIT.
// source: unittest.proto

package protobuf_unittest

import (
	protobuf_unittest_import "github.com/norma-core/norma-core/shared/gremlin_go/bench/gremlin_pb/protobuf_unittest_import"
	bytes "bytes"
	math "math"
	gremlin "github.com/norma-core/norma-core/shared/gremlin_go"
)

type TestAllTypes_NestedEnum int32

const (
	TestAllTypes_FOO TestAllTypes_NestedEnum = 1
	TestAllTypes_BAR TestAllTypes_NestedEnum = 2
	TestAllTypes_BAZ TestAllTypes_NestedEnum = 3
	TestAllTypes_NEG TestAllTypes_NestedEnum = -1
)

func (e TestAllTypes_NestedEnum) String() string {
	switch e {
	case TestAllTypes_FOO:
		return "FOO"
	case TestAllTypes_BAR:
		return "BAR"
	case TestAllTypes_BAZ:
		return "BAZ"
	case TestAllTypes_NEG:
		return "NEG"
	default:
		return ""
	}
}

type ForeignEnum int32

const (
	ForeignEnum_FOREIGN_FOO ForeignEnum = 4
	ForeignEnum_FOREIGN_BAR ForeignEnum = 5
	ForeignEnum_FOREIGN_BAZ ForeignEnum = 6
)

func (e ForeignEnum) String() string {
	switch e {
	case ForeignEnum_FOREIGN_FOO:
		return "FOREIGN_FOO"
	case ForeignEnum_FOREIGN_BAR:
		return "FOREIGN_BAR"
	case ForeignEnum_FOREIGN_BAZ:
		return "FOREIGN_BAZ"
	default:
		return ""
	}
}

type TestEnumWithDupValue int32

const (
	TestEnumWithDupValue_FOO1 TestEnumWithDupValue = 1
	TestEnumWithDupValue_BAR1 TestEnumWithDupValue = 2
	TestEnumWithDupValue_BAZ TestEnumWithDupValue = 3
	TestEnumWithDupValue_FOO2 TestEnumWithDupValue = 1
	TestEnumWithDupValue_BAR2 TestEnumWithDupValue = 2
)

func (e TestEnumWithDupValue) String() string {
	switch e {
	case TestEnumWithDupValue_FOO1:
		return "FOO1"
	case TestEnumWithDupValue_BAR1:
		return "BAR1"
	case TestEnumWithDupValue_BAZ:
		return "BAZ"
	default:
		return ""
	}
}

type TestSparseEnum int32

const (
	TestSparseEnum_SPARSE_A TestSparseEnum = 123
	TestSparseEnum_SPARSE_B TestSparseEnum = 62374
	TestSparseEnum_SPARSE_C TestSparseEnum = 12589234
	TestSparseEnum_SPARSE_D TestSparseEnum = -15
	TestSparseEnum_SPARSE_E TestSparseEnum = -53452
	TestSparseEnum_SPARSE_F TestSparseEnum = 0
	TestSparseEnum_SPARSE_G TestSparseEnum = 2
)

func (e TestSparseEnum) String() string {
	switch e {
	case TestSparseEnum_SPARSE_A:
		return "SPARSE_A"
	case TestSparseEnum_SPARSE_B:
		return "SPARSE_B"
	case TestSparseEnum_SPARSE_C:
		return "SPARSE_C"
	case TestSparseEnum_SPARSE_D:
		return "SPARSE_D"
	case TestSparseEnum_SPARSE_E:
		return "SPARSE_E"
	case TestSparseEnum_SPARSE_F:
		return "SPARSE_F"
	case TestSparseEnum_SPARSE_G:
		return "SPARSE_G"
	default:
		return ""
	}
}

type TestOneof2_NestedEnum int32

const (
	TestOneof2_FOO TestOneof2_NestedEnum = 1
	TestOneof2_BAR TestOneof2_NestedEnum = 2
	TestOneof2_BAZ TestOneof2_NestedEnum = 3
)

func (e TestOneof2_NestedEnum) String() string {
	switch e {
	case TestOneof2_FOO:
		return "FOO"
	case TestOneof2_BAR:
		return "BAR"
	case TestOneof2_BAZ:
		return "BAZ"
	default:
		return ""
	}
}

type TestDynamicExtensions_DynamicEnumType int32

const (
	TestDynamicExtensions_DYNAMIC_FOO TestDynamicExtensions_DynamicEnumType = 2200
	TestDynamicExtensions_DYNAMIC_BAR TestDynamicExtensions_DynamicEnumType = 2201
	TestDynamicExtensions_DYNAMIC_BAZ TestDynamicExtensions_DynamicEnumType = 2202
)

func (e TestDynamicExtensions_DynamicEnumType) String() string {
	switch e {
	case TestDynamicExtensions_DYNAMIC_FOO:
		return "DYNAMIC_FOO"
	case TestDynamicExtensions_DYNAMIC_BAR:
		return "DYNAMIC_BAR"
	case TestDynamicExtensions_DYNAMIC_BAZ:
		return "DYNAMIC_BAZ"
	default:
		return ""
	}
}

type VeryLargeEnum int32

const (
	VeryLargeEnum_ENUM_LABEL_DEFAULT VeryLargeEnum = 0
	VeryLargeEnum_ENUM_LABEL_1 VeryLargeEnum = 1
	VeryLargeEnum_ENUM_LABEL_2 VeryLargeEnum = 2
	VeryLargeEnum_ENUM_LABEL_3 VeryLargeEnum = 3
	VeryLargeEnum_ENUM_LABEL_4 VeryLargeEnum = 4
	VeryLargeEnum_ENUM_LABEL_5 VeryLargeEnum = 5
	VeryLargeEnum_ENUM_LABEL_6 VeryLargeEnum = 6
	VeryLargeEnum_ENUM_LABEL_7 VeryLargeEnum = 7
	VeryLargeEnum_ENUM_LABEL_8 VeryLargeEnum = 8
	VeryLargeEnum_ENUM_LABEL_9 VeryLargeEnum = 9
	VeryLargeEnum_ENUM_LABEL_10 VeryLargeEnum = 10
	VeryLargeEnum_ENUM_LABEL_11 VeryLargeEnum = 11
	VeryLargeEnum_ENUM_LABEL_12 VeryLargeEnum = 12
	VeryLargeEnum_ENUM_LABEL_13 VeryLargeEnum = 13
	VeryLargeEnum_ENUM_LABEL_14 VeryLargeEnum = 14
	VeryLargeEnum_ENUM_LABEL_15 VeryLargeEnum = 15
	VeryLargeEnum_ENUM_LABEL_16 VeryLargeEnum = 16
	VeryLargeEnum_ENUM_LABEL_17 VeryLargeEnum = 17
	VeryLargeEnum_ENUM_LABEL_18 VeryLargeEnum = 18
	VeryLargeEnum_ENUM_LABEL_19 VeryLargeEnum = 19
	VeryLargeEnum_ENUM_LABEL_20 VeryLargeEnum = 20
	VeryLargeEnum_ENUM_LABEL_21 VeryLargeEnum = 21
	VeryLargeEnum_ENUM_LABEL_22 VeryLargeEnum = 22
	VeryLargeEnum_ENUM_LABEL_23 VeryLargeEnum = 23
	VeryLargeEnum_ENUM_LABEL_24 VeryLargeEnum = 24
	VeryLargeEnum_ENUM_LABEL_25 VeryLargeEnum = 25
	VeryLargeEnum_ENUM_LABEL_26 VeryLargeEnum = 26
	VeryLargeEnum_ENUM_LABEL_27 VeryLargeEnum = 27
	VeryLargeEnum_ENUM_LABEL_28 VeryLargeEnum = 28
	VeryLargeEnum_ENUM_LABEL_29 VeryLargeEnum = 29
	VeryLargeEnum_ENUM_LABEL_30 VeryLargeEnum = 30
	VeryLargeEnum_ENUM_LABEL_31 VeryLargeEnum = 31
	VeryLargeEnum_ENUM_LABEL_32 VeryLargeEnum = 32
	VeryLargeEnum_ENUM_LABEL_33 VeryLargeEnum = 33
	VeryLargeEnum_ENUM_LABEL_34 VeryLargeEnum = 34
	VeryLargeEnum_ENUM_LABEL_35 VeryLargeEnum = 35
	VeryLargeEnum_ENUM_LABEL_36 VeryLargeEnum = 36
	VeryLargeEnum_ENUM_LABEL_37 VeryLargeEnum = 37
	VeryLargeEnum_ENUM_LABEL_38 VeryLargeEnum = 38
	VeryLargeEnum_ENUM_LABEL_39 VeryLargeEnum = 39
	VeryLargeEnum_ENUM_LABEL_40 VeryLargeEnum = 40
	VeryLargeEnum_ENUM_LABEL_41 VeryLargeEnum = 41
	VeryLargeEnum_ENUM_LABEL_42 VeryLargeEnum = 42
	VeryLargeEnum_ENUM_LABEL_43 VeryLargeEnum = 43
	VeryLargeEnum_ENUM_LABEL_44 VeryLargeEnum = 44
	VeryLargeEnum_ENUM_LABEL_45 VeryLargeEnum = 45
	VeryLargeEnum_ENUM_LABEL_46 VeryLargeEnum = 46
	VeryLargeEnum_ENUM_LABEL_47 VeryLargeEnum = 47
	VeryLargeEnum_ENUM_LABEL_48 VeryLargeEnum = 48
	VeryLargeEnum_ENUM_LABEL_49 VeryLargeEnum = 49
	VeryLargeEnum_ENUM_LABEL_50 VeryLargeEnum = 50
	VeryLargeEnum_ENUM_LABEL_51 VeryLargeEnum = 51
	VeryLargeEnum_ENUM_LABEL_52 VeryLargeEnum = 52
	VeryLargeEnum_ENUM_LABEL_53 VeryLargeEnum = 53
	VeryLargeEnum_ENUM_LABEL_54 VeryLargeEnum = 54
	VeryLargeEnum_ENUM_LABEL_55 VeryLargeEnum = 55
	VeryLargeEnum_ENUM_LABEL_56 VeryLargeEnum = 56
	VeryLargeEnum_ENUM_LABEL_57 VeryLargeEnum = 57
	VeryLargeEnum_ENUM_LABEL_58 VeryLargeEnum = 58
	VeryLargeEnum_ENUM_LABEL_59 VeryLargeEnum = 59
	VeryLargeEnum_ENUM_LABEL_60 VeryLargeEnum = 60
	VeryLargeEnum_ENUM_LABEL_61 VeryLargeEnum = 61
	VeryLargeEnum_ENUM_LABEL_62 VeryLargeEnum = 62
	VeryLargeEnum_ENUM_LABEL_63 VeryLargeEnum = 63
	VeryLargeEnum_ENUM_LABEL_64 VeryLargeEnum = 64
	VeryLargeEnum_ENUM_LABEL_65 VeryLargeEnum = 65
	VeryLargeEnum_ENUM_LABEL_66 VeryLargeEnum = 66
	VeryLargeEnum_ENUM_LABEL_67 VeryLargeEnum = 67
	VeryLargeEnum_ENUM_LABEL_68 VeryLargeEnum = 68
	VeryLargeEnum_ENUM_LABEL_69 VeryLargeEnum = 69
	VeryLargeEnum_ENUM_LABEL_70 VeryLargeEnum = 70
	VeryLargeEnum_ENUM_LABEL_71 VeryLargeEnum = 71
	VeryLargeEnum_ENUM_LABEL_72 VeryLargeEnum = 72
	VeryLargeEnum_ENUM_LABEL_73 VeryLargeEnum = 73
	VeryLargeEnum_ENUM_LABEL_74 VeryLargeEnum = 74
	VeryLargeEnum_ENUM_LABEL_75 VeryLargeEnum = 75
	VeryLargeEnum_ENUM_LABEL_76 VeryLargeEnum = 76
	VeryLargeEnum_ENUM_LABEL_77 VeryLargeEnum = 77
	VeryLargeEnum_ENUM_LABEL_78 VeryLargeEnum = 78
	VeryLargeEnum_ENUM_LABEL_79 VeryLargeEnum = 79
	VeryLargeEnum_ENUM_LABEL_80 VeryLargeEnum = 80
	VeryLargeEnum_ENUM_LABEL_81 VeryLargeEnum = 81
	VeryLargeEnum_ENUM_LABEL_82 VeryLargeEnum = 82
	VeryLargeEnum_ENUM_LABEL_83 VeryLargeEnum = 83
	VeryLargeEnum_ENUM_LABEL_84 VeryLargeEnum = 84
	VeryLargeEnum_ENUM_LABEL_85 VeryLargeEnum = 85
	VeryLargeEnum_ENUM_LABEL_86 VeryLargeEnum = 86
	VeryLargeEnum_ENUM_LABEL_87 VeryLargeEnum = 87
	VeryLargeEnum_ENUM_LABEL_88 VeryLargeEnum = 88
	VeryLargeEnum_ENUM_LABEL_89 VeryLargeEnum = 89
	VeryLargeEnum_ENUM_LABEL_90 VeryLargeEnum = 90
	VeryLargeEnum_ENUM_LABEL_91 VeryLargeEnum = 91
	VeryLargeEnum_ENUM_LABEL_92 VeryLargeEnum = 92
	VeryLargeEnum_ENUM_LABEL_93 VeryLargeEnum = 93
	VeryLargeEnum_ENUM_LABEL_94 VeryLargeEnum = 94
	VeryLargeEnum_ENUM_LABEL_95 VeryLargeEnum = 95
	VeryLargeEnum_ENUM_LABEL_96 VeryLargeEnum = 96
	VeryLargeEnum_ENUM_LABEL_97 VeryLargeEnum = 97
	VeryLargeEnum_ENUM_LABEL_98 VeryLargeEnum = 98
	VeryLargeEnum_ENUM_LABEL_99 VeryLargeEnum = 99
	VeryLargeEnum_ENUM_LABEL_100 VeryLargeEnum = 100
)

func (e VeryLargeEnum) String() string {
	switch e {
	case VeryLargeEnum_ENUM_LABEL_DEFAULT:
		return "ENUM_LABEL_DEFAULT"
	case VeryLargeEnum_ENUM_LABEL_1:
		return "ENUM_LABEL_1"
	case VeryLargeEnum_ENUM_LABEL_2:
		return "ENUM_LABEL_2"
	case VeryLargeEnum_ENUM_LABEL_3:
		return "ENUM_LABEL_3"
	case VeryLargeEnum_ENUM_LABEL_4:
		return "ENUM_LABEL_4"
	case VeryLargeEnum_ENUM_LABEL_5:
		return "ENUM_LABEL_5"
	case VeryLargeEnum_ENUM_LABEL_6:
		return "ENUM_LABEL_6"
	case VeryLargeEnum_ENUM_LABEL_7:
		return "ENUM_LABEL_7"
	case VeryLargeEnum_ENUM_LABEL_8:
		return "ENUM_LABEL_8"
	case VeryLargeEnum_ENUM_LABEL_9:
		return "ENUM_LABEL_9"
	case VeryLargeEnum_ENUM_LABEL_10:
		return "ENUM_LABEL_10"
	case VeryLargeEnum_ENUM_LABEL_11:
		return "ENUM_LABEL_11"
	case VeryLargeEnum_ENUM_LABEL_12:
		return "ENUM_LABEL_12"
	case VeryLargeEnum_ENUM_LABEL_13:
		return "ENUM_LABEL_13"
	case VeryLargeEnum_ENUM_LABEL_14:
		return "ENUM_LABEL_14"
	case VeryLargeEnum_ENUM_LABEL_15:
		return "ENUM_LABEL_15"
	case VeryLargeEnum_ENUM_LABEL_16:
		return "ENUM_LABEL_16"
	case VeryLargeEnum_ENUM_LABEL_17:
		return "ENUM_LABEL_17"
	case VeryLargeEnum_ENUM_LABEL_18:
		return "ENUM_LABEL_18"
	case VeryLargeEnum_ENUM_LABEL_19:
		return "ENUM_LABEL_19"
	case VeryLargeEnum_ENUM_LABEL_20:
		return "ENUM_LABEL_20"
	case VeryLargeEnum_ENUM_LABEL_21:
		return "ENUM_LABEL_21"
	case VeryLargeEnum_ENUM_LABEL_22:
		return "ENUM_LABEL_22"
	case VeryLargeEnum_ENUM_LABEL_23:
		return "ENUM_LABEL_23"
	case VeryLargeEnum_ENUM_LABEL_24:
		return "ENUM_LABEL_24"
	case VeryLargeEnum_ENUM_LABEL_25:
		return "ENUM_LABEL_25"
	case VeryLargeEnum_ENUM_LABEL_26:
		return "ENUM_LABEL_26"
	case VeryLargeEnum_ENUM_LABEL_27:
		return "ENUM_LABEL_27"
	case VeryLargeEnum_ENUM_LABEL_28:
		return "ENUM_LABEL_28"
	case VeryLargeEnum_ENUM_LABEL_29:
		return "ENUM_LABEL_29"
	case VeryLargeEnum_ENUM_LABEL_30:
		return "ENUM_LABEL_30"
	case VeryLargeEnum_ENUM_LABEL_31:
		return "ENUM_LABEL_31"
	case VeryLargeEnum_ENUM_LABEL_32:
		return "ENUM_LABEL_32"
	case VeryLargeEnum_ENUM_LABEL_33:
		return "ENUM_LABEL_33"
	case VeryLargeEnum_ENUM_LABEL_34:
		return "ENUM_LABEL_34"
	case VeryLargeEnum_ENUM_LABEL_35:
		return "ENUM_LABEL_35"
	case VeryLargeEnum_ENUM_LABEL_36:
		return "ENUM_LABEL_36"
	case VeryLargeEnum_ENUM_LABEL_37:
		return "ENUM_LABEL_37"
	case VeryLargeEnum_ENUM_LABEL_38:
		return "ENUM_LABEL_38"
	case VeryLargeEnum_ENUM_LABEL_39:
		return "ENUM_LABEL_39"
	case VeryLargeEnum_ENUM_LABEL_40:
		return "ENUM_LABEL_40"
	case VeryLargeEnum_ENUM_LABEL_41:
		return "ENUM_LABEL_41"
	case VeryLargeEnum_ENUM_LABEL_42:
		return "ENUM_LABEL_42"
	case VeryLargeEnum_ENUM_LABEL_43:
		return "ENUM_LABEL_43"
	case VeryLargeEnum_ENUM_LABEL_44:
		return "ENUM_LABEL_44"
	case VeryLargeEnum_ENUM_LABEL_45:
		return "ENUM_LABEL_45"
	case VeryLargeEnum_ENUM_LABEL_46:
		return "ENUM_LABEL_46"
	case VeryLargeEnum_ENUM_LABEL_47:
		return "ENUM_LABEL_47"
	case VeryLargeEnum_ENUM_LABEL_48:
		return "ENUM_LABEL_48"
	case VeryLargeEnum_ENUM_LABEL_49:
		return "ENUM_LABEL_49"
	case VeryLargeEnum_ENUM_LABEL_50:
		return "ENUM_LABEL_50"
	case VeryLargeEnum_ENUM_LABEL_51:
		return "ENUM_LABEL_51"
	case VeryLargeEnum_ENUM_LABEL_52:
		return "ENUM_LABEL_52"
	case VeryLargeEnum_ENUM_LABEL_53:
		return "ENUM_LABEL_53"
	case VeryLargeEnum_ENUM_LABEL_54:
		return "ENUM_LABEL_54"
	case VeryLargeEnum_ENUM_LABEL_55:
		return "ENUM_LABEL_55"
	case VeryLargeEnum_ENUM_LABEL_56:
		return "ENUM_LABEL_56"
	case VeryLargeEnum_ENUM_LABEL_57:
		return "ENUM_LABEL_57"
	case VeryLargeEnum_ENUM_LABEL_58:
		return "ENUM_LABEL_58"
	case VeryLargeEnum_ENUM_LABEL_59:
		return "ENUM_LABEL_59"
	case VeryLargeEnum_ENUM_LABEL_60:
		return "ENUM_LABEL_60"
	case VeryLargeEnum_ENUM_LABEL_61:
		return "ENUM_LABEL_61"
	case VeryLargeEnum_ENUM_LABEL_62:
		return "ENUM_LABEL_62"
	case VeryLargeEnum_ENUM_LABEL_63:
		return "ENUM_LABEL_63"
	case VeryLargeEnum_ENUM_LABEL_64:
		return "ENUM_LABEL_64"
	case VeryLargeEnum_ENUM_LABEL_65:
		return "ENUM_LABEL_65"
	case VeryLargeEnum_ENUM_LABEL_66:
		return "ENUM_LABEL_66"
	case VeryLargeEnum_ENUM_LABEL_67:
		return "ENUM_LABEL_67"
	case VeryLargeEnum_ENUM_LABEL_68:
		return "ENUM_LABEL_68"
	case VeryLargeEnum_ENUM_LABEL_69:
		return "ENUM_LABEL_69"
	case VeryLargeEnum_ENUM_LABEL_70:
		return "ENUM_LABEL_70"
	case VeryLargeEnum_ENUM_LABEL_71:
		return "ENUM_LABEL_71"
	case VeryLargeEnum_ENUM_LABEL_72:
		return "ENUM_LABEL_72"
	case VeryLargeEnum_ENUM_LABEL_73:
		return "ENUM_LABEL_73"
	case VeryLargeEnum_ENUM_LABEL_74:
		return "ENUM_LABEL_74"
	case VeryLargeEnum_ENUM_LABEL_75:
		return "ENUM_LABEL_75"
	case VeryLargeEnum_ENUM_LABEL_76:
		return "ENUM_LABEL_76"
	case VeryLargeEnum_ENUM_LABEL_77:
		return "ENUM_LABEL_77"
	case VeryLargeEnum_ENUM_LABEL_78:
		return "ENUM_LABEL_78"
	case VeryLargeEnum_ENUM_LABEL_79:
		return "ENUM_LABEL_79"
	case VeryLargeEnum_ENUM_LABEL_80:
		return "ENUM_LABEL_80"
	case VeryLargeEnum_ENUM_LABEL_81:
		return "ENUM_LABEL_81"
	case VeryLargeEnum_ENUM_LABEL_82:
		return "ENUM_LABEL_82"
	case VeryLargeEnum_ENUM_LABEL_83:
		return "ENUM_LABEL_83"
	case VeryLargeEnum_ENUM_LABEL_84:
		return "ENUM_LABEL_84"
	case VeryLargeEnum_ENUM_LABEL_85:
		return "ENUM_LABEL_85"
	case VeryLargeEnum_ENUM_LABEL_86:
		return "ENUM_LABEL_86"
	case VeryLargeEnum_ENUM_LABEL_87:
		return "ENUM_LABEL_87"
	case VeryLargeEnum_ENUM_LABEL_88:
		return "ENUM_LABEL_88"
	case VeryLargeEnum_ENUM_LABEL_89:
		return "ENUM_LABEL_89"
	case VeryLargeEnum_ENUM_LABEL_90:
		return "ENUM_LABEL_90"
	case VeryLargeEnum_ENUM_LABEL_91:
		return "ENUM_LABEL_91"
	case VeryLargeEnum_ENUM_LABEL_92:
		return "ENUM_LABEL_92"
	case VeryLargeEnum_ENUM_LABEL_93:
		return "ENUM_LABEL_93"
	case VeryLargeEnum_ENUM_LABEL_94:
		return "ENUM_LABEL_94"
	case VeryLargeEnum_ENUM_LABEL_95:
		return "ENUM_LABEL_95"
	case VeryLargeEnum_ENUM_LABEL_96:
		return "ENUM_LABEL_96"
	case VeryLargeEnum_ENUM_LABEL_97:
		return "ENUM_LABEL_97"
	case VeryLargeEnum_ENUM_LABEL_98:
		return "ENUM_LABEL_98"
	case VeryLargeEnum_ENUM_LABEL_99:
		return "ENUM_LABEL_99"
	case VeryLargeEnum_ENUM_LABEL_100:
		return "ENUM_LABEL_100"
	default:
		return ""
	}
}

const (
	wireTestAllTypes_OptionalInt32 gremlin.ProtoWireNumber = 1
	wireTestAllTypes_OptionalInt64 gremlin.ProtoWireNumber = 2
	wireTestAllTypes_OptionalUint32 gremlin.ProtoWireNumber = 3
	wireTestAllTypes_OptionalUint64 gremlin.ProtoWireNumber = 4
	wireTestAllTypes_OptionalSint32 gremlin.ProtoWireNumber = 5
	wireTestAllTypes_OptionalSint64 gremlin.ProtoWireNumber = 6
	wireTestAllTypes_OptionalFixed32 gremlin.ProtoWireNumber = 7
	wireTestAllTypes_OptionalFixed64 gremlin.ProtoWireNumber = 8
	wireTestAllTypes_OptionalSfixed32 gremlin.ProtoWireNumber = 9
	wireTestAllTypes_OptionalSfixed64 gremlin.ProtoWireNumber = 10
	wireTestAllTypes_OptionalFloat gremlin.ProtoWireNumber = 11
	wireTestAllTypes_OptionalDouble gremlin.ProtoWireNumber = 12
	wireTestAllTypes_OptionalBool gremlin.ProtoWireNumber = 13
	wireTestAllTypes_OptionalString gremlin.ProtoWireNumber = 14
	wireTestAllTypes_OptionalBytes gremlin.ProtoWireNumber = 15
	wireTestAllTypes_OptionalNestedMessage gremlin.ProtoWireNumber = 18
	wireTestAllTypes_OptionalForeignMessage gremlin.ProtoWireNumber = 19
	wireTestAllTypes_OptionalImportMessage gremlin.ProtoWireNumber = 20
	wireTestAllTypes_OptionalNestedEnum gremlin.ProtoWireNumber = 21
	wireTestAllTypes_OptionalForeignEnum gremlin.ProtoWireNumber = 22
	wireTestAllTypes_OptionalImportEnum gremlin.ProtoWireNumber = 23
	wireTestAllTypes_OptionalStringPiece gremlin.ProtoWireNumber = 24
	wireTestAllTypes_OptionalCord gremlin.ProtoWireNumber = 25
	wireTestAllTypes_OptionalPublicImportMessage gremlin.ProtoWireNumber = 26
	wireTestAllTypes_OptionalLazyMessage gremlin.ProtoWireNumber = 27
	wireTestAllTypes_OptionalUnverifiedLazyMessage gremlin.ProtoWireNumber = 28
	wireTestAllTypes_RepeatedInt32 gremlin.ProtoWireNumber = 31
	wireTestAllTypes_RepeatedInt64 gremlin.ProtoWireNumber = 32
	wireTestAllTypes_RepeatedUint32 gremlin.ProtoWireNumber = 33
	wireTestAllTypes_RepeatedUint64 gremlin.ProtoWireNumber = 34
	wireTestAllTypes_RepeatedSint32 gremlin.ProtoWireNumber = 35
	wireTestAllTypes_RepeatedSint64 gremlin.ProtoWireNumber = 36
	wireTestAllTypes_RepeatedFixed32 gremlin.ProtoWireNumber = 37
	wireTestAllTypes_RepeatedFixed64 gremlin.ProtoWireNumber = 38
	wireTestAllTypes_RepeatedSfixed32 gremlin.ProtoWireNumber = 39
	wireTestAllTypes_RepeatedSfixed64 gremlin.ProtoWireNumber = 40
	wireTestAllTypes_RepeatedFloat gremlin.ProtoWireNumber = 41
	wireTestAllTypes_RepeatedDouble gremlin.ProtoWireNumber = 42
	wireTestAllTypes_RepeatedBool gremlin.ProtoWireNumber = 43
	wireTestAllTypes_RepeatedString gremlin.ProtoWireNumber = 44
	wireTestAllTypes_RepeatedBytes gremlin.ProtoWireNumber = 45
	wireTestAllTypes_RepeatedNestedMessage gremlin.ProtoWireNumber = 48
	wireTestAllTypes_RepeatedForeignMessage gremlin.ProtoWireNumber = 49
	wireTestAllTypes_RepeatedImportMessage gremlin.ProtoWireNumber = 50
	wireTestAllTypes_RepeatedNestedEnum gremlin.ProtoWireNumber = 51
	wireTestAllTypes_RepeatedForeignEnum gremlin.ProtoWireNumber = 52
	wireTestAllTypes_RepeatedImportEnum gremlin.ProtoWireNumber = 53
	wireTestAllTypes_RepeatedStringPiece gremlin.ProtoWireNumber = 54
	wireTestAllTypes_RepeatedCord gremlin.ProtoWireNumber = 55
	wireTestAllTypes_RepeatedLazyMessage gremlin.ProtoWireNumber = 57
	wireTestAllTypes_DefaultInt32 gremlin.ProtoWireNumber = 61
	wireTestAllTypes_DefaultInt64 gremlin.ProtoWireNumber = 62
	wireTestAllTypes_DefaultUint32 gremlin.ProtoWireNumber = 63
	wireTestAllTypes_DefaultUint64 gremlin.ProtoWireNumber = 64
	wireTestAllTypes_DefaultSint32 gremlin.ProtoWireNumber = 65
	wireTestAllTypes_DefaultSint64 gremlin.ProtoWireNumber = 66
	wireTestAllTypes_DefaultFixed32 gremlin.ProtoWireNumber = 67
	wireTestAllTypes_DefaultFixed64 gremlin.ProtoWireNumber = 68
	wireTestAllTypes_DefaultSfixed32 gremlin.ProtoWireNumber = 69
	wireTestAllTypes_DefaultSfixed64 gremlin.ProtoWireNumber = 70
	wireTestAllTypes_DefaultFloat gremlin.ProtoWireNumber = 71
	wireTestAllTypes_DefaultDouble gremlin.ProtoWireNumber = 72
	wireTestAllTypes_DefaultBool gremlin.ProtoWireNumber = 73
	wireTestAllTypes_DefaultString gremlin.ProtoWireNumber = 74
	wireTestAllTypes_DefaultBytes gremlin.ProtoWireNumber = 75
	wireTestAllTypes_DefaultNestedEnum gremlin.ProtoWireNumber = 81
	wireTestAllTypes_DefaultForeignEnum gremlin.ProtoWireNumber = 82
	wireTestAllTypes_DefaultImportEnum gremlin.ProtoWireNumber = 83
	wireTestAllTypes_DefaultStringPiece gremlin.ProtoWireNumber = 84
	wireTestAllTypes_DefaultCord gremlin.ProtoWireNumber = 85
	wireTestAllTypes_OneofUint32 gremlin.ProtoWireNumber = 111
	wireTestAllTypes_OneofNestedMessage gremlin.ProtoWireNumber = 112
	wireTestAllTypes_OneofString gremlin.ProtoWireNumber = 113
	wireTestAllTypes_OneofBytes gremlin.ProtoWireNumber = 114
)

type TestAllTypesReader struct {
	buf *gremlin.Reader

	dataOptionalInt32     int32
	dataOptionalInt64     int64
	dataOptionalUint32     uint32
	dataOptionalUint64     uint64
	dataOptionalSint32     int32
	dataOptionalSint64     int64
	dataOptionalFixed32     uint32
	dataOptionalFixed64     uint64
	dataOptionalSfixed32     int32
	dataOptionalSfixed64     int64
	dataOptionalFloat     float32
	dataOptionalDouble     float64
	dataOptionalBool     bool
	dataOptionalString     string
	dataOptionalBytes     []byte
	dataOptionalNestedMessage     *TestAllTypes_NestedMessageReader
	dataOptionalForeignMessage     *ForeignMessageReader
	dataOptionalImportMessage     *protobuf_unittest_import.ImportMessageReader
	dataOptionalNestedEnum     TestAllTypes_NestedEnum
	dataOptionalForeignEnum     ForeignEnum
	dataOptionalImportEnum     protobuf_unittest_import.ImportEnum
	dataOptionalStringPiece     string
	dataOptionalCord     string
	dataOptionalPublicImportMessage     *protobuf_unittest_import.PublicImportMessageReader
	dataOptionalLazyMessage     *TestAllTypes_NestedMessageReader
	dataOptionalUnverifiedLazyMessage     *TestAllTypes_NestedMessageReader
	dataRepeatedInt32     []int32
	dataRepeatedInt64     []int64
	dataRepeatedUint32     []uint32
	dataRepeatedUint64     []uint64
	dataRepeatedSint32     []int32
	dataRepeatedSint64     []int64
	dataRepeatedFixed32     []uint32
	dataRepeatedFixed64     []uint64
	dataRepeatedSfixed32     []int32
	dataRepeatedSfixed64     []int64
	dataRepeatedFloat     []float32
	dataRepeatedDouble     []float64
	dataRepeatedBool     []bool
	dataRepeatedString     []string
	dataRepeatedBytes     [][]byte
	dataRepeatedNestedMessage     []*TestAllTypes_NestedMessageReader
	dataRepeatedForeignMessage     []*ForeignMessageReader
	dataRepeatedImportMessage     []*protobuf_unittest_import.ImportMessageReader
	dataRepeatedNestedEnum     []TestAllTypes_NestedEnum
	dataRepeatedForeignEnum     []ForeignEnum
	dataRepeatedImportEnum     []protobuf_unittest_import.ImportEnum
	dataRepeatedStringPiece     []string
	dataRepeatedCord     []string
	dataRepeatedLazyMessage     []*TestAllTypes_NestedMessageReader
	dataDefaultInt32     int32
	dataDefaultInt64     int64
	dataDefaultUint32     uint32
	dataDefaultUint64     uint64
	dataDefaultSint32     int32
	dataDefaultSint64     int64
	dataDefaultFixed32     uint32
	dataDefaultFixed64     uint64
	dataDefaultSfixed32     int32
	dataDefaultSfixed64     int64
	dataDefaultFloat     float32
	dataDefaultDouble     float64
	dataDefaultBool     bool
	dataDefaultString     string
	dataDefaultBytes     []byte
	dataDefaultNestedEnum     TestAllTypes_NestedEnum
	dataDefaultForeignEnum     ForeignEnum
	dataDefaultImportEnum     protobuf_unittest_import.ImportEnum
	dataDefaultStringPiece     string
	dataDefaultCord     string
	dataOneofUint32     uint32
	dataOneofNestedMessage     *TestAllTypes_NestedMessageReader
	dataOneofString     string
	dataOneofBytes     []byte

	offsetOptionalInt32   int
	offsetOptionalInt64   int
	offsetOptionalUint32   int
	offsetOptionalUint64   int
	offsetOptionalSint32   int
	offsetOptionalSint64   int
	offsetOptionalFixed32   int
	offsetOptionalFixed64   int
	offsetOptionalSfixed32   int
	offsetOptionalSfixed64   int
	offsetOptionalFloat   int
	offsetOptionalDouble   int
	offsetOptionalBool   int
	offsetOptionalString   int
	offsetOptionalBytes   int
	offsetOptionalNestedMessage   int
	offsetOptionalForeignMessage   int
	offsetOptionalImportMessage   int
	offsetOptionalNestedEnum   int
	offsetOptionalForeignEnum   int
	offsetOptionalImportEnum   int
	offsetOptionalStringPiece   int
	offsetOptionalCord   int
	offsetOptionalPublicImportMessage   int
	offsetOptionalLazyMessage   int
	offsetOptionalUnverifiedLazyMessage   int
	offsetRepeatedInt32   []int
	wireTypeRepeatedInt32 []gremlin.ProtoWireType
	offsetRepeatedInt64   []int
	wireTypeRepeatedInt64 []gremlin.ProtoWireType
	offsetRepeatedUint32   []int
	wireTypeRepeatedUint32 []gremlin.ProtoWireType
	offsetRepeatedUint64   []int
	wireTypeRepeatedUint64 []gremlin.ProtoWireType
	offsetRepeatedSint32   []int
	wireTypeRepeatedSint32 []gremlin.ProtoWireType
	offsetRepeatedSint64   []int
	wireTypeRepeatedSint64 []gremlin.ProtoWireType
	offsetRepeatedFixed32   []int
	wireTypeRepeatedFixed32 []gremlin.ProtoWireType
	offsetRepeatedFixed64   []int
	wireTypeRepeatedFixed64 []gremlin.ProtoWireType
	offsetRepeatedSfixed32   []int
	wireTypeRepeatedSfixed32 []gremlin.ProtoWireType
	offsetRepeatedSfixed64   []int
	wireTypeRepeatedSfixed64 []gremlin.ProtoWireType
	offsetRepeatedFloat   []int
	wireTypeRepeatedFloat []gremlin.ProtoWireType
	offsetRepeatedDouble   []int
	wireTypeRepeatedDouble []gremlin.ProtoWireType
	offsetRepeatedBool   []int
	wireTypeRepeatedBool []gremlin.ProtoWireType
	offsetRepeatedString   []int
	offsetRepeatedBytes   []int
	offsetRepeatedNestedMessage   []int
	offsetRepeatedForeignMessage   []int
	offsetRepeatedImportMessage   []int
	offsetRepeatedNestedEnum   []int
	wireTypeRepeatedNestedEnum []gremlin.ProtoWireType
	offsetRepeatedForeignEnum   []int
	wireTypeRepeatedForeignEnum []gremlin.ProtoWireType
	offsetRepeatedImportEnum   []int
	wireTypeRepeatedImportEnum []gremlin.ProtoWireType
	offsetRepeatedStringPiece   []int
	offsetRepeatedCord   []int
	offsetRepeatedLazyMessage   []int
	offsetDefaultInt32   int
	offsetDefaultInt64   int
	offsetDefaultUint32   int
	offsetDefaultUint64   int
	offsetDefaultSint32   int
	offsetDefaultSint64   int
	offsetDefaultFixed32   int
	offsetDefaultFixed64   int
	offsetDefaultSfixed32   int
	offsetDefaultSfixed64   int
	offsetDefaultFloat   int
	offsetDefaultDouble   int
	offsetDefaultBool   int
	offsetDefaultString   int
	offsetDefaultBytes   int
	offsetDefaultNestedEnum   int
	offsetDefaultForeignEnum   int
	offsetDefaultImportEnum   int
	offsetDefaultStringPiece   int
	offsetDefaultCord   int
	offsetOneofUint32   int
	offsetOneofNestedMessage   int
	offsetOneofString   int
	offsetOneofBytes   int

	parsedOptionalInt32   bool
	parsedOptionalInt64   bool
	parsedOptionalUint32   bool
	parsedOptionalUint64   bool
	parsedOptionalSint32   bool
	parsedOptionalSint64   bool
	parsedOptionalFixed32   bool
	parsedOptionalFixed64   bool
	parsedOptionalSfixed32   bool
	parsedOptionalSfixed64   bool
	parsedOptionalFloat   bool
	parsedOptionalDouble   bool
	parsedOptionalBool   bool
	parsedOptionalString   bool
	parsedOptionalBytes   bool
	parsedOptionalNestedMessage   bool
	parsedOptionalForeignMessage   bool
	parsedOptionalImportMessage   bool
	parsedOptionalNestedEnum   bool
	parsedOptionalForeignEnum   bool
	parsedOptionalImportEnum   bool
	parsedOptionalStringPiece   bool
	parsedOptionalCord   bool
	parsedOptionalPublicImportMessage   bool
	parsedOptionalLazyMessage   bool
	parsedOptionalUnverifiedLazyMessage   bool
	parsedRepeatedInt32   bool
	parsedRepeatedInt64   bool
	parsedRepeatedUint32   bool
	parsedRepeatedUint64   bool
	parsedRepeatedSint32   bool
	parsedRepeatedSint64   bool
	parsedRepeatedFixed32   bool
	parsedRepeatedFixed64   bool
	parsedRepeatedSfixed32   bool
	parsedRepeatedSfixed64   bool
	parsedRepeatedFloat   bool
	parsedRepeatedDouble   bool
	parsedRepeatedBool   bool
	parsedRepeatedString   bool
	parsedRepeatedBytes   bool
	parsedRepeatedNestedMessage   bool
	parsedRepeatedForeignMessage   bool
	parsedRepeatedImportMessage   bool
	parsedRepeatedNestedEnum   bool
	parsedRepeatedForeignEnum   bool
	parsedRepeatedImportEnum   bool
	parsedRepeatedStringPiece   bool
	parsedRepeatedCord   bool
	parsedRepeatedLazyMessage   bool
	parsedDefaultInt32   bool
	parsedDefaultInt64   bool
	parsedDefaultUint32   bool
	parsedDefaultUint64   bool
	parsedDefaultSint32   bool
	parsedDefaultSint64   bool
	parsedDefaultFixed32   bool
	parsedDefaultFixed64   bool
	parsedDefaultSfixed32   bool
	parsedDefaultSfixed64   bool
	parsedDefaultFloat   bool
	parsedDefaultDouble   bool
	parsedDefaultBool   bool
	parsedDefaultString   bool
	parsedDefaultBytes   bool
	parsedDefaultNestedEnum   bool
	parsedDefaultForeignEnum   bool
	parsedDefaultImportEnum   bool
	parsedDefaultStringPiece   bool
	parsedDefaultCord   bool
	parsedOneofUint32   bool
	parsedOneofNestedMessage   bool
	parsedOneofString   bool
	parsedOneofBytes   bool
}

func NewTestAllTypesReader() *TestAllTypesReader {
	return &TestAllTypesReader{}
}

func (m *TestAllTypesReader) GetOptionalInt32() int32 {
	if m == nil {
		return 0
	}
	return m.readOptionalInt32()
}

func (m *TestAllTypesReader) readOptionalInt32() int32 {
	if m.parsedOptionalInt32 {
		return m.dataOptionalInt32
	}
	wOffset := m.offsetOptionalInt32
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataOptionalInt32 = entry
	m.parsedOptionalInt32 = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalInt64() int64 {
	if m == nil {
		return 0
	}
	return m.readOptionalInt64()
}

func (m *TestAllTypesReader) readOptionalInt64() int64 {
	if m.parsedOptionalInt64 {
		return m.dataOptionalInt64
	}
	wOffset := m.offsetOptionalInt64
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadInt64(wOffset)
	}
	
	m.dataOptionalInt64 = entry
	m.parsedOptionalInt64 = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalUint32() uint32 {
	if m == nil {
		return 0
	}
	return m.readOptionalUint32()
}

func (m *TestAllTypesReader) readOptionalUint32() uint32 {
	if m.parsedOptionalUint32 {
		return m.dataOptionalUint32
	}
	wOffset := m.offsetOptionalUint32
	
	var entry uint32
	if wOffset > 0 {
		entry = m.buf.ReadUint32(wOffset)
	}
	
	m.dataOptionalUint32 = entry
	m.parsedOptionalUint32 = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalUint64() uint64 {
	if m == nil {
		return 0
	}
	return m.readOptionalUint64()
}

func (m *TestAllTypesReader) readOptionalUint64() uint64 {
	if m.parsedOptionalUint64 {
		return m.dataOptionalUint64
	}
	wOffset := m.offsetOptionalUint64
	
	var entry uint64
	if wOffset > 0 {
		entry = m.buf.ReadUint64(wOffset)
	}
	
	m.dataOptionalUint64 = entry
	m.parsedOptionalUint64 = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalSint32() int32 {
	if m == nil {
		return 0
	}
	return m.readOptionalSint32()
}

func (m *TestAllTypesReader) readOptionalSint32() int32 {
	if m.parsedOptionalSint32 {
		return m.dataOptionalSint32
	}
	wOffset := m.offsetOptionalSint32
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadSInt32(wOffset)
	}
	
	m.dataOptionalSint32 = entry
	m.parsedOptionalSint32 = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalSint64() int64 {
	if m == nil {
		return 0
	}
	return m.readOptionalSint64()
}

func (m *TestAllTypesReader) readOptionalSint64() int64 {
	if m.parsedOptionalSint64 {
		return m.dataOptionalSint64
	}
	wOffset := m.offsetOptionalSint64
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadSInt64(wOffset)
	}
	
	m.dataOptionalSint64 = entry
	m.parsedOptionalSint64 = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalFixed32() uint32 {
	if m == nil {
		return 0
	}
	return m.readOptionalFixed32()
}

func (m *TestAllTypesReader) readOptionalFixed32() uint32 {
	if m.parsedOptionalFixed32 {
		return m.dataOptionalFixed32
	}
	wOffset := m.offsetOptionalFixed32
	
	var entry uint32
	if wOffset > 0 {
		entry = m.buf.ReadFixed32(wOffset)
	}
	
	m.dataOptionalFixed32 = entry
	m.parsedOptionalFixed32 = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalFixed64() uint64 {
	if m == nil {
		return 0
	}
	return m.readOptionalFixed64()
}

func (m *TestAllTypesReader) readOptionalFixed64() uint64 {
	if m.parsedOptionalFixed64 {
		return m.dataOptionalFixed64
	}
	wOffset := m.offsetOptionalFixed64
	
	var entry uint64
	if wOffset > 0 {
		entry = m.buf.ReadFixed64(wOffset)
	}
	
	m.dataOptionalFixed64 = entry
	m.parsedOptionalFixed64 = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalSfixed32() int32 {
	if m == nil {
		return 0
	}
	return m.readOptionalSfixed32()
}

func (m *TestAllTypesReader) readOptionalSfixed32() int32 {
	if m.parsedOptionalSfixed32 {
		return m.dataOptionalSfixed32
	}
	wOffset := m.offsetOptionalSfixed32
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadSFixed32(wOffset)
	}
	
	m.dataOptionalSfixed32 = entry
	m.parsedOptionalSfixed32 = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalSfixed64() int64 {
	if m == nil {
		return 0
	}
	return m.readOptionalSfixed64()
}

func (m *TestAllTypesReader) readOptionalSfixed64() int64 {
	if m.parsedOptionalSfixed64 {
		return m.dataOptionalSfixed64
	}
	wOffset := m.offsetOptionalSfixed64
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadSFixed64(wOffset)
	}
	
	m.dataOptionalSfixed64 = entry
	m.parsedOptionalSfixed64 = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalFloat() float32 {
	if m == nil {
		return 0
	}
	return m.readOptionalFloat()
}

func (m *TestAllTypesReader) readOptionalFloat() float32 {
	if m.parsedOptionalFloat {
		return m.dataOptionalFloat
	}
	wOffset := m.offsetOptionalFloat
	
	var entry float32
	if wOffset > 0 {
		entry = m.buf.ReadFloat32(wOffset)
	}
	
	m.dataOptionalFloat = entry
	m.parsedOptionalFloat = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalDouble() float64 {
	if m == nil {
		return 0
	}
	return m.readOptionalDouble()
}

func (m *TestAllTypesReader) readOptionalDouble() float64 {
	if m.parsedOptionalDouble {
		return m.dataOptionalDouble
	}
	wOffset := m.offsetOptionalDouble
	
	var entry float64
	if wOffset > 0 {
		entry = m.buf.ReadFloat64(wOffset)
	}
	
	m.dataOptionalDouble = entry
	m.parsedOptionalDouble = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalBool() bool {
	if m == nil {
		return false
	}
	return m.readOptionalBool()
}

func (m *TestAllTypesReader) readOptionalBool() bool {
	if m.parsedOptionalBool {
		return m.dataOptionalBool
	}
	wOffset := m.offsetOptionalBool
	
	var entry bool
	if wOffset > 0 {
		entry = m.buf.ReadBool(wOffset)
	}
	
	m.dataOptionalBool = entry
	m.parsedOptionalBool = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalString() string {
	if m == nil {
		return ""
	}
	return m.readOptionalString()
}

func (m *TestAllTypesReader) readOptionalString() string {
	if m.parsedOptionalString {
		return m.dataOptionalString
	}
	wOffset := m.offsetOptionalString
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataOptionalString = entry
	m.parsedOptionalString = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalBytes() []byte {
	if m == nil {
		return nil
	}
	return m.readOptionalBytes()
}

func (m *TestAllTypesReader) readOptionalBytes() []byte {
	if m.parsedOptionalBytes {
		return m.dataOptionalBytes
	}
	wOffset := m.offsetOptionalBytes
	
	var entry []byte
	if wOffset > 0 {
		entry = m.buf.ReadBytes(wOffset)
	}
	
	m.dataOptionalBytes = entry
	m.parsedOptionalBytes = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalNestedMessage() *TestAllTypes_NestedMessageReader {
	if m == nil {
		return nil
	}
	return m.readOptionalNestedMessage()
}

func (m *TestAllTypesReader) readOptionalNestedMessage() *TestAllTypes_NestedMessageReader {
	if m.parsedOptionalNestedMessage {
		return m.dataOptionalNestedMessage
	}
	wOffset := m.offsetOptionalNestedMessage
	
	var entry *TestAllTypes_NestedMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypes_NestedMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalNestedMessage = entry
	m.parsedOptionalNestedMessage = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalForeignMessage() *ForeignMessageReader {
	if m == nil {
		return nil
	}
	return m.readOptionalForeignMessage()
}

func (m *TestAllTypesReader) readOptionalForeignMessage() *ForeignMessageReader {
	if m.parsedOptionalForeignMessage {
		return m.dataOptionalForeignMessage
	}
	wOffset := m.offsetOptionalForeignMessage
	
	var entry *ForeignMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewForeignMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalForeignMessage = entry
	m.parsedOptionalForeignMessage = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalImportMessage() *protobuf_unittest_import.ImportMessageReader {
	if m == nil {
		return nil
	}
	return m.readOptionalImportMessage()
}

func (m *TestAllTypesReader) readOptionalImportMessage() *protobuf_unittest_import.ImportMessageReader {
	if m.parsedOptionalImportMessage {
		return m.dataOptionalImportMessage
	}
	wOffset := m.offsetOptionalImportMessage
	
	var entry *protobuf_unittest_import.ImportMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = protobuf_unittest_import.NewImportMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalImportMessage = entry
	m.parsedOptionalImportMessage = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalNestedEnum() TestAllTypes_NestedEnum {
	if m == nil {
		return 0
	}
	return m.readOptionalNestedEnum()
}

func (m *TestAllTypesReader) readOptionalNestedEnum() TestAllTypes_NestedEnum {
	if m.parsedOptionalNestedEnum {
		return m.dataOptionalNestedEnum
	}
	wOffset := m.offsetOptionalNestedEnum
	
	var entry TestAllTypes_NestedEnum
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = TestAllTypes_NestedEnum(rawEntry)
	} else {
		entry = 0
	}
	
	m.dataOptionalNestedEnum = entry
	m.parsedOptionalNestedEnum = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalForeignEnum() ForeignEnum {
	if m == nil {
		return 0
	}
	return m.readOptionalForeignEnum()
}

func (m *TestAllTypesReader) readOptionalForeignEnum() ForeignEnum {
	if m.parsedOptionalForeignEnum {
		return m.dataOptionalForeignEnum
	}
	wOffset := m.offsetOptionalForeignEnum
	
	var entry ForeignEnum
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = ForeignEnum(rawEntry)
	} else {
		entry = 0
	}
	
	m.dataOptionalForeignEnum = entry
	m.parsedOptionalForeignEnum = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalImportEnum() protobuf_unittest_import.ImportEnum {
	if m == nil {
		return 0
	}
	return m.readOptionalImportEnum()
}

func (m *TestAllTypesReader) readOptionalImportEnum() protobuf_unittest_import.ImportEnum {
	if m.parsedOptionalImportEnum {
		return m.dataOptionalImportEnum
	}
	wOffset := m.offsetOptionalImportEnum
	
	var entry protobuf_unittest_import.ImportEnum
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = protobuf_unittest_import.ImportEnum(rawEntry)
	} else {
		entry = 0
	}
	
	m.dataOptionalImportEnum = entry
	m.parsedOptionalImportEnum = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalStringPiece() string {
	if m == nil {
		return ""
	}
	return m.readOptionalStringPiece()
}

func (m *TestAllTypesReader) readOptionalStringPiece() string {
	if m.parsedOptionalStringPiece {
		return m.dataOptionalStringPiece
	}
	wOffset := m.offsetOptionalStringPiece
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataOptionalStringPiece = entry
	m.parsedOptionalStringPiece = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalCord() string {
	if m == nil {
		return ""
	}
	return m.readOptionalCord()
}

func (m *TestAllTypesReader) readOptionalCord() string {
	if m.parsedOptionalCord {
		return m.dataOptionalCord
	}
	wOffset := m.offsetOptionalCord
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataOptionalCord = entry
	m.parsedOptionalCord = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalPublicImportMessage() *protobuf_unittest_import.PublicImportMessageReader {
	if m == nil {
		return nil
	}
	return m.readOptionalPublicImportMessage()
}

func (m *TestAllTypesReader) readOptionalPublicImportMessage() *protobuf_unittest_import.PublicImportMessageReader {
	if m.parsedOptionalPublicImportMessage {
		return m.dataOptionalPublicImportMessage
	}
	wOffset := m.offsetOptionalPublicImportMessage
	
	var entry *protobuf_unittest_import.PublicImportMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = protobuf_unittest_import.NewPublicImportMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalPublicImportMessage = entry
	m.parsedOptionalPublicImportMessage = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalLazyMessage() *TestAllTypes_NestedMessageReader {
	if m == nil {
		return nil
	}
	return m.readOptionalLazyMessage()
}

func (m *TestAllTypesReader) readOptionalLazyMessage() *TestAllTypes_NestedMessageReader {
	if m.parsedOptionalLazyMessage {
		return m.dataOptionalLazyMessage
	}
	wOffset := m.offsetOptionalLazyMessage
	
	var entry *TestAllTypes_NestedMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypes_NestedMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalLazyMessage = entry
	m.parsedOptionalLazyMessage = true
	return entry
}

func (m *TestAllTypesReader) GetOptionalUnverifiedLazyMessage() *TestAllTypes_NestedMessageReader {
	if m == nil {
		return nil
	}
	return m.readOptionalUnverifiedLazyMessage()
}

func (m *TestAllTypesReader) readOptionalUnverifiedLazyMessage() *TestAllTypes_NestedMessageReader {
	if m.parsedOptionalUnverifiedLazyMessage {
		return m.dataOptionalUnverifiedLazyMessage
	}
	wOffset := m.offsetOptionalUnverifiedLazyMessage
	
	var entry *TestAllTypes_NestedMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypes_NestedMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalUnverifiedLazyMessage = entry
	m.parsedOptionalUnverifiedLazyMessage = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedInt32() []int32 {
	if m == nil {
		return nil
	}
	return m.readRepeatedInt32()
}

func (m *TestAllTypesReader) readRepeatedInt32() []int32 {
	if m.parsedRepeatedInt32 {
		return m.dataRepeatedInt32
	}
	wOffset := m.offsetRepeatedInt32
	var wType = m.wireTypeRepeatedInt32
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadInt32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedInt32 = entry
	m.parsedRepeatedInt32 = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedInt64() []int64 {
	if m == nil {
		return nil
	}
	return m.readRepeatedInt64()
}

func (m *TestAllTypesReader) readRepeatedInt64() []int64 {
	if m.parsedRepeatedInt64 {
		return m.dataRepeatedInt64
	}
	wOffset := m.offsetRepeatedInt64
	var wType = m.wireTypeRepeatedInt64
	
	var entry []int64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadInt64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int64
			if wOffset > 0 {
				listEntry = m.buf.ReadInt64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedInt64 = entry
	m.parsedRepeatedInt64 = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedUint32() []uint32 {
	if m == nil {
		return nil
	}
	return m.readRepeatedUint32()
}

func (m *TestAllTypesReader) readRepeatedUint32() []uint32 {
	if m.parsedRepeatedUint32 {
		return m.dataRepeatedUint32
	}
	wOffset := m.offsetRepeatedUint32
	var wType = m.wireTypeRepeatedUint32
	
	var entry []uint32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadUint32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint32
			if wOffset > 0 {
				listEntry = m.buf.ReadUint32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedUint32 = entry
	m.parsedRepeatedUint32 = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedUint64() []uint64 {
	if m == nil {
		return nil
	}
	return m.readRepeatedUint64()
}

func (m *TestAllTypesReader) readRepeatedUint64() []uint64 {
	if m.parsedRepeatedUint64 {
		return m.dataRepeatedUint64
	}
	wOffset := m.offsetRepeatedUint64
	var wType = m.wireTypeRepeatedUint64
	
	var entry []uint64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadUint64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint64
			if wOffset > 0 {
				listEntry = m.buf.ReadUint64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedUint64 = entry
	m.parsedRepeatedUint64 = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedSint32() []int32 {
	if m == nil {
		return nil
	}
	return m.readRepeatedSint32()
}

func (m *TestAllTypesReader) readRepeatedSint32() []int32 {
	if m.parsedRepeatedSint32 {
		return m.dataRepeatedSint32
	}
	wOffset := m.offsetRepeatedSint32
	var wType = m.wireTypeRepeatedSint32
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSInt32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadSInt32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedSint32 = entry
	m.parsedRepeatedSint32 = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedSint64() []int64 {
	if m == nil {
		return nil
	}
	return m.readRepeatedSint64()
}

func (m *TestAllTypesReader) readRepeatedSint64() []int64 {
	if m.parsedRepeatedSint64 {
		return m.dataRepeatedSint64
	}
	wOffset := m.offsetRepeatedSint64
	var wType = m.wireTypeRepeatedSint64
	
	var entry []int64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSInt64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int64
			if wOffset > 0 {
				listEntry = m.buf.ReadSInt64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedSint64 = entry
	m.parsedRepeatedSint64 = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedFixed32() []uint32 {
	if m == nil {
		return nil
	}
	return m.readRepeatedFixed32()
}

func (m *TestAllTypesReader) readRepeatedFixed32() []uint32 {
	if m.parsedRepeatedFixed32 {
		return m.dataRepeatedFixed32
	}
	wOffset := m.offsetRepeatedFixed32
	var wType = m.wireTypeRepeatedFixed32
	
	var entry []uint32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFixed32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint32
			if wOffset > 0 {
				listEntry = m.buf.ReadFixed32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedFixed32 = entry
	m.parsedRepeatedFixed32 = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedFixed64() []uint64 {
	if m == nil {
		return nil
	}
	return m.readRepeatedFixed64()
}

func (m *TestAllTypesReader) readRepeatedFixed64() []uint64 {
	if m.parsedRepeatedFixed64 {
		return m.dataRepeatedFixed64
	}
	wOffset := m.offsetRepeatedFixed64
	var wType = m.wireTypeRepeatedFixed64
	
	var entry []uint64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFixed64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint64
			if wOffset > 0 {
				listEntry = m.buf.ReadFixed64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedFixed64 = entry
	m.parsedRepeatedFixed64 = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedSfixed32() []int32 {
	if m == nil {
		return nil
	}
	return m.readRepeatedSfixed32()
}

func (m *TestAllTypesReader) readRepeatedSfixed32() []int32 {
	if m.parsedRepeatedSfixed32 {
		return m.dataRepeatedSfixed32
	}
	wOffset := m.offsetRepeatedSfixed32
	var wType = m.wireTypeRepeatedSfixed32
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSFixed32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadSFixed32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedSfixed32 = entry
	m.parsedRepeatedSfixed32 = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedSfixed64() []int64 {
	if m == nil {
		return nil
	}
	return m.readRepeatedSfixed64()
}

func (m *TestAllTypesReader) readRepeatedSfixed64() []int64 {
	if m.parsedRepeatedSfixed64 {
		return m.dataRepeatedSfixed64
	}
	wOffset := m.offsetRepeatedSfixed64
	var wType = m.wireTypeRepeatedSfixed64
	
	var entry []int64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSFixed64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int64
			if wOffset > 0 {
				listEntry = m.buf.ReadSFixed64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedSfixed64 = entry
	m.parsedRepeatedSfixed64 = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedFloat() []float32 {
	if m == nil {
		return nil
	}
	return m.readRepeatedFloat()
}

func (m *TestAllTypesReader) readRepeatedFloat() []float32 {
	if m.parsedRepeatedFloat {
		return m.dataRepeatedFloat
	}
	wOffset := m.offsetRepeatedFloat
	var wType = m.wireTypeRepeatedFloat
	
	var entry []float32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry float32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFloat32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry float32
			if wOffset > 0 {
				listEntry = m.buf.ReadFloat32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedFloat = entry
	m.parsedRepeatedFloat = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedDouble() []float64 {
	if m == nil {
		return nil
	}
	return m.readRepeatedDouble()
}

func (m *TestAllTypesReader) readRepeatedDouble() []float64 {
	if m.parsedRepeatedDouble {
		return m.dataRepeatedDouble
	}
	wOffset := m.offsetRepeatedDouble
	var wType = m.wireTypeRepeatedDouble
	
	var entry []float64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry float64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFloat64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry float64
			if wOffset > 0 {
				listEntry = m.buf.ReadFloat64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedDouble = entry
	m.parsedRepeatedDouble = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedBool() []bool {
	if m == nil {
		return nil
	}
	return m.readRepeatedBool()
}

func (m *TestAllTypesReader) readRepeatedBool() []bool {
	if m.parsedRepeatedBool {
		return m.dataRepeatedBool
	}
	wOffset := m.offsetRepeatedBool
	var wType = m.wireTypeRepeatedBool
	
	var entry []bool
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry bool
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadBool(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry bool
			if wOffset > 0 {
				listEntry = m.buf.ReadBool(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedBool = entry
	m.parsedRepeatedBool = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedString() []string {
	if m == nil {
		return nil
	}
	return m.readRepeatedString()
}

func (m *TestAllTypesReader) readRepeatedString() []string {
	if m.parsedRepeatedString {
		return m.dataRepeatedString
	}
	wOffset := m.offsetRepeatedString
	
	var entry []string
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry string
		if wOffset > 0 {
			listEntry = m.buf.ReadString(wOffset)
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedString = entry
	m.parsedRepeatedString = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedBytes() [][]byte {
	if m == nil {
		return nil
	}
	return m.readRepeatedBytes()
}

func (m *TestAllTypesReader) readRepeatedBytes() [][]byte {
	if m.parsedRepeatedBytes {
		return m.dataRepeatedBytes
	}
	wOffset := m.offsetRepeatedBytes
	
	var entry [][]byte
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry []byte
		if wOffset > 0 {
			listEntry = m.buf.ReadBytes(wOffset)
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedBytes = entry
	m.parsedRepeatedBytes = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedNestedMessage() []*TestAllTypes_NestedMessageReader {
	if m == nil {
		return nil
	}
	return m.readRepeatedNestedMessage()
}

func (m *TestAllTypesReader) readRepeatedNestedMessage() []*TestAllTypes_NestedMessageReader {
	if m.parsedRepeatedNestedMessage {
		return m.dataRepeatedNestedMessage
	}
	wOffset := m.offsetRepeatedNestedMessage
	
	var entry []*TestAllTypes_NestedMessageReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *TestAllTypes_NestedMessageReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewTestAllTypes_NestedMessageReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedNestedMessage = entry
	m.parsedRepeatedNestedMessage = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedForeignMessage() []*ForeignMessageReader {
	if m == nil {
		return nil
	}
	return m.readRepeatedForeignMessage()
}

func (m *TestAllTypesReader) readRepeatedForeignMessage() []*ForeignMessageReader {
	if m.parsedRepeatedForeignMessage {
		return m.dataRepeatedForeignMessage
	}
	wOffset := m.offsetRepeatedForeignMessage
	
	var entry []*ForeignMessageReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *ForeignMessageReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewForeignMessageReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedForeignMessage = entry
	m.parsedRepeatedForeignMessage = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedImportMessage() []*protobuf_unittest_import.ImportMessageReader {
	if m == nil {
		return nil
	}
	return m.readRepeatedImportMessage()
}

func (m *TestAllTypesReader) readRepeatedImportMessage() []*protobuf_unittest_import.ImportMessageReader {
	if m.parsedRepeatedImportMessage {
		return m.dataRepeatedImportMessage
	}
	wOffset := m.offsetRepeatedImportMessage
	
	var entry []*protobuf_unittest_import.ImportMessageReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *protobuf_unittest_import.ImportMessageReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = protobuf_unittest_import.NewImportMessageReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedImportMessage = entry
	m.parsedRepeatedImportMessage = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedNestedEnum() []TestAllTypes_NestedEnum {
	if m == nil {
		return nil
	}
	return m.readRepeatedNestedEnum()
}

func (m *TestAllTypesReader) readRepeatedNestedEnum() []TestAllTypes_NestedEnum {
	if m.parsedRepeatedNestedEnum {
		return m.dataRepeatedNestedEnum
	}
	wOffset := m.offsetRepeatedNestedEnum
	var wType = m.wireTypeRepeatedNestedEnum
	
	var entry []TestAllTypes_NestedEnum
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry TestAllTypes_NestedEnum
				var listEntrySize int
				if wOffset > 0 {
					rawEntry, size := m.buf.SizedReadInt32(wOffset)
					listEntry = TestAllTypes_NestedEnum(rawEntry)
					listEntrySize = size
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry TestAllTypes_NestedEnum
			if wOffset > 0 {
				rawEntry := m.buf.ReadInt32(wOffset)
				listEntry = TestAllTypes_NestedEnum(rawEntry)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedNestedEnum = entry
	m.parsedRepeatedNestedEnum = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedForeignEnum() []ForeignEnum {
	if m == nil {
		return nil
	}
	return m.readRepeatedForeignEnum()
}

func (m *TestAllTypesReader) readRepeatedForeignEnum() []ForeignEnum {
	if m.parsedRepeatedForeignEnum {
		return m.dataRepeatedForeignEnum
	}
	wOffset := m.offsetRepeatedForeignEnum
	var wType = m.wireTypeRepeatedForeignEnum
	
	var entry []ForeignEnum
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry ForeignEnum
				var listEntrySize int
				if wOffset > 0 {
					rawEntry, size := m.buf.SizedReadInt32(wOffset)
					listEntry = ForeignEnum(rawEntry)
					listEntrySize = size
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry ForeignEnum
			if wOffset > 0 {
				rawEntry := m.buf.ReadInt32(wOffset)
				listEntry = ForeignEnum(rawEntry)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedForeignEnum = entry
	m.parsedRepeatedForeignEnum = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedImportEnum() []protobuf_unittest_import.ImportEnum {
	if m == nil {
		return nil
	}
	return m.readRepeatedImportEnum()
}

func (m *TestAllTypesReader) readRepeatedImportEnum() []protobuf_unittest_import.ImportEnum {
	if m.parsedRepeatedImportEnum {
		return m.dataRepeatedImportEnum
	}
	wOffset := m.offsetRepeatedImportEnum
	var wType = m.wireTypeRepeatedImportEnum
	
	var entry []protobuf_unittest_import.ImportEnum
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry protobuf_unittest_import.ImportEnum
				var listEntrySize int
				if wOffset > 0 {
					rawEntry, size := m.buf.SizedReadInt32(wOffset)
					listEntry = protobuf_unittest_import.ImportEnum(rawEntry)
					listEntrySize = size
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry protobuf_unittest_import.ImportEnum
			if wOffset > 0 {
				rawEntry := m.buf.ReadInt32(wOffset)
				listEntry = protobuf_unittest_import.ImportEnum(rawEntry)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedImportEnum = entry
	m.parsedRepeatedImportEnum = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedStringPiece() []string {
	if m == nil {
		return nil
	}
	return m.readRepeatedStringPiece()
}

func (m *TestAllTypesReader) readRepeatedStringPiece() []string {
	if m.parsedRepeatedStringPiece {
		return m.dataRepeatedStringPiece
	}
	wOffset := m.offsetRepeatedStringPiece
	
	var entry []string
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry string
		if wOffset > 0 {
			listEntry = m.buf.ReadString(wOffset)
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedStringPiece = entry
	m.parsedRepeatedStringPiece = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedCord() []string {
	if m == nil {
		return nil
	}
	return m.readRepeatedCord()
}

func (m *TestAllTypesReader) readRepeatedCord() []string {
	if m.parsedRepeatedCord {
		return m.dataRepeatedCord
	}
	wOffset := m.offsetRepeatedCord
	
	var entry []string
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry string
		if wOffset > 0 {
			listEntry = m.buf.ReadString(wOffset)
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedCord = entry
	m.parsedRepeatedCord = true
	return entry
}

func (m *TestAllTypesReader) GetRepeatedLazyMessage() []*TestAllTypes_NestedMessageReader {
	if m == nil {
		return nil
	}
	return m.readRepeatedLazyMessage()
}

func (m *TestAllTypesReader) readRepeatedLazyMessage() []*TestAllTypes_NestedMessageReader {
	if m.parsedRepeatedLazyMessage {
		return m.dataRepeatedLazyMessage
	}
	wOffset := m.offsetRepeatedLazyMessage
	
	var entry []*TestAllTypes_NestedMessageReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *TestAllTypes_NestedMessageReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewTestAllTypes_NestedMessageReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedLazyMessage = entry
	m.parsedRepeatedLazyMessage = true
	return entry
}

func (m *TestAllTypesReader) GetDefaultInt32() int32 {
	if m == nil {
		return 41
	}
	return m.readDefaultInt32()
}

func (m *TestAllTypesReader) readDefaultInt32() int32 {
	if m.parsedDefaultInt32 {
		return m.dataDefaultInt32
	}
	wOffset := m.offsetDefaultInt32
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	} else {
		entry = 41
	}
	
	m.dataDefaultInt32 = entry
	m.parsedDefaultInt32 = true
	return entry
}

func (m *TestAllTypesReader) GetDefaultInt64() int64 {
	if m == nil {
		return 42
	}
	return m.readDefaultInt64()
}

func (m *TestAllTypesReader) readDefaultInt64() int64 {
	if m.parsedDefaultInt64 {
		return m.dataDefaultInt64
	}
	wOffset := m.offsetDefaultInt64
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadInt64(wOffset)
	} else {
		entry = 42
	}
	
	m.dataDefaultInt64 = entry
	m.parsedDefaultInt64 = true
	return entry
}

func (m *TestAllTypesReader) GetDefaultUint32() uint32 {
	if m == nil {
		return 43
	}
	return m.readDefaultUint32()
}

func (m *TestAllTypesReader) readDefaultUint32() uint32 {
	if m.parsedDefaultUint32 {
		return m.dataDefaultUint32
	}
	wOffset := m.offsetDefaultUint32
	
	var entry uint32
	if wOffset > 0 {
		entry = m.buf.ReadUint32(wOffset)
	} else {
		entry = 43
	}
	
	m.dataDefaultUint32 = entry
	m.parsedDefaultUint32 = true
	return entry
}

func (m *TestAllTypesReader) GetDefaultUint64() uint64 {
	if m == nil {
		return 44
	}
	return m.readDefaultUint64()
}

func (m *TestAllTypesReader) readDefaultUint64() uint64 {
	if m.parsedDefaultUint64 {
		return m.dataDefaultUint64
	}
	wOffset := m.offsetDefaultUint64
	
	var entry uint64
	if wOffset > 0 {
		entry = m.buf.ReadUint64(wOffset)
	} else {
		entry = 44
	}
	
	m.dataDefaultUint64 = entry
	m.parsedDefaultUint64 = true
	return entry
}

func (m *TestAllTypesReader) GetDefaultSint32() int32 {
	if m == nil {
		return -45
	}
	return m.readDefaultSint32()
}

func (m *TestAllTypesReader) readDefaultSint32() int32 {
	if m.parsedDefaultSint32 {
		return m.dataDefaultSint32
	}
	wOffset := m.offsetDefaultSint32
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadSInt32(wOffset)
	} else {
		entry = -45
	}
	
	m.dataDefaultSint32 = entry
	m.parsedDefaultSint32 = true
	return entry
}

func (m *TestAllTypesReader) GetDefaultSint64() int64 {
	if m == nil {
		return 46
	}
	return m.readDefaultSint64()
}

func (m *TestAllTypesReader) readDefaultSint64() int64 {
	if m.parsedDefaultSint64 {
		return m.dataDefaultSint64
	}
	wOffset := m.offsetDefaultSint64
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadSInt64(wOffset)
	} else {
		entry = 46
	}
	
	m.dataDefaultSint64 = entry
	m.parsedDefaultSint64 = true
	return entry
}

func (m *TestAllTypesReader) GetDefaultFixed32() uint32 {
	if m == nil {
		return 47
	}
	return m.readDefaultFixed32()
}

func (m *TestAllTypesReader) readDefaultFixed32() uint32 {
	if m.parsedDefaultFixed32 {
		return m.dataDefaultFixed32
	}
	wOffset := m.offsetDefaultFixed32
	
	var entry uint32
	if wOffset > 0 {
		entry = m.buf.ReadFixed32(wOffset)
	} else {
		entry = 47
	}
	
	m.dataDefaultFixed32 = entry
	m.parsedDefaultFixed32 = true
	return entry
}

func (m *TestAllTypesReader) GetDefaultFixed64() uint64 {
	if m == nil {
		return 48
	}
	return m.readDefaultFixed64()
}

func (m *TestAllTypesReader) readDefaultFixed64() uint64 {
	if m.parsedDefaultFixed64 {
		return m.dataDefaultFixed64
	}
	wOffset := m.offsetDefaultFixed64
	
	var entry uint64
	if wOffset > 0 {
		entry = m.buf.ReadFixed64(wOffset)
	} else {
		entry = 48
	}
	
	m.dataDefaultFixed64 = entry
	m.parsedDefaultFixed64 = true
	return entry
}

func (m *TestAllTypesReader) GetDefaultSfixed32() int32 {
	if m == nil {
		return 49
	}
	return m.readDefaultSfixed32()
}

func (m *TestAllTypesReader) readDefaultSfixed32() int32 {
	if m.parsedDefaultSfixed32 {
		return m.dataDefaultSfixed32
	}
	wOffset := m.offsetDefaultSfixed32
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadSFixed32(wOffset)
	} else {
		entry = 49
	}
	
	m.dataDefaultSfixed32 = entry
	m.parsedDefaultSfixed32 = true
	return entry
}

func (m *TestAllTypesReader) GetDefaultSfixed64() int64 {
	if m == nil {
		return -50
	}
	return m.readDefaultSfixed64()
}

func (m *TestAllTypesReader) readDefaultSfixed64() int64 {
	if m.parsedDefaultSfixed64 {
		return m.dataDefaultSfixed64
	}
	wOffset := m.offsetDefaultSfixed64
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadSFixed64(wOffset)
	} else {
		entry = -50
	}
	
	m.dataDefaultSfixed64 = entry
	m.parsedDefaultSfixed64 = true
	return entry
}

func (m *TestAllTypesReader) GetDefaultFloat() float32 {
	if m == nil {
		return 51.5
	}
	return m.readDefaultFloat()
}

func (m *TestAllTypesReader) readDefaultFloat() float32 {
	if m.parsedDefaultFloat {
		return m.dataDefaultFloat
	}
	wOffset := m.offsetDefaultFloat
	
	var entry float32
	if wOffset > 0 {
		entry = m.buf.ReadFloat32(wOffset)
	} else {
		entry = 51.5
	}
	
	m.dataDefaultFloat = entry
	m.parsedDefaultFloat = true
	return entry
}

func (m *TestAllTypesReader) GetDefaultDouble() float64 {
	if m == nil {
		return 52e3
	}
	return m.readDefaultDouble()
}

func (m *TestAllTypesReader) readDefaultDouble() float64 {
	if m.parsedDefaultDouble {
		return m.dataDefaultDouble
	}
	wOffset := m.offsetDefaultDouble
	
	var entry float64
	if wOffset > 0 {
		entry = m.buf.ReadFloat64(wOffset)
	} else {
		entry = 52e3
	}
	
	m.dataDefaultDouble = entry
	m.parsedDefaultDouble = true
	return entry
}

func (m *TestAllTypesReader) GetDefaultBool() bool {
	if m == nil {
		return true
	}
	return m.readDefaultBool()
}

func (m *TestAllTypesReader) readDefaultBool() bool {
	if m.parsedDefaultBool {
		return m.dataDefaultBool
	}
	wOffset := m.offsetDefaultBool
	
	var entry bool
	if wOffset > 0 {
		entry = m.buf.ReadBool(wOffset)
	} else {
		entry = true
	}
	
	m.dataDefaultBool = entry
	m.parsedDefaultBool = true
	return entry
}

func (m *TestAllTypesReader) GetDefaultString() string {
	if m == nil {
		return "hello"
	}
	return m.readDefaultString()
}

func (m *TestAllTypesReader) readDefaultString() string {
	if m.parsedDefaultString {
		return m.dataDefaultString
	}
	wOffset := m.offsetDefaultString
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	} else {
		entry = "hello"
	}
	
	m.dataDefaultString = entry
	m.parsedDefaultString = true
	return entry
}

func (m *TestAllTypesReader) GetDefaultBytes() []byte {
	if m == nil {
		return []byte("world")
	}
	return m.readDefaultBytes()
}

func (m *TestAllTypesReader) readDefaultBytes() []byte {
	if m.parsedDefaultBytes {
		return m.dataDefaultBytes
	}
	wOffset := m.offsetDefaultBytes
	
	var entry []byte
	if wOffset > 0 {
		entry = m.buf.ReadBytes(wOffset)
	} else {
		entry = []byte("world")
	}
	
	m.dataDefaultBytes = entry
	m.parsedDefaultBytes = true
	return entry
}

func (m *TestAllTypesReader) GetDefaultNestedEnum() TestAllTypes_NestedEnum {
	if m == nil {
		return 0
	}
	return m.readDefaultNestedEnum()
}

func (m *TestAllTypesReader) readDefaultNestedEnum() TestAllTypes_NestedEnum {
	if m.parsedDefaultNestedEnum {
		return m.dataDefaultNestedEnum
	}
	wOffset := m.offsetDefaultNestedEnum
	
	var entry TestAllTypes_NestedEnum
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = TestAllTypes_NestedEnum(rawEntry)
	} else {
		entry = 0
	}
	
	m.dataDefaultNestedEnum = entry
	m.parsedDefaultNestedEnum = true
	return entry
}

func (m *TestAllTypesReader) GetDefaultForeignEnum() ForeignEnum {
	if m == nil {
		return 0
	}
	return m.readDefaultForeignEnum()
}

func (m *TestAllTypesReader) readDefaultForeignEnum() ForeignEnum {
	if m.parsedDefaultForeignEnum {
		return m.dataDefaultForeignEnum
	}
	wOffset := m.offsetDefaultForeignEnum
	
	var entry ForeignEnum
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = ForeignEnum(rawEntry)
	} else {
		entry = 0
	}
	
	m.dataDefaultForeignEnum = entry
	m.parsedDefaultForeignEnum = true
	return entry
}

func (m *TestAllTypesReader) GetDefaultImportEnum() protobuf_unittest_import.ImportEnum {
	if m == nil {
		return 0
	}
	return m.readDefaultImportEnum()
}

func (m *TestAllTypesReader) readDefaultImportEnum() protobuf_unittest_import.ImportEnum {
	if m.parsedDefaultImportEnum {
		return m.dataDefaultImportEnum
	}
	wOffset := m.offsetDefaultImportEnum
	
	var entry protobuf_unittest_import.ImportEnum
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = protobuf_unittest_import.ImportEnum(rawEntry)
	} else {
		entry = 0
	}
	
	m.dataDefaultImportEnum = entry
	m.parsedDefaultImportEnum = true
	return entry
}

func (m *TestAllTypesReader) GetDefaultStringPiece() string {
	if m == nil {
		return "abc"
	}
	return m.readDefaultStringPiece()
}

func (m *TestAllTypesReader) readDefaultStringPiece() string {
	if m.parsedDefaultStringPiece {
		return m.dataDefaultStringPiece
	}
	wOffset := m.offsetDefaultStringPiece
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	} else {
		entry = "abc"
	}
	
	m.dataDefaultStringPiece = entry
	m.parsedDefaultStringPiece = true
	return entry
}

func (m *TestAllTypesReader) GetDefaultCord() string {
	if m == nil {
		return "123"
	}
	return m.readDefaultCord()
}

func (m *TestAllTypesReader) readDefaultCord() string {
	if m.parsedDefaultCord {
		return m.dataDefaultCord
	}
	wOffset := m.offsetDefaultCord
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	} else {
		entry = "123"
	}
	
	m.dataDefaultCord = entry
	m.parsedDefaultCord = true
	return entry
}

func (m *TestAllTypesReader) GetOneofUint32() uint32 {
	if m == nil {
		return 0
	}
	return m.readOneofUint32()
}

func (m *TestAllTypesReader) readOneofUint32() uint32 {
	if m.parsedOneofUint32 {
		return m.dataOneofUint32
	}
	wOffset := m.offsetOneofUint32
	
	var entry uint32
	if wOffset > 0 {
		entry = m.buf.ReadUint32(wOffset)
	}
	
	m.dataOneofUint32 = entry
	m.parsedOneofUint32 = true
	return entry
}

func (m *TestAllTypesReader) GetOneofNestedMessage() *TestAllTypes_NestedMessageReader {
	if m == nil {
		return nil
	}
	return m.readOneofNestedMessage()
}

func (m *TestAllTypesReader) readOneofNestedMessage() *TestAllTypes_NestedMessageReader {
	if m.parsedOneofNestedMessage {
		return m.dataOneofNestedMessage
	}
	wOffset := m.offsetOneofNestedMessage
	
	var entry *TestAllTypes_NestedMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypes_NestedMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOneofNestedMessage = entry
	m.parsedOneofNestedMessage = true
	return entry
}

func (m *TestAllTypesReader) GetOneofString() string {
	if m == nil {
		return ""
	}
	return m.readOneofString()
}

func (m *TestAllTypesReader) readOneofString() string {
	if m.parsedOneofString {
		return m.dataOneofString
	}
	wOffset := m.offsetOneofString
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataOneofString = entry
	m.parsedOneofString = true
	return entry
}

func (m *TestAllTypesReader) GetOneofBytes() []byte {
	if m == nil {
		return nil
	}
	return m.readOneofBytes()
}

func (m *TestAllTypesReader) readOneofBytes() []byte {
	if m.parsedOneofBytes {
		return m.dataOneofBytes
	}
	wOffset := m.offsetOneofBytes
	
	var entry []byte
	if wOffset > 0 {
		entry = m.buf.ReadBytes(wOffset)
	}
	
	m.dataOneofBytes = entry
	m.parsedOneofBytes = true
	return entry
}

func (m *TestAllTypesReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestAllTypes_OptionalInt32:
			m.offsetOptionalInt32 = offset
		case wireTestAllTypes_OptionalInt64:
			m.offsetOptionalInt64 = offset
		case wireTestAllTypes_OptionalUint32:
			m.offsetOptionalUint32 = offset
		case wireTestAllTypes_OptionalUint64:
			m.offsetOptionalUint64 = offset
		case wireTestAllTypes_OptionalSint32:
			m.offsetOptionalSint32 = offset
		case wireTestAllTypes_OptionalSint64:
			m.offsetOptionalSint64 = offset
		case wireTestAllTypes_OptionalFixed32:
			m.offsetOptionalFixed32 = offset
		case wireTestAllTypes_OptionalFixed64:
			m.offsetOptionalFixed64 = offset
		case wireTestAllTypes_OptionalSfixed32:
			m.offsetOptionalSfixed32 = offset
		case wireTestAllTypes_OptionalSfixed64:
			m.offsetOptionalSfixed64 = offset
		case wireTestAllTypes_OptionalFloat:
			m.offsetOptionalFloat = offset
		case wireTestAllTypes_OptionalDouble:
			m.offsetOptionalDouble = offset
		case wireTestAllTypes_OptionalBool:
			m.offsetOptionalBool = offset
		case wireTestAllTypes_OptionalString:
			m.offsetOptionalString = offset
		case wireTestAllTypes_OptionalBytes:
			m.offsetOptionalBytes = offset
		case wireTestAllTypes_OptionalNestedMessage:
			m.offsetOptionalNestedMessage = offset
		case wireTestAllTypes_OptionalForeignMessage:
			m.offsetOptionalForeignMessage = offset
		case wireTestAllTypes_OptionalImportMessage:
			m.offsetOptionalImportMessage = offset
		case wireTestAllTypes_OptionalNestedEnum:
			m.offsetOptionalNestedEnum = offset
		case wireTestAllTypes_OptionalForeignEnum:
			m.offsetOptionalForeignEnum = offset
		case wireTestAllTypes_OptionalImportEnum:
			m.offsetOptionalImportEnum = offset
		case wireTestAllTypes_OptionalStringPiece:
			m.offsetOptionalStringPiece = offset
		case wireTestAllTypes_OptionalCord:
			m.offsetOptionalCord = offset
		case wireTestAllTypes_OptionalPublicImportMessage:
			m.offsetOptionalPublicImportMessage = offset
		case wireTestAllTypes_OptionalLazyMessage:
			m.offsetOptionalLazyMessage = offset
		case wireTestAllTypes_OptionalUnverifiedLazyMessage:
			m.offsetOptionalUnverifiedLazyMessage = offset
		case wireTestAllTypes_RepeatedInt32:
			m.offsetRepeatedInt32 = append(m.offsetRepeatedInt32, offset)
			m.wireTypeRepeatedInt32 = append(m.wireTypeRepeatedInt32, wire)
		case wireTestAllTypes_RepeatedInt64:
			m.offsetRepeatedInt64 = append(m.offsetRepeatedInt64, offset)
			m.wireTypeRepeatedInt64 = append(m.wireTypeRepeatedInt64, wire)
		case wireTestAllTypes_RepeatedUint32:
			m.offsetRepeatedUint32 = append(m.offsetRepeatedUint32, offset)
			m.wireTypeRepeatedUint32 = append(m.wireTypeRepeatedUint32, wire)
		case wireTestAllTypes_RepeatedUint64:
			m.offsetRepeatedUint64 = append(m.offsetRepeatedUint64, offset)
			m.wireTypeRepeatedUint64 = append(m.wireTypeRepeatedUint64, wire)
		case wireTestAllTypes_RepeatedSint32:
			m.offsetRepeatedSint32 = append(m.offsetRepeatedSint32, offset)
			m.wireTypeRepeatedSint32 = append(m.wireTypeRepeatedSint32, wire)
		case wireTestAllTypes_RepeatedSint64:
			m.offsetRepeatedSint64 = append(m.offsetRepeatedSint64, offset)
			m.wireTypeRepeatedSint64 = append(m.wireTypeRepeatedSint64, wire)
		case wireTestAllTypes_RepeatedFixed32:
			m.offsetRepeatedFixed32 = append(m.offsetRepeatedFixed32, offset)
			m.wireTypeRepeatedFixed32 = append(m.wireTypeRepeatedFixed32, wire)
		case wireTestAllTypes_RepeatedFixed64:
			m.offsetRepeatedFixed64 = append(m.offsetRepeatedFixed64, offset)
			m.wireTypeRepeatedFixed64 = append(m.wireTypeRepeatedFixed64, wire)
		case wireTestAllTypes_RepeatedSfixed32:
			m.offsetRepeatedSfixed32 = append(m.offsetRepeatedSfixed32, offset)
			m.wireTypeRepeatedSfixed32 = append(m.wireTypeRepeatedSfixed32, wire)
		case wireTestAllTypes_RepeatedSfixed64:
			m.offsetRepeatedSfixed64 = append(m.offsetRepeatedSfixed64, offset)
			m.wireTypeRepeatedSfixed64 = append(m.wireTypeRepeatedSfixed64, wire)
		case wireTestAllTypes_RepeatedFloat:
			m.offsetRepeatedFloat = append(m.offsetRepeatedFloat, offset)
			m.wireTypeRepeatedFloat = append(m.wireTypeRepeatedFloat, wire)
		case wireTestAllTypes_RepeatedDouble:
			m.offsetRepeatedDouble = append(m.offsetRepeatedDouble, offset)
			m.wireTypeRepeatedDouble = append(m.wireTypeRepeatedDouble, wire)
		case wireTestAllTypes_RepeatedBool:
			m.offsetRepeatedBool = append(m.offsetRepeatedBool, offset)
			m.wireTypeRepeatedBool = append(m.wireTypeRepeatedBool, wire)
		case wireTestAllTypes_RepeatedString:
			m.offsetRepeatedString = append(m.offsetRepeatedString, offset)
		case wireTestAllTypes_RepeatedBytes:
			m.offsetRepeatedBytes = append(m.offsetRepeatedBytes, offset)
		case wireTestAllTypes_RepeatedNestedMessage:
			m.offsetRepeatedNestedMessage = append(m.offsetRepeatedNestedMessage, offset)
		case wireTestAllTypes_RepeatedForeignMessage:
			m.offsetRepeatedForeignMessage = append(m.offsetRepeatedForeignMessage, offset)
		case wireTestAllTypes_RepeatedImportMessage:
			m.offsetRepeatedImportMessage = append(m.offsetRepeatedImportMessage, offset)
		case wireTestAllTypes_RepeatedNestedEnum:
			m.offsetRepeatedNestedEnum = append(m.offsetRepeatedNestedEnum, offset)
			m.wireTypeRepeatedNestedEnum = append(m.wireTypeRepeatedNestedEnum, wire)
		case wireTestAllTypes_RepeatedForeignEnum:
			m.offsetRepeatedForeignEnum = append(m.offsetRepeatedForeignEnum, offset)
			m.wireTypeRepeatedForeignEnum = append(m.wireTypeRepeatedForeignEnum, wire)
		case wireTestAllTypes_RepeatedImportEnum:
			m.offsetRepeatedImportEnum = append(m.offsetRepeatedImportEnum, offset)
			m.wireTypeRepeatedImportEnum = append(m.wireTypeRepeatedImportEnum, wire)
		case wireTestAllTypes_RepeatedStringPiece:
			m.offsetRepeatedStringPiece = append(m.offsetRepeatedStringPiece, offset)
		case wireTestAllTypes_RepeatedCord:
			m.offsetRepeatedCord = append(m.offsetRepeatedCord, offset)
		case wireTestAllTypes_RepeatedLazyMessage:
			m.offsetRepeatedLazyMessage = append(m.offsetRepeatedLazyMessage, offset)
		case wireTestAllTypes_DefaultInt32:
			m.offsetDefaultInt32 = offset
		case wireTestAllTypes_DefaultInt64:
			m.offsetDefaultInt64 = offset
		case wireTestAllTypes_DefaultUint32:
			m.offsetDefaultUint32 = offset
		case wireTestAllTypes_DefaultUint64:
			m.offsetDefaultUint64 = offset
		case wireTestAllTypes_DefaultSint32:
			m.offsetDefaultSint32 = offset
		case wireTestAllTypes_DefaultSint64:
			m.offsetDefaultSint64 = offset
		case wireTestAllTypes_DefaultFixed32:
			m.offsetDefaultFixed32 = offset
		case wireTestAllTypes_DefaultFixed64:
			m.offsetDefaultFixed64 = offset
		case wireTestAllTypes_DefaultSfixed32:
			m.offsetDefaultSfixed32 = offset
		case wireTestAllTypes_DefaultSfixed64:
			m.offsetDefaultSfixed64 = offset
		case wireTestAllTypes_DefaultFloat:
			m.offsetDefaultFloat = offset
		case wireTestAllTypes_DefaultDouble:
			m.offsetDefaultDouble = offset
		case wireTestAllTypes_DefaultBool:
			m.offsetDefaultBool = offset
		case wireTestAllTypes_DefaultString:
			m.offsetDefaultString = offset
		case wireTestAllTypes_DefaultBytes:
			m.offsetDefaultBytes = offset
		case wireTestAllTypes_DefaultNestedEnum:
			m.offsetDefaultNestedEnum = offset
		case wireTestAllTypes_DefaultForeignEnum:
			m.offsetDefaultForeignEnum = offset
		case wireTestAllTypes_DefaultImportEnum:
			m.offsetDefaultImportEnum = offset
		case wireTestAllTypes_DefaultStringPiece:
			m.offsetDefaultStringPiece = offset
		case wireTestAllTypes_DefaultCord:
			m.offsetDefaultCord = offset
		case wireTestAllTypes_OneofUint32:
			m.offsetOneofUint32 = offset
		case wireTestAllTypes_OneofNestedMessage:
			m.offsetOneofNestedMessage = offset
		case wireTestAllTypes_OneofString:
			m.offsetOneofString = offset
		case wireTestAllTypes_OneofBytes:
			m.offsetOneofBytes = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestAllTypesReader) ToStruct() *TestAllTypes {
	if m == nil {
		return nil
	}
	res := &TestAllTypes{}
	res.OptionalInt32 = m.GetOptionalInt32()
	res.OptionalInt64 = m.GetOptionalInt64()
	res.OptionalUint32 = m.GetOptionalUint32()
	res.OptionalUint64 = m.GetOptionalUint64()
	res.OptionalSint32 = m.GetOptionalSint32()
	res.OptionalSint64 = m.GetOptionalSint64()
	res.OptionalFixed32 = m.GetOptionalFixed32()
	res.OptionalFixed64 = m.GetOptionalFixed64()
	res.OptionalSfixed32 = m.GetOptionalSfixed32()
	res.OptionalSfixed64 = m.GetOptionalSfixed64()
	res.OptionalFloat = m.GetOptionalFloat()
	res.OptionalDouble = m.GetOptionalDouble()
	res.OptionalBool = m.GetOptionalBool()
	res.OptionalString = m.GetOptionalString()
	res.OptionalBytes = m.GetOptionalBytes()

	{
		var data = m.GetOptionalNestedMessage()
		var structData *TestAllTypes_NestedMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalNestedMessage = structData
	}

	{
		var data = m.GetOptionalForeignMessage()
		var structData *ForeignMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalForeignMessage = structData
	}

	{
		var data = m.GetOptionalImportMessage()
		var structData *protobuf_unittest_import.ImportMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalImportMessage = structData
	}
	res.OptionalNestedEnum = m.GetOptionalNestedEnum()
	res.OptionalForeignEnum = m.GetOptionalForeignEnum()
	res.OptionalImportEnum = m.GetOptionalImportEnum()
	res.OptionalStringPiece = m.GetOptionalStringPiece()
	res.OptionalCord = m.GetOptionalCord()

	{
		var data = m.GetOptionalPublicImportMessage()
		var structData *protobuf_unittest_import.PublicImportMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalPublicImportMessage = structData
	}

	{
		var data = m.GetOptionalLazyMessage()
		var structData *TestAllTypes_NestedMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalLazyMessage = structData
	}

	{
		var data = m.GetOptionalUnverifiedLazyMessage()
		var structData *TestAllTypes_NestedMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalUnverifiedLazyMessage = structData
	}
	res.RepeatedInt32 = m.GetRepeatedInt32()
	res.RepeatedInt64 = m.GetRepeatedInt64()
	res.RepeatedUint32 = m.GetRepeatedUint32()
	res.RepeatedUint64 = m.GetRepeatedUint64()
	res.RepeatedSint32 = m.GetRepeatedSint32()
	res.RepeatedSint64 = m.GetRepeatedSint64()
	res.RepeatedFixed32 = m.GetRepeatedFixed32()
	res.RepeatedFixed64 = m.GetRepeatedFixed64()
	res.RepeatedSfixed32 = m.GetRepeatedSfixed32()
	res.RepeatedSfixed64 = m.GetRepeatedSfixed64()
	res.RepeatedFloat = m.GetRepeatedFloat()
	res.RepeatedDouble = m.GetRepeatedDouble()
	res.RepeatedBool = m.GetRepeatedBool()
	res.RepeatedString = m.GetRepeatedString()
	res.RepeatedBytes = m.GetRepeatedBytes()

	{
		var data = m.GetRepeatedNestedMessage()
		var structData []*TestAllTypes_NestedMessage
		if len(data) > 0 {
			structData = make([]*TestAllTypes_NestedMessage, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.RepeatedNestedMessage = structData
	}

	{
		var data = m.GetRepeatedForeignMessage()
		var structData []*ForeignMessage
		if len(data) > 0 {
			structData = make([]*ForeignMessage, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.RepeatedForeignMessage = structData
	}

	{
		var data = m.GetRepeatedImportMessage()
		var structData []*protobuf_unittest_import.ImportMessage
		if len(data) > 0 {
			structData = make([]*protobuf_unittest_import.ImportMessage, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.RepeatedImportMessage = structData
	}
	res.RepeatedNestedEnum = m.GetRepeatedNestedEnum()
	res.RepeatedForeignEnum = m.GetRepeatedForeignEnum()
	res.RepeatedImportEnum = m.GetRepeatedImportEnum()
	res.RepeatedStringPiece = m.GetRepeatedStringPiece()
	res.RepeatedCord = m.GetRepeatedCord()

	{
		var data = m.GetRepeatedLazyMessage()
		var structData []*TestAllTypes_NestedMessage
		if len(data) > 0 {
			structData = make([]*TestAllTypes_NestedMessage, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.RepeatedLazyMessage = structData
	}
	res.DefaultInt32 = m.GetDefaultInt32()
	res.DefaultInt64 = m.GetDefaultInt64()
	res.DefaultUint32 = m.GetDefaultUint32()
	res.DefaultUint64 = m.GetDefaultUint64()
	res.DefaultSint32 = m.GetDefaultSint32()
	res.DefaultSint64 = m.GetDefaultSint64()
	res.DefaultFixed32 = m.GetDefaultFixed32()
	res.DefaultFixed64 = m.GetDefaultFixed64()
	res.DefaultSfixed32 = m.GetDefaultSfixed32()
	res.DefaultSfixed64 = m.GetDefaultSfixed64()
	res.DefaultFloat = m.GetDefaultFloat()
	res.DefaultDouble = m.GetDefaultDouble()
	res.DefaultBool = m.GetDefaultBool()
	res.DefaultString = m.GetDefaultString()
	res.DefaultBytes = m.GetDefaultBytes()
	res.DefaultNestedEnum = m.GetDefaultNestedEnum()
	res.DefaultForeignEnum = m.GetDefaultForeignEnum()
	res.DefaultImportEnum = m.GetDefaultImportEnum()
	res.DefaultStringPiece = m.GetDefaultStringPiece()
	res.DefaultCord = m.GetDefaultCord()
	res.OneofUint32 = m.GetOneofUint32()

	{
		var data = m.GetOneofNestedMessage()
		var structData *TestAllTypes_NestedMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.OneofNestedMessage = structData
	}
	res.OneofString = m.GetOneofString()
	res.OneofBytes = m.GetOneofBytes()

	return res
}

func (s *TestAllTypesReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestAllTypes struct {
	OptionalInt32	int32	`json:"optional_int32,omitempty"`
	OptionalInt64	int64	`json:"optional_int64,omitempty"`
	OptionalUint32	uint32	`json:"optional_uint32,omitempty"`
	OptionalUint64	uint64	`json:"optional_uint64,omitempty"`
	OptionalSint32	int32	`json:"optional_sint32,omitempty"`
	OptionalSint64	int64	`json:"optional_sint64,omitempty"`
	OptionalFixed32	uint32	`json:"optional_fixed32,omitempty"`
	OptionalFixed64	uint64	`json:"optional_fixed64,omitempty"`
	OptionalSfixed32	int32	`json:"optional_sfixed32,omitempty"`
	OptionalSfixed64	int64	`json:"optional_sfixed64,omitempty"`
	OptionalFloat	float32	`json:"optional_float,omitempty"`
	OptionalDouble	float64	`json:"optional_double,omitempty"`
	OptionalBool	bool	`json:"optional_bool,omitempty"`
	OptionalString	string	`json:"optional_string,omitempty"`
	OptionalBytes	[]byte	`json:"optional_bytes,omitempty"`
	OptionalNestedMessage	*TestAllTypes_NestedMessage	`json:"optional_nested_message,omitempty"`
	OptionalForeignMessage	*ForeignMessage	`json:"optional_foreign_message,omitempty"`
	OptionalImportMessage	*protobuf_unittest_import.ImportMessage	`json:"optional_import_message,omitempty"`
	OptionalNestedEnum	TestAllTypes_NestedEnum	`json:"optional_nested_enum,omitempty"`
	OptionalForeignEnum	ForeignEnum	`json:"optional_foreign_enum,omitempty"`
	OptionalImportEnum	protobuf_unittest_import.ImportEnum	`json:"optional_import_enum,omitempty"`
	OptionalStringPiece	string	`json:"optional_string_piece,omitempty"`
	OptionalCord	string	`json:"optional_cord,omitempty"`
	OptionalPublicImportMessage	*protobuf_unittest_import.PublicImportMessage	`json:"optional_public_import_message,omitempty"`
	OptionalLazyMessage	*TestAllTypes_NestedMessage	`json:"optional_lazy_message,omitempty"`
	OptionalUnverifiedLazyMessage	*TestAllTypes_NestedMessage	`json:"optional_unverified_lazy_message,omitempty"`
	RepeatedInt32	[]int32	`json:"repeated_int32,omitempty"`
	RepeatedInt64	[]int64	`json:"repeated_int64,omitempty"`
	RepeatedUint32	[]uint32	`json:"repeated_uint32,omitempty"`
	RepeatedUint64	[]uint64	`json:"repeated_uint64,omitempty"`
	RepeatedSint32	[]int32	`json:"repeated_sint32,omitempty"`
	RepeatedSint64	[]int64	`json:"repeated_sint64,omitempty"`
	RepeatedFixed32	[]uint32	`json:"repeated_fixed32,omitempty"`
	RepeatedFixed64	[]uint64	`json:"repeated_fixed64,omitempty"`
	RepeatedSfixed32	[]int32	`json:"repeated_sfixed32,omitempty"`
	RepeatedSfixed64	[]int64	`json:"repeated_sfixed64,omitempty"`
	RepeatedFloat	[]float32	`json:"repeated_float,omitempty"`
	RepeatedDouble	[]float64	`json:"repeated_double,omitempty"`
	RepeatedBool	[]bool	`json:"repeated_bool,omitempty"`
	RepeatedString	[]string	`json:"repeated_string,omitempty"`
	RepeatedBytes	[][]byte	`json:"repeated_bytes,omitempty"`
	RepeatedNestedMessage	[]*TestAllTypes_NestedMessage	`json:"repeated_nested_message,omitempty"`
	RepeatedForeignMessage	[]*ForeignMessage	`json:"repeated_foreign_message,omitempty"`
	RepeatedImportMessage	[]*protobuf_unittest_import.ImportMessage	`json:"repeated_import_message,omitempty"`
	RepeatedNestedEnum	[]TestAllTypes_NestedEnum	`json:"repeated_nested_enum,omitempty"`
	RepeatedForeignEnum	[]ForeignEnum	`json:"repeated_foreign_enum,omitempty"`
	RepeatedImportEnum	[]protobuf_unittest_import.ImportEnum	`json:"repeated_import_enum,omitempty"`
	RepeatedStringPiece	[]string	`json:"repeated_string_piece,omitempty"`
	RepeatedCord	[]string	`json:"repeated_cord,omitempty"`
	RepeatedLazyMessage	[]*TestAllTypes_NestedMessage	`json:"repeated_lazy_message,omitempty"`
	DefaultInt32	int32	`json:"default_int32,omitempty"`
	DefaultInt64	int64	`json:"default_int64,omitempty"`
	DefaultUint32	uint32	`json:"default_uint32,omitempty"`
	DefaultUint64	uint64	`json:"default_uint64,omitempty"`
	DefaultSint32	int32	`json:"default_sint32,omitempty"`
	DefaultSint64	int64	`json:"default_sint64,omitempty"`
	DefaultFixed32	uint32	`json:"default_fixed32,omitempty"`
	DefaultFixed64	uint64	`json:"default_fixed64,omitempty"`
	DefaultSfixed32	int32	`json:"default_sfixed32,omitempty"`
	DefaultSfixed64	int64	`json:"default_sfixed64,omitempty"`
	DefaultFloat	float32	`json:"default_float,omitempty"`
	DefaultDouble	float64	`json:"default_double,omitempty"`
	DefaultBool	bool	`json:"default_bool,omitempty"`
	DefaultString	string	`json:"default_string,omitempty"`
	DefaultBytes	[]byte	`json:"default_bytes,omitempty"`
	DefaultNestedEnum	TestAllTypes_NestedEnum	`json:"default_nested_enum,omitempty"`
	DefaultForeignEnum	ForeignEnum	`json:"default_foreign_enum,omitempty"`
	DefaultImportEnum	protobuf_unittest_import.ImportEnum	`json:"default_import_enum,omitempty"`
	DefaultStringPiece	string	`json:"default_string_piece,omitempty"`
	DefaultCord	string	`json:"default_cord,omitempty"`
	OneofUint32	uint32	`json:"oneof_uint32,omitempty"`
	OneofNestedMessage	*TestAllTypes_NestedMessage	`json:"oneof_nested_message,omitempty"`
	OneofString	string	`json:"oneof_string,omitempty"`
	OneofBytes	[]byte	`json:"oneof_bytes,omitempty"`
}

func (s *TestAllTypes) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestAllTypes) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.OptionalInt32 != 0 {
		res.AppendInt32(wireTestAllTypes_OptionalInt32, s.OptionalInt32)
	}
	if s.OptionalInt64 != 0 {
		res.AppendInt64(wireTestAllTypes_OptionalInt64, s.OptionalInt64)
	}
	if s.OptionalUint32 != 0 {
		res.AppendUint32(wireTestAllTypes_OptionalUint32, s.OptionalUint32)
	}
	if s.OptionalUint64 != 0 {
		res.AppendUint64(wireTestAllTypes_OptionalUint64, s.OptionalUint64)
	}
	if s.OptionalSint32 != 0 {
		res.AppendSInt32(wireTestAllTypes_OptionalSint32, s.OptionalSint32)
	}
	if s.OptionalSint64 != 0 {
		res.AppendSInt64(wireTestAllTypes_OptionalSint64, s.OptionalSint64)
	}
	if s.OptionalFixed32 != 0 {
		res.AppendFixed32(wireTestAllTypes_OptionalFixed32, s.OptionalFixed32)
	}
	if s.OptionalFixed64 != 0 {
		res.AppendFixed64(wireTestAllTypes_OptionalFixed64, s.OptionalFixed64)
	}
	if s.OptionalSfixed32 != 0 {
		res.AppendSFixed32(wireTestAllTypes_OptionalSfixed32, s.OptionalSfixed32)
	}
	if s.OptionalSfixed64 != 0 {
		res.AppendSFixed64(wireTestAllTypes_OptionalSfixed64, s.OptionalSfixed64)
	}
	if s.OptionalFloat != 0 {
		res.AppendFloat32(wireTestAllTypes_OptionalFloat, s.OptionalFloat)
	}
	if s.OptionalDouble != 0 {
		res.AppendFloat64(wireTestAllTypes_OptionalDouble, s.OptionalDouble)
	}
	if s.OptionalBool {
		res.AppendBool(wireTestAllTypes_OptionalBool, s.OptionalBool)
	}
	if s.OptionalString != "" {
		res.AppendString(wireTestAllTypes_OptionalString, s.OptionalString)
	}
	if len(s.OptionalBytes) != 0 {
		res.AppendBytes(wireTestAllTypes_OptionalBytes, s.OptionalBytes)
	}
	if s.OptionalNestedMessage != nil {
		structSize := s.OptionalNestedMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestAllTypes_OptionalNestedMessage, structSize)
		s.OptionalNestedMessage.MarshalTo(res)
	}
	if s.OptionalForeignMessage != nil {
		structSize := s.OptionalForeignMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestAllTypes_OptionalForeignMessage, structSize)
		s.OptionalForeignMessage.MarshalTo(res)
	}
	if s.OptionalImportMessage != nil {
		structSize := s.OptionalImportMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestAllTypes_OptionalImportMessage, structSize)
		s.OptionalImportMessage.MarshalTo(res)
	}
	if s.OptionalNestedEnum != 0 {
		res.AppendInt32(wireTestAllTypes_OptionalNestedEnum, int32(s.OptionalNestedEnum))
	}
	if s.OptionalForeignEnum != 0 {
		res.AppendInt32(wireTestAllTypes_OptionalForeignEnum, int32(s.OptionalForeignEnum))
	}
	if s.OptionalImportEnum != 0 {
		res.AppendInt32(wireTestAllTypes_OptionalImportEnum, int32(s.OptionalImportEnum))
	}
	if s.OptionalStringPiece != "" {
		res.AppendString(wireTestAllTypes_OptionalStringPiece, s.OptionalStringPiece)
	}
	if s.OptionalCord != "" {
		res.AppendString(wireTestAllTypes_OptionalCord, s.OptionalCord)
	}
	if s.OptionalPublicImportMessage != nil {
		structSize := s.OptionalPublicImportMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestAllTypes_OptionalPublicImportMessage, structSize)
		s.OptionalPublicImportMessage.MarshalTo(res)
	}
	if s.OptionalLazyMessage != nil {
		structSize := s.OptionalLazyMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestAllTypes_OptionalLazyMessage, structSize)
		s.OptionalLazyMessage.MarshalTo(res)
	}
	if s.OptionalUnverifiedLazyMessage != nil {
		structSize := s.OptionalUnverifiedLazyMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestAllTypes_OptionalUnverifiedLazyMessage, structSize)
		s.OptionalUnverifiedLazyMessage.MarshalTo(res)
	}
	if len(s.RepeatedInt32) > 0 {
		if len(s.RepeatedInt32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedInt32 {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllTypes_RepeatedInt32, listBytesSize)
			for _, entry := range s.RepeatedInt32 {
				res.AppendInt32WithoutTag(entry)
			}
		} else if len(s.RepeatedInt32) == 1 {
			res.AppendInt32(wireTestAllTypes_RepeatedInt32, s.RepeatedInt32[0])
		}
	}
	if len(s.RepeatedInt64) > 0 {
		if len(s.RepeatedInt64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedInt64 {
				var entrySize = 0
				entrySize = gremlin.SizeInt64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllTypes_RepeatedInt64, listBytesSize)
			for _, entry := range s.RepeatedInt64 {
				res.AppendInt64WithoutTag(entry)
			}
		} else if len(s.RepeatedInt64) == 1 {
			res.AppendInt64(wireTestAllTypes_RepeatedInt64, s.RepeatedInt64[0])
		}
	}
	if len(s.RepeatedUint32) > 0 {
		if len(s.RepeatedUint32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedUint32 {
				var entrySize = 0
				entrySize = gremlin.SizeUint32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllTypes_RepeatedUint32, listBytesSize)
			for _, entry := range s.RepeatedUint32 {
				res.AppendUint32WithoutTag(entry)
			}
		} else if len(s.RepeatedUint32) == 1 {
			res.AppendUint32(wireTestAllTypes_RepeatedUint32, s.RepeatedUint32[0])
		}
	}
	if len(s.RepeatedUint64) > 0 {
		if len(s.RepeatedUint64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedUint64 {
				var entrySize = 0
				entrySize = gremlin.SizeUint64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllTypes_RepeatedUint64, listBytesSize)
			for _, entry := range s.RepeatedUint64 {
				res.AppendUint64WithoutTag(entry)
			}
		} else if len(s.RepeatedUint64) == 1 {
			res.AppendUint64(wireTestAllTypes_RepeatedUint64, s.RepeatedUint64[0])
		}
	}
	if len(s.RepeatedSint32) > 0 {
		if len(s.RepeatedSint32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedSint32 {
				var entrySize = 0
				entrySize = gremlin.SizeSInt32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllTypes_RepeatedSint32, listBytesSize)
			for _, entry := range s.RepeatedSint32 {
				res.AppendSInt32WithoutTag(entry)
			}
		} else if len(s.RepeatedSint32) == 1 {
			res.AppendSInt32(wireTestAllTypes_RepeatedSint32, s.RepeatedSint32[0])
		}
	}
	if len(s.RepeatedSint64) > 0 {
		if len(s.RepeatedSint64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedSint64 {
				var entrySize = 0
				entrySize = gremlin.SizeSInt64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllTypes_RepeatedSint64, listBytesSize)
			for _, entry := range s.RepeatedSint64 {
				res.AppendSInt64WithoutTag(entry)
			}
		} else if len(s.RepeatedSint64) == 1 {
			res.AppendSInt64(wireTestAllTypes_RepeatedSint64, s.RepeatedSint64[0])
		}
	}
	if len(s.RepeatedFixed32) > 0 {
		if len(s.RepeatedFixed32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedFixed32 {
				var entrySize = 0
				entrySize = gremlin.SizeFixed32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllTypes_RepeatedFixed32, listBytesSize)
			for _, entry := range s.RepeatedFixed32 {
				res.AppendFixed32WithoutTag(entry)
			}
		} else if len(s.RepeatedFixed32) == 1 {
			res.AppendFixed32(wireTestAllTypes_RepeatedFixed32, s.RepeatedFixed32[0])
		}
	}
	if len(s.RepeatedFixed64) > 0 {
		if len(s.RepeatedFixed64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedFixed64 {
				var entrySize = 0
				entrySize = gremlin.SizeFixed64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllTypes_RepeatedFixed64, listBytesSize)
			for _, entry := range s.RepeatedFixed64 {
				res.AppendFixed64WithoutTag(entry)
			}
		} else if len(s.RepeatedFixed64) == 1 {
			res.AppendFixed64(wireTestAllTypes_RepeatedFixed64, s.RepeatedFixed64[0])
		}
	}
	if len(s.RepeatedSfixed32) > 0 {
		if len(s.RepeatedSfixed32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedSfixed32 {
				var entrySize = 0
				entrySize = gremlin.SizeSFixed32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllTypes_RepeatedSfixed32, listBytesSize)
			for _, entry := range s.RepeatedSfixed32 {
				res.AppendSFixed32WithoutTag(entry)
			}
		} else if len(s.RepeatedSfixed32) == 1 {
			res.AppendSFixed32(wireTestAllTypes_RepeatedSfixed32, s.RepeatedSfixed32[0])
		}
	}
	if len(s.RepeatedSfixed64) > 0 {
		if len(s.RepeatedSfixed64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedSfixed64 {
				var entrySize = 0
				entrySize = gremlin.SizeSFixed64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllTypes_RepeatedSfixed64, listBytesSize)
			for _, entry := range s.RepeatedSfixed64 {
				res.AppendSFixed64WithoutTag(entry)
			}
		} else if len(s.RepeatedSfixed64) == 1 {
			res.AppendSFixed64(wireTestAllTypes_RepeatedSfixed64, s.RepeatedSfixed64[0])
		}
	}
	if len(s.RepeatedFloat) > 0 {
		if len(s.RepeatedFloat) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedFloat {
				var entrySize = 0
				entrySize = gremlin.SizeFloat32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllTypes_RepeatedFloat, listBytesSize)
			for _, entry := range s.RepeatedFloat {
				res.AppendFloat32WithoutTag(entry)
			}
		} else if len(s.RepeatedFloat) == 1 {
			res.AppendFloat32(wireTestAllTypes_RepeatedFloat, s.RepeatedFloat[0])
		}
	}
	if len(s.RepeatedDouble) > 0 {
		if len(s.RepeatedDouble) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedDouble {
				var entrySize = 0
				entrySize = gremlin.SizeFloat64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllTypes_RepeatedDouble, listBytesSize)
			for _, entry := range s.RepeatedDouble {
				res.AppendFloat64WithoutTag(entry)
			}
		} else if len(s.RepeatedDouble) == 1 {
			res.AppendFloat64(wireTestAllTypes_RepeatedDouble, s.RepeatedDouble[0])
		}
	}
	if len(s.RepeatedBool) > 0 {
		if len(s.RepeatedBool) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedBool {
				var entrySize = 0
				entrySize = gremlin.SizeBool(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllTypes_RepeatedBool, listBytesSize)
			for _, entry := range s.RepeatedBool {
				res.AppendBoolWithoutTag(entry)
			}
		} else if len(s.RepeatedBool) == 1 {
			res.AppendBool(wireTestAllTypes_RepeatedBool, s.RepeatedBool[0])
		}
	}
	if len(s.RepeatedString) > 0 {
		for _, entry := range s.RepeatedString {
			res.AppendString(wireTestAllTypes_RepeatedString, entry)
		}
	}
	if len(s.RepeatedBytes) > 0 {
		for _, entry := range s.RepeatedBytes {
			res.AppendBytes(wireTestAllTypes_RepeatedBytes, entry)
		}
	}
	if len(s.RepeatedNestedMessage) > 0 {
		for _, entry := range s.RepeatedNestedMessage {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireTestAllTypes_RepeatedNestedMessage, structSize)
			entry.MarshalTo(res)
		}
	}
	if len(s.RepeatedForeignMessage) > 0 {
		for _, entry := range s.RepeatedForeignMessage {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireTestAllTypes_RepeatedForeignMessage, structSize)
			entry.MarshalTo(res)
		}
	}
	if len(s.RepeatedImportMessage) > 0 {
		for _, entry := range s.RepeatedImportMessage {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireTestAllTypes_RepeatedImportMessage, structSize)
			entry.MarshalTo(res)
		}
	}
	if len(s.RepeatedNestedEnum) > 0 {
		if len(s.RepeatedNestedEnum) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedNestedEnum {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(int32(entry))
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllTypes_RepeatedNestedEnum, listBytesSize)
			for _, entry := range s.RepeatedNestedEnum {
				res.AppendInt32WithoutTag(int32(entry))
			}
		} else if len(s.RepeatedNestedEnum) == 1 {
			res.AppendInt32(wireTestAllTypes_RepeatedNestedEnum, int32(s.RepeatedNestedEnum[0]))
		}
	}
	if len(s.RepeatedForeignEnum) > 0 {
		if len(s.RepeatedForeignEnum) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedForeignEnum {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(int32(entry))
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllTypes_RepeatedForeignEnum, listBytesSize)
			for _, entry := range s.RepeatedForeignEnum {
				res.AppendInt32WithoutTag(int32(entry))
			}
		} else if len(s.RepeatedForeignEnum) == 1 {
			res.AppendInt32(wireTestAllTypes_RepeatedForeignEnum, int32(s.RepeatedForeignEnum[0]))
		}
	}
	if len(s.RepeatedImportEnum) > 0 {
		if len(s.RepeatedImportEnum) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedImportEnum {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(int32(entry))
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllTypes_RepeatedImportEnum, listBytesSize)
			for _, entry := range s.RepeatedImportEnum {
				res.AppendInt32WithoutTag(int32(entry))
			}
		} else if len(s.RepeatedImportEnum) == 1 {
			res.AppendInt32(wireTestAllTypes_RepeatedImportEnum, int32(s.RepeatedImportEnum[0]))
		}
	}
	if len(s.RepeatedStringPiece) > 0 {
		for _, entry := range s.RepeatedStringPiece {
			res.AppendString(wireTestAllTypes_RepeatedStringPiece, entry)
		}
	}
	if len(s.RepeatedCord) > 0 {
		for _, entry := range s.RepeatedCord {
			res.AppendString(wireTestAllTypes_RepeatedCord, entry)
		}
	}
	if len(s.RepeatedLazyMessage) > 0 {
		for _, entry := range s.RepeatedLazyMessage {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireTestAllTypes_RepeatedLazyMessage, structSize)
			entry.MarshalTo(res)
		}
	}
	if s.DefaultInt32 != 41 {
		res.AppendInt32(wireTestAllTypes_DefaultInt32, s.DefaultInt32)
	}
	if s.DefaultInt64 != 42 {
		res.AppendInt64(wireTestAllTypes_DefaultInt64, s.DefaultInt64)
	}
	if s.DefaultUint32 != 43 {
		res.AppendUint32(wireTestAllTypes_DefaultUint32, s.DefaultUint32)
	}
	if s.DefaultUint64 != 44 {
		res.AppendUint64(wireTestAllTypes_DefaultUint64, s.DefaultUint64)
	}
	if s.DefaultSint32 != -45 {
		res.AppendSInt32(wireTestAllTypes_DefaultSint32, s.DefaultSint32)
	}
	if s.DefaultSint64 != 46 {
		res.AppendSInt64(wireTestAllTypes_DefaultSint64, s.DefaultSint64)
	}
	if s.DefaultFixed32 != 47 {
		res.AppendFixed32(wireTestAllTypes_DefaultFixed32, s.DefaultFixed32)
	}
	if s.DefaultFixed64 != 48 {
		res.AppendFixed64(wireTestAllTypes_DefaultFixed64, s.DefaultFixed64)
	}
	if s.DefaultSfixed32 != 49 {
		res.AppendSFixed32(wireTestAllTypes_DefaultSfixed32, s.DefaultSfixed32)
	}
	if s.DefaultSfixed64 != -50 {
		res.AppendSFixed64(wireTestAllTypes_DefaultSfixed64, s.DefaultSfixed64)
	}
	if s.DefaultFloat != 51.5 {
		res.AppendFloat32(wireTestAllTypes_DefaultFloat, s.DefaultFloat)
	}
	if s.DefaultDouble != 52e3 {
		res.AppendFloat64(wireTestAllTypes_DefaultDouble, s.DefaultDouble)
	}
	if s.DefaultBool != true {
		res.AppendBool(wireTestAllTypes_DefaultBool, s.DefaultBool)
	}
	if s.DefaultString != "hello" {
		res.AppendString(wireTestAllTypes_DefaultString, s.DefaultString)
	}
	if !bytes.Equal(s.DefaultBytes, []byte("world")) {
		res.AppendBytes(wireTestAllTypes_DefaultBytes, s.DefaultBytes)
	}
	if s.DefaultNestedEnum != 0 {
		res.AppendInt32(wireTestAllTypes_DefaultNestedEnum, int32(s.DefaultNestedEnum))
	}
	if s.DefaultForeignEnum != 0 {
		res.AppendInt32(wireTestAllTypes_DefaultForeignEnum, int32(s.DefaultForeignEnum))
	}
	if s.DefaultImportEnum != 0 {
		res.AppendInt32(wireTestAllTypes_DefaultImportEnum, int32(s.DefaultImportEnum))
	}
	if s.DefaultStringPiece != "abc" {
		res.AppendString(wireTestAllTypes_DefaultStringPiece, s.DefaultStringPiece)
	}
	if s.DefaultCord != "123" {
		res.AppendString(wireTestAllTypes_DefaultCord, s.DefaultCord)
	}
	if s.OneofUint32 != 0 {
		res.AppendUint32(wireTestAllTypes_OneofUint32, s.OneofUint32)
	}
	if s.OneofNestedMessage != nil {
		structSize := s.OneofNestedMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestAllTypes_OneofNestedMessage, structSize)
		s.OneofNestedMessage.MarshalTo(res)
	}
	if s.OneofString != "" {
		res.AppendString(wireTestAllTypes_OneofString, s.OneofString)
	}
	if len(s.OneofBytes) != 0 {
		res.AppendBytes(wireTestAllTypes_OneofBytes, s.OneofBytes)
	}
}

func (s *TestAllTypes) Copy() *TestAllTypes {
	if s == nil {
		return nil
	}
	res := &TestAllTypes{}
	res.OptionalInt32 = s.OptionalInt32
	res.OptionalInt64 = s.OptionalInt64
	res.OptionalUint32 = s.OptionalUint32
	res.OptionalUint64 = s.OptionalUint64
	res.OptionalSint32 = s.OptionalSint32
	res.OptionalSint64 = s.OptionalSint64
	res.OptionalFixed32 = s.OptionalFixed32
	res.OptionalFixed64 = s.OptionalFixed64
	res.OptionalSfixed32 = s.OptionalSfixed32
	res.OptionalSfixed64 = s.OptionalSfixed64
	res.OptionalFloat = s.OptionalFloat
	res.OptionalDouble = s.OptionalDouble
	res.OptionalBool = s.OptionalBool
	res.OptionalString = s.OptionalString
	res.OptionalBytes = s.OptionalBytes
	if s.OptionalNestedMessage != nil {
		res.OptionalNestedMessage = s.OptionalNestedMessage.Copy()
	}
	if s.OptionalForeignMessage != nil {
		res.OptionalForeignMessage = s.OptionalForeignMessage.Copy()
	}
	if s.OptionalImportMessage != nil {
		res.OptionalImportMessage = s.OptionalImportMessage.Copy()
	}
	res.OptionalNestedEnum = s.OptionalNestedEnum
	res.OptionalForeignEnum = s.OptionalForeignEnum
	res.OptionalImportEnum = s.OptionalImportEnum
	res.OptionalStringPiece = s.OptionalStringPiece
	res.OptionalCord = s.OptionalCord
	if s.OptionalPublicImportMessage != nil {
		res.OptionalPublicImportMessage = s.OptionalPublicImportMessage.Copy()
	}
	if s.OptionalLazyMessage != nil {
		res.OptionalLazyMessage = s.OptionalLazyMessage.Copy()
	}
	if s.OptionalUnverifiedLazyMessage != nil {
		res.OptionalUnverifiedLazyMessage = s.OptionalUnverifiedLazyMessage.Copy()
	}
	res.RepeatedInt32 = s.RepeatedInt32
	res.RepeatedInt64 = s.RepeatedInt64
	res.RepeatedUint32 = s.RepeatedUint32
	res.RepeatedUint64 = s.RepeatedUint64
	res.RepeatedSint32 = s.RepeatedSint32
	res.RepeatedSint64 = s.RepeatedSint64
	res.RepeatedFixed32 = s.RepeatedFixed32
	res.RepeatedFixed64 = s.RepeatedFixed64
	res.RepeatedSfixed32 = s.RepeatedSfixed32
	res.RepeatedSfixed64 = s.RepeatedSfixed64
	res.RepeatedFloat = s.RepeatedFloat
	res.RepeatedDouble = s.RepeatedDouble
	res.RepeatedBool = s.RepeatedBool
	res.RepeatedString = s.RepeatedString
	res.RepeatedBytes = s.RepeatedBytes
	res.RepeatedNestedMessage = make([]*TestAllTypes_NestedMessage, len(s.RepeatedNestedMessage))
	for i := range s.RepeatedNestedMessage {
		if s.RepeatedNestedMessage[i] != nil {
			res.RepeatedNestedMessage[i] = s.RepeatedNestedMessage[i].Copy()
		}
	}
	res.RepeatedForeignMessage = make([]*ForeignMessage, len(s.RepeatedForeignMessage))
	for i := range s.RepeatedForeignMessage {
		if s.RepeatedForeignMessage[i] != nil {
			res.RepeatedForeignMessage[i] = s.RepeatedForeignMessage[i].Copy()
		}
	}
	res.RepeatedImportMessage = make([]*protobuf_unittest_import.ImportMessage, len(s.RepeatedImportMessage))
	for i := range s.RepeatedImportMessage {
		if s.RepeatedImportMessage[i] != nil {
			res.RepeatedImportMessage[i] = s.RepeatedImportMessage[i].Copy()
		}
	}
	res.RepeatedNestedEnum = s.RepeatedNestedEnum
	res.RepeatedForeignEnum = s.RepeatedForeignEnum
	res.RepeatedImportEnum = s.RepeatedImportEnum
	res.RepeatedStringPiece = s.RepeatedStringPiece
	res.RepeatedCord = s.RepeatedCord
	res.RepeatedLazyMessage = make([]*TestAllTypes_NestedMessage, len(s.RepeatedLazyMessage))
	for i := range s.RepeatedLazyMessage {
		if s.RepeatedLazyMessage[i] != nil {
			res.RepeatedLazyMessage[i] = s.RepeatedLazyMessage[i].Copy()
		}
	}
	res.DefaultInt32 = s.DefaultInt32
	res.DefaultInt64 = s.DefaultInt64
	res.DefaultUint32 = s.DefaultUint32
	res.DefaultUint64 = s.DefaultUint64
	res.DefaultSint32 = s.DefaultSint32
	res.DefaultSint64 = s.DefaultSint64
	res.DefaultFixed32 = s.DefaultFixed32
	res.DefaultFixed64 = s.DefaultFixed64
	res.DefaultSfixed32 = s.DefaultSfixed32
	res.DefaultSfixed64 = s.DefaultSfixed64
	res.DefaultFloat = s.DefaultFloat
	res.DefaultDouble = s.DefaultDouble
	res.DefaultBool = s.DefaultBool
	res.DefaultString = s.DefaultString
	res.DefaultBytes = s.DefaultBytes
	res.DefaultNestedEnum = s.DefaultNestedEnum
	res.DefaultForeignEnum = s.DefaultForeignEnum
	res.DefaultImportEnum = s.DefaultImportEnum
	res.DefaultStringPiece = s.DefaultStringPiece
	res.DefaultCord = s.DefaultCord
	res.OneofUint32 = s.OneofUint32
	if s.OneofNestedMessage != nil {
		res.OneofNestedMessage = s.OneofNestedMessage.Copy()
	}
	res.OneofString = s.OneofString
	res.OneofBytes = s.OneofBytes

	return res
}

func (s *TestAllTypes) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.OptionalInt32 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_OptionalInt32) + gremlin.SizeInt32(s.OptionalInt32)
		size += entrySize
	}

	if s.OptionalInt64 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_OptionalInt64) + gremlin.SizeInt64(s.OptionalInt64)
		size += entrySize
	}

	if s.OptionalUint32 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_OptionalUint32) + gremlin.SizeUint32(s.OptionalUint32)
		size += entrySize
	}

	if s.OptionalUint64 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_OptionalUint64) + gremlin.SizeUint64(s.OptionalUint64)
		size += entrySize
	}

	if s.OptionalSint32 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_OptionalSint32) + gremlin.SizeSInt32(s.OptionalSint32)
		size += entrySize
	}

	if s.OptionalSint64 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_OptionalSint64) + gremlin.SizeSInt64(s.OptionalSint64)
		size += entrySize
	}

	if s.OptionalFixed32 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_OptionalFixed32) + gremlin.SizeFixed32(s.OptionalFixed32)
		size += entrySize
	}

	if s.OptionalFixed64 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_OptionalFixed64) + gremlin.SizeFixed64(s.OptionalFixed64)
		size += entrySize
	}

	if s.OptionalSfixed32 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_OptionalSfixed32) + gremlin.SizeSFixed32(s.OptionalSfixed32)
		size += entrySize
	}

	if s.OptionalSfixed64 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_OptionalSfixed64) + gremlin.SizeSFixed64(s.OptionalSfixed64)
		size += entrySize
	}

	if s.OptionalFloat != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_OptionalFloat) + gremlin.SizeFloat32(s.OptionalFloat)
		size += entrySize
	}

	if s.OptionalDouble != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_OptionalDouble) + gremlin.SizeFloat64(s.OptionalDouble)
		size += entrySize
	}

	if s.OptionalBool {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_OptionalBool) + gremlin.SizeBool(s.OptionalBool)
		size += entrySize
	}

	if s.OptionalString != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.OptionalString)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllTypes_OptionalString)
		size += entrySize
	}

	if len(s.OptionalBytes) != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeBytes(s.OptionalBytes)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllTypes_OptionalBytes)
		size += entrySize
	}

	if s.OptionalNestedMessage != nil {
		var entrySize = 0
		entrySize = s.OptionalNestedMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllTypes_OptionalNestedMessage)
		
		size += entrySize
	}

	if s.OptionalForeignMessage != nil {
		var entrySize = 0
		entrySize = s.OptionalForeignMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllTypes_OptionalForeignMessage)
		
		size += entrySize
	}

	if s.OptionalImportMessage != nil {
		var entrySize = 0
		entrySize = s.OptionalImportMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllTypes_OptionalImportMessage)
		
		size += entrySize
	}

	if s.OptionalNestedEnum != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_OptionalNestedEnum) + gremlin.SizeInt32(int32(s.OptionalNestedEnum))
		size += entrySize
	}

	if s.OptionalForeignEnum != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_OptionalForeignEnum) + gremlin.SizeInt32(int32(s.OptionalForeignEnum))
		size += entrySize
	}

	if s.OptionalImportEnum != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_OptionalImportEnum) + gremlin.SizeInt32(int32(s.OptionalImportEnum))
		size += entrySize
	}

	if s.OptionalStringPiece != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.OptionalStringPiece)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllTypes_OptionalStringPiece)
		size += entrySize
	}

	if s.OptionalCord != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.OptionalCord)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllTypes_OptionalCord)
		size += entrySize
	}

	if s.OptionalPublicImportMessage != nil {
		var entrySize = 0
		entrySize = s.OptionalPublicImportMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllTypes_OptionalPublicImportMessage)
		
		size += entrySize
	}

	if s.OptionalLazyMessage != nil {
		var entrySize = 0
		entrySize = s.OptionalLazyMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllTypes_OptionalLazyMessage)
		
		size += entrySize
	}

	if s.OptionalUnverifiedLazyMessage != nil {
		var entrySize = 0
		entrySize = s.OptionalUnverifiedLazyMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllTypes_OptionalUnverifiedLazyMessage)
		
		size += entrySize
	}

	if len(s.RepeatedInt32) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedInt32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedInt32 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedInt32) + listBytesSize
		} else if len(s.RepeatedInt32) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllTypes_RepeatedInt32) + gremlin.SizeInt32(s.RepeatedInt32[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedInt64) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedInt64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedInt64 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedInt64) + listBytesSize
		} else if len(s.RepeatedInt64) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllTypes_RepeatedInt64) + gremlin.SizeInt64(s.RepeatedInt64[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedUint32) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedUint32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedUint32 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeUint32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedUint32) + listBytesSize
		} else if len(s.RepeatedUint32) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllTypes_RepeatedUint32) + gremlin.SizeUint32(s.RepeatedUint32[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedUint64) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedUint64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedUint64 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeUint64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedUint64) + listBytesSize
		} else if len(s.RepeatedUint64) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllTypes_RepeatedUint64) + gremlin.SizeUint64(s.RepeatedUint64[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedSint32) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedSint32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedSint32 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSInt32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedSint32) + listBytesSize
		} else if len(s.RepeatedSint32) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllTypes_RepeatedSint32) + gremlin.SizeSInt32(s.RepeatedSint32[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedSint64) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedSint64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedSint64 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSInt64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedSint64) + listBytesSize
		} else if len(s.RepeatedSint64) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllTypes_RepeatedSint64) + gremlin.SizeSInt64(s.RepeatedSint64[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedFixed32) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedFixed32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedFixed32 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFixed32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedFixed32) + listBytesSize
		} else if len(s.RepeatedFixed32) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllTypes_RepeatedFixed32) + gremlin.SizeFixed32(s.RepeatedFixed32[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedFixed64) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedFixed64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedFixed64 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFixed64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedFixed64) + listBytesSize
		} else if len(s.RepeatedFixed64) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllTypes_RepeatedFixed64) + gremlin.SizeFixed64(s.RepeatedFixed64[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedSfixed32) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedSfixed32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedSfixed32 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSFixed32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedSfixed32) + listBytesSize
		} else if len(s.RepeatedSfixed32) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllTypes_RepeatedSfixed32) + gremlin.SizeSFixed32(s.RepeatedSfixed32[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedSfixed64) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedSfixed64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedSfixed64 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSFixed64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedSfixed64) + listBytesSize
		} else if len(s.RepeatedSfixed64) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllTypes_RepeatedSfixed64) + gremlin.SizeSFixed64(s.RepeatedSfixed64[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedFloat) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedFloat) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedFloat {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFloat32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedFloat) + listBytesSize
		} else if len(s.RepeatedFloat) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllTypes_RepeatedFloat) + gremlin.SizeFloat32(s.RepeatedFloat[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedDouble) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedDouble) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedDouble {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFloat64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedDouble) + listBytesSize
		} else if len(s.RepeatedDouble) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllTypes_RepeatedDouble) + gremlin.SizeFloat64(s.RepeatedDouble[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedBool) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedBool) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedBool {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeBool(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedBool) + listBytesSize
		} else if len(s.RepeatedBool) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllTypes_RepeatedBool) + gremlin.SizeBool(s.RepeatedBool[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedString) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedString {
			var listEntrySize int
			listEntrySize = gremlin.SizeString(val)
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedString)
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedBytes) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedBytes {
			var listEntrySize int
			listEntrySize = gremlin.SizeBytes(val)
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedBytes)
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedNestedMessage) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedNestedMessage {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedNestedMessage)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedForeignMessage) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedForeignMessage {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedForeignMessage)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedImportMessage) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedImportMessage {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedImportMessage)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedNestedEnum) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedNestedEnum) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedNestedEnum {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(int32(entry))
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedNestedEnum) + listBytesSize
		} else if len(s.RepeatedNestedEnum) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllTypes_RepeatedNestedEnum) + gremlin.SizeInt32(int32(s.RepeatedNestedEnum[0]))
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedForeignEnum) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedForeignEnum) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedForeignEnum {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(int32(entry))
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedForeignEnum) + listBytesSize
		} else if len(s.RepeatedForeignEnum) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllTypes_RepeatedForeignEnum) + gremlin.SizeInt32(int32(s.RepeatedForeignEnum[0]))
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedImportEnum) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedImportEnum) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedImportEnum {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(int32(entry))
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedImportEnum) + listBytesSize
		} else if len(s.RepeatedImportEnum) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllTypes_RepeatedImportEnum) + gremlin.SizeInt32(int32(s.RepeatedImportEnum[0]))
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedStringPiece) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedStringPiece {
			var listEntrySize int
			listEntrySize = gremlin.SizeString(val)
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedStringPiece)
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedCord) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedCord {
			var listEntrySize int
			listEntrySize = gremlin.SizeString(val)
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedCord)
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedLazyMessage) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedLazyMessage {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestAllTypes_RepeatedLazyMessage)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if s.DefaultInt32 != 41 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_DefaultInt32) + gremlin.SizeInt32(s.DefaultInt32)
		size += entrySize
	}

	if s.DefaultInt64 != 42 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_DefaultInt64) + gremlin.SizeInt64(s.DefaultInt64)
		size += entrySize
	}

	if s.DefaultUint32 != 43 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_DefaultUint32) + gremlin.SizeUint32(s.DefaultUint32)
		size += entrySize
	}

	if s.DefaultUint64 != 44 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_DefaultUint64) + gremlin.SizeUint64(s.DefaultUint64)
		size += entrySize
	}

	if s.DefaultSint32 != -45 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_DefaultSint32) + gremlin.SizeSInt32(s.DefaultSint32)
		size += entrySize
	}

	if s.DefaultSint64 != 46 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_DefaultSint64) + gremlin.SizeSInt64(s.DefaultSint64)
		size += entrySize
	}

	if s.DefaultFixed32 != 47 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_DefaultFixed32) + gremlin.SizeFixed32(s.DefaultFixed32)
		size += entrySize
	}

	if s.DefaultFixed64 != 48 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_DefaultFixed64) + gremlin.SizeFixed64(s.DefaultFixed64)
		size += entrySize
	}

	if s.DefaultSfixed32 != 49 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_DefaultSfixed32) + gremlin.SizeSFixed32(s.DefaultSfixed32)
		size += entrySize
	}

	if s.DefaultSfixed64 != -50 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_DefaultSfixed64) + gremlin.SizeSFixed64(s.DefaultSfixed64)
		size += entrySize
	}

	if s.DefaultFloat != 51.5 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_DefaultFloat) + gremlin.SizeFloat32(s.DefaultFloat)
		size += entrySize
	}

	if s.DefaultDouble != 52e3 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_DefaultDouble) + gremlin.SizeFloat64(s.DefaultDouble)
		size += entrySize
	}

	if s.DefaultBool != true {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_DefaultBool) + gremlin.SizeBool(s.DefaultBool)
		size += entrySize
	}

	if s.DefaultString != "hello" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.DefaultString)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllTypes_DefaultString)
		size += entrySize
	}

	if !bytes.Equal(s.DefaultBytes, []byte("world")) {
		var entrySize = 0
		entrySize = gremlin.SizeBytes(s.DefaultBytes)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllTypes_DefaultBytes)
		size += entrySize
	}

	if s.DefaultNestedEnum != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_DefaultNestedEnum) + gremlin.SizeInt32(int32(s.DefaultNestedEnum))
		size += entrySize
	}

	if s.DefaultForeignEnum != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_DefaultForeignEnum) + gremlin.SizeInt32(int32(s.DefaultForeignEnum))
		size += entrySize
	}

	if s.DefaultImportEnum != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_DefaultImportEnum) + gremlin.SizeInt32(int32(s.DefaultImportEnum))
		size += entrySize
	}

	if s.DefaultStringPiece != "abc" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.DefaultStringPiece)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllTypes_DefaultStringPiece)
		size += entrySize
	}

	if s.DefaultCord != "123" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.DefaultCord)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllTypes_DefaultCord)
		size += entrySize
	}

	if s.OneofUint32 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_OneofUint32) + gremlin.SizeUint32(s.OneofUint32)
		size += entrySize
	}

	if s.OneofNestedMessage != nil {
		var entrySize = 0
		entrySize = s.OneofNestedMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllTypes_OneofNestedMessage)
		
		size += entrySize
	}

	if s.OneofString != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.OneofString)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllTypes_OneofString)
		size += entrySize
	}

	if len(s.OneofBytes) != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeBytes(s.OneofBytes)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllTypes_OneofBytes)
		size += entrySize
	}

	return size
}

const (
	wireTestAllTypes_NestedMessage_Bb gremlin.ProtoWireNumber = 1
)

type TestAllTypes_NestedMessageReader struct {
	buf *gremlin.Reader

	dataBb     int32

	offsetBb   int

	parsedBb   bool
}

func NewTestAllTypes_NestedMessageReader() *TestAllTypes_NestedMessageReader {
	return &TestAllTypes_NestedMessageReader{}
}

func (m *TestAllTypes_NestedMessageReader) GetBb() int32 {
	if m == nil {
		return 0
	}
	return m.readBb()
}

func (m *TestAllTypes_NestedMessageReader) readBb() int32 {
	if m.parsedBb {
		return m.dataBb
	}
	wOffset := m.offsetBb
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataBb = entry
	m.parsedBb = true
	return entry
}

func (m *TestAllTypes_NestedMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestAllTypes_NestedMessage_Bb:
			m.offsetBb = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestAllTypes_NestedMessageReader) ToStruct() *TestAllTypes_NestedMessage {
	if m == nil {
		return nil
	}
	res := &TestAllTypes_NestedMessage{}
	res.Bb = m.GetBb()

	return res
}

func (s *TestAllTypes_NestedMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestAllTypes_NestedMessage struct {
	Bb	int32	`json:"bb,omitempty"`
}

func (s *TestAllTypes_NestedMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestAllTypes_NestedMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Bb != 0 {
		res.AppendInt32(wireTestAllTypes_NestedMessage_Bb, s.Bb)
	}
}

func (s *TestAllTypes_NestedMessage) Copy() *TestAllTypes_NestedMessage {
	if s == nil {
		return nil
	}
	res := &TestAllTypes_NestedMessage{}
	res.Bb = s.Bb

	return res
}

func (s *TestAllTypes_NestedMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Bb != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllTypes_NestedMessage_Bb) + gremlin.SizeInt32(s.Bb)
		size += entrySize
	}

	return size
}

const (
	wireNestedTestAllTypes_Child gremlin.ProtoWireNumber = 1
	wireNestedTestAllTypes_Payload gremlin.ProtoWireNumber = 2
	wireNestedTestAllTypes_RepeatedChild gremlin.ProtoWireNumber = 3
	wireNestedTestAllTypes_LazyChild gremlin.ProtoWireNumber = 4
	wireNestedTestAllTypes_EagerChild gremlin.ProtoWireNumber = 5
)

type NestedTestAllTypesReader struct {
	buf *gremlin.Reader

	dataChild     *NestedTestAllTypesReader
	dataPayload     *TestAllTypesReader
	dataRepeatedChild     []*NestedTestAllTypesReader
	dataLazyChild     *NestedTestAllTypesReader
	dataEagerChild     *TestAllTypesReader

	offsetChild   int
	offsetPayload   int
	offsetRepeatedChild   []int
	offsetLazyChild   int
	offsetEagerChild   int

	parsedChild   bool
	parsedPayload   bool
	parsedRepeatedChild   bool
	parsedLazyChild   bool
	parsedEagerChild   bool
}

func NewNestedTestAllTypesReader() *NestedTestAllTypesReader {
	return &NestedTestAllTypesReader{}
}

func (m *NestedTestAllTypesReader) GetChild() *NestedTestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readChild()
}

func (m *NestedTestAllTypesReader) readChild() *NestedTestAllTypesReader {
	if m.parsedChild {
		return m.dataChild
	}
	wOffset := m.offsetChild
	
	var entry *NestedTestAllTypesReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewNestedTestAllTypesReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataChild = entry
	m.parsedChild = true
	return entry
}

func (m *NestedTestAllTypesReader) GetPayload() *TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readPayload()
}

func (m *NestedTestAllTypesReader) readPayload() *TestAllTypesReader {
	if m.parsedPayload {
		return m.dataPayload
	}
	wOffset := m.offsetPayload
	
	var entry *TestAllTypesReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypesReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataPayload = entry
	m.parsedPayload = true
	return entry
}

func (m *NestedTestAllTypesReader) GetRepeatedChild() []*NestedTestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readRepeatedChild()
}

func (m *NestedTestAllTypesReader) readRepeatedChild() []*NestedTestAllTypesReader {
	if m.parsedRepeatedChild {
		return m.dataRepeatedChild
	}
	wOffset := m.offsetRepeatedChild
	
	var entry []*NestedTestAllTypesReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *NestedTestAllTypesReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewNestedTestAllTypesReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedChild = entry
	m.parsedRepeatedChild = true
	return entry
}

func (m *NestedTestAllTypesReader) GetLazyChild() *NestedTestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readLazyChild()
}

func (m *NestedTestAllTypesReader) readLazyChild() *NestedTestAllTypesReader {
	if m.parsedLazyChild {
		return m.dataLazyChild
	}
	wOffset := m.offsetLazyChild
	
	var entry *NestedTestAllTypesReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewNestedTestAllTypesReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataLazyChild = entry
	m.parsedLazyChild = true
	return entry
}

func (m *NestedTestAllTypesReader) GetEagerChild() *TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readEagerChild()
}

func (m *NestedTestAllTypesReader) readEagerChild() *TestAllTypesReader {
	if m.parsedEagerChild {
		return m.dataEagerChild
	}
	wOffset := m.offsetEagerChild
	
	var entry *TestAllTypesReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypesReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataEagerChild = entry
	m.parsedEagerChild = true
	return entry
}

func (m *NestedTestAllTypesReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireNestedTestAllTypes_Child:
			m.offsetChild = offset
		case wireNestedTestAllTypes_Payload:
			m.offsetPayload = offset
		case wireNestedTestAllTypes_RepeatedChild:
			m.offsetRepeatedChild = append(m.offsetRepeatedChild, offset)
		case wireNestedTestAllTypes_LazyChild:
			m.offsetLazyChild = offset
		case wireNestedTestAllTypes_EagerChild:
			m.offsetEagerChild = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *NestedTestAllTypesReader) ToStruct() *NestedTestAllTypes {
	if m == nil {
		return nil
	}
	res := &NestedTestAllTypes{}

	{
		var data = m.GetChild()
		var structData *NestedTestAllTypes
		if data != nil {
			structData = data.ToStruct()
		}
		res.Child = structData
	}

	{
		var data = m.GetPayload()
		var structData *TestAllTypes
		if data != nil {
			structData = data.ToStruct()
		}
		res.Payload = structData
	}

	{
		var data = m.GetRepeatedChild()
		var structData []*NestedTestAllTypes
		if len(data) > 0 {
			structData = make([]*NestedTestAllTypes, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.RepeatedChild = structData
	}

	{
		var data = m.GetLazyChild()
		var structData *NestedTestAllTypes
		if data != nil {
			structData = data.ToStruct()
		}
		res.LazyChild = structData
	}

	{
		var data = m.GetEagerChild()
		var structData *TestAllTypes
		if data != nil {
			structData = data.ToStruct()
		}
		res.EagerChild = structData
	}

	return res
}

func (s *NestedTestAllTypesReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type NestedTestAllTypes struct {
	Child	*NestedTestAllTypes	`json:"child,omitempty"`
	Payload	*TestAllTypes	`json:"payload,omitempty"`
	RepeatedChild	[]*NestedTestAllTypes	`json:"repeated_child,omitempty"`
	LazyChild	*NestedTestAllTypes	`json:"lazy_child,omitempty"`
	EagerChild	*TestAllTypes	`json:"eager_child,omitempty"`
}

func (s *NestedTestAllTypes) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *NestedTestAllTypes) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Child != nil {
		structSize := s.Child.XXX_PbContentSize()
		res.AppendBytesTag(wireNestedTestAllTypes_Child, structSize)
		s.Child.MarshalTo(res)
	}
	if s.Payload != nil {
		structSize := s.Payload.XXX_PbContentSize()
		res.AppendBytesTag(wireNestedTestAllTypes_Payload, structSize)
		s.Payload.MarshalTo(res)
	}
	if len(s.RepeatedChild) > 0 {
		for _, entry := range s.RepeatedChild {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireNestedTestAllTypes_RepeatedChild, structSize)
			entry.MarshalTo(res)
		}
	}
	if s.LazyChild != nil {
		structSize := s.LazyChild.XXX_PbContentSize()
		res.AppendBytesTag(wireNestedTestAllTypes_LazyChild, structSize)
		s.LazyChild.MarshalTo(res)
	}
	if s.EagerChild != nil {
		structSize := s.EagerChild.XXX_PbContentSize()
		res.AppendBytesTag(wireNestedTestAllTypes_EagerChild, structSize)
		s.EagerChild.MarshalTo(res)
	}
}

func (s *NestedTestAllTypes) Copy() *NestedTestAllTypes {
	if s == nil {
		return nil
	}
	res := &NestedTestAllTypes{}
	if s.Child != nil {
		res.Child = s.Child.Copy()
	}
	if s.Payload != nil {
		res.Payload = s.Payload.Copy()
	}
	res.RepeatedChild = make([]*NestedTestAllTypes, len(s.RepeatedChild))
	for i := range s.RepeatedChild {
		if s.RepeatedChild[i] != nil {
			res.RepeatedChild[i] = s.RepeatedChild[i].Copy()
		}
	}
	if s.LazyChild != nil {
		res.LazyChild = s.LazyChild.Copy()
	}
	if s.EagerChild != nil {
		res.EagerChild = s.EagerChild.Copy()
	}

	return res
}

func (s *NestedTestAllTypes) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Child != nil {
		var entrySize = 0
		entrySize = s.Child.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireNestedTestAllTypes_Child)
		
		size += entrySize
	}

	if s.Payload != nil {
		var entrySize = 0
		entrySize = s.Payload.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireNestedTestAllTypes_Payload)
		
		size += entrySize
	}

	if len(s.RepeatedChild) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedChild {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireNestedTestAllTypes_RepeatedChild)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if s.LazyChild != nil {
		var entrySize = 0
		entrySize = s.LazyChild.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireNestedTestAllTypes_LazyChild)
		
		size += entrySize
	}

	if s.EagerChild != nil {
		var entrySize = 0
		entrySize = s.EagerChild.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireNestedTestAllTypes_EagerChild)
		
		size += entrySize
	}

	return size
}

const (
	wireTestDeprecatedFields_DeprecatedInt32 gremlin.ProtoWireNumber = 1
	wireTestDeprecatedFields_DeprecatedInt32InOneof gremlin.ProtoWireNumber = 2
)

type TestDeprecatedFieldsReader struct {
	buf *gremlin.Reader

	dataDeprecatedInt32     int32
	dataDeprecatedInt32InOneof     int32

	offsetDeprecatedInt32   int
	offsetDeprecatedInt32InOneof   int

	parsedDeprecatedInt32   bool
	parsedDeprecatedInt32InOneof   bool
}

func NewTestDeprecatedFieldsReader() *TestDeprecatedFieldsReader {
	return &TestDeprecatedFieldsReader{}
}

func (m *TestDeprecatedFieldsReader) GetDeprecatedInt32() int32 {
	if m == nil {
		return 0
	}
	return m.readDeprecatedInt32()
}

func (m *TestDeprecatedFieldsReader) readDeprecatedInt32() int32 {
	if m.parsedDeprecatedInt32 {
		return m.dataDeprecatedInt32
	}
	wOffset := m.offsetDeprecatedInt32
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDeprecatedInt32 = entry
	m.parsedDeprecatedInt32 = true
	return entry
}

func (m *TestDeprecatedFieldsReader) GetDeprecatedInt32InOneof() int32 {
	if m == nil {
		return 0
	}
	return m.readDeprecatedInt32InOneof()
}

func (m *TestDeprecatedFieldsReader) readDeprecatedInt32InOneof() int32 {
	if m.parsedDeprecatedInt32InOneof {
		return m.dataDeprecatedInt32InOneof
	}
	wOffset := m.offsetDeprecatedInt32InOneof
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDeprecatedInt32InOneof = entry
	m.parsedDeprecatedInt32InOneof = true
	return entry
}

func (m *TestDeprecatedFieldsReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestDeprecatedFields_DeprecatedInt32:
			m.offsetDeprecatedInt32 = offset
		case wireTestDeprecatedFields_DeprecatedInt32InOneof:
			m.offsetDeprecatedInt32InOneof = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestDeprecatedFieldsReader) ToStruct() *TestDeprecatedFields {
	if m == nil {
		return nil
	}
	res := &TestDeprecatedFields{}
	res.DeprecatedInt32 = m.GetDeprecatedInt32()
	res.DeprecatedInt32InOneof = m.GetDeprecatedInt32InOneof()

	return res
}

func (s *TestDeprecatedFieldsReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestDeprecatedFields struct {
	DeprecatedInt32	int32	`json:"deprecated_int32,omitempty"`
	DeprecatedInt32InOneof	int32	`json:"deprecated_int32_in_oneof,omitempty"`
}

func (s *TestDeprecatedFields) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestDeprecatedFields) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.DeprecatedInt32 != 0 {
		res.AppendInt32(wireTestDeprecatedFields_DeprecatedInt32, s.DeprecatedInt32)
	}
	if s.DeprecatedInt32InOneof != 0 {
		res.AppendInt32(wireTestDeprecatedFields_DeprecatedInt32InOneof, s.DeprecatedInt32InOneof)
	}
}

func (s *TestDeprecatedFields) Copy() *TestDeprecatedFields {
	if s == nil {
		return nil
	}
	res := &TestDeprecatedFields{}
	res.DeprecatedInt32 = s.DeprecatedInt32
	res.DeprecatedInt32InOneof = s.DeprecatedInt32InOneof

	return res
}

func (s *TestDeprecatedFields) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.DeprecatedInt32 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestDeprecatedFields_DeprecatedInt32) + gremlin.SizeInt32(s.DeprecatedInt32)
		size += entrySize
	}

	if s.DeprecatedInt32InOneof != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestDeprecatedFields_DeprecatedInt32InOneof) + gremlin.SizeInt32(s.DeprecatedInt32InOneof)
		size += entrySize
	}

	return size
}

const (
)

type TestDeprecatedMessageReader struct {
	buf *gremlin.Reader



}

func NewTestDeprecatedMessageReader() *TestDeprecatedMessageReader {
	return &TestDeprecatedMessageReader{}
}

func (m *TestDeprecatedMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestDeprecatedMessageReader) ToStruct() *TestDeprecatedMessage {
	if m == nil {
		return nil
	}
	res := &TestDeprecatedMessage{}

	return res
}

func (s *TestDeprecatedMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestDeprecatedMessage struct {
}

func (s *TestDeprecatedMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestDeprecatedMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

}

func (s *TestDeprecatedMessage) Copy() *TestDeprecatedMessage {
	if s == nil {
		return nil
	}
	res := &TestDeprecatedMessage{}

	return res
}

func (s *TestDeprecatedMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	return size
}

const (
	wireForeignMessage_C gremlin.ProtoWireNumber = 1
	wireForeignMessage_D gremlin.ProtoWireNumber = 2
)

type ForeignMessageReader struct {
	buf *gremlin.Reader

	dataC     int32
	dataD     int32

	offsetC   int
	offsetD   int

	parsedC   bool
	parsedD   bool
}

func NewForeignMessageReader() *ForeignMessageReader {
	return &ForeignMessageReader{}
}

func (m *ForeignMessageReader) GetC() int32 {
	if m == nil {
		return 0
	}
	return m.readC()
}

func (m *ForeignMessageReader) readC() int32 {
	if m.parsedC {
		return m.dataC
	}
	wOffset := m.offsetC
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataC = entry
	m.parsedC = true
	return entry
}

func (m *ForeignMessageReader) GetD() int32 {
	if m == nil {
		return 0
	}
	return m.readD()
}

func (m *ForeignMessageReader) readD() int32 {
	if m.parsedD {
		return m.dataD
	}
	wOffset := m.offsetD
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataD = entry
	m.parsedD = true
	return entry
}

func (m *ForeignMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireForeignMessage_C:
			m.offsetC = offset
		case wireForeignMessage_D:
			m.offsetD = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *ForeignMessageReader) ToStruct() *ForeignMessage {
	if m == nil {
		return nil
	}
	res := &ForeignMessage{}
	res.C = m.GetC()
	res.D = m.GetD()

	return res
}

func (s *ForeignMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type ForeignMessage struct {
	C	int32	`json:"c,omitempty"`
	D	int32	`json:"d,omitempty"`
}

func (s *ForeignMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *ForeignMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.C != 0 {
		res.AppendInt32(wireForeignMessage_C, s.C)
	}
	if s.D != 0 {
		res.AppendInt32(wireForeignMessage_D, s.D)
	}
}

func (s *ForeignMessage) Copy() *ForeignMessage {
	if s == nil {
		return nil
	}
	res := &ForeignMessage{}
	res.C = s.C
	res.D = s.D

	return res
}

func (s *ForeignMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.C != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireForeignMessage_C) + gremlin.SizeInt32(s.C)
		size += entrySize
	}

	if s.D != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireForeignMessage_D) + gremlin.SizeInt32(s.D)
		size += entrySize
	}

	return size
}

const (
)

type TestReservedFieldsReader struct {
	buf *gremlin.Reader



}

func NewTestReservedFieldsReader() *TestReservedFieldsReader {
	return &TestReservedFieldsReader{}
}

func (m *TestReservedFieldsReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestReservedFieldsReader) ToStruct() *TestReservedFields {
	if m == nil {
		return nil
	}
	res := &TestReservedFields{}

	return res
}

func (s *TestReservedFieldsReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestReservedFields struct {
}

func (s *TestReservedFields) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestReservedFields) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

}

func (s *TestReservedFields) Copy() *TestReservedFields {
	if s == nil {
		return nil
	}
	res := &TestReservedFields{}

	return res
}

func (s *TestReservedFields) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	return size
}

const (
	wireTestAllExtensions_OptionalInt32Extension gremlin.ProtoWireNumber = 1
	wireTestAllExtensions_OptionalInt64Extension gremlin.ProtoWireNumber = 2
	wireTestAllExtensions_OptionalUint32Extension gremlin.ProtoWireNumber = 3
	wireTestAllExtensions_OptionalUint64Extension gremlin.ProtoWireNumber = 4
	wireTestAllExtensions_OptionalSint32Extension gremlin.ProtoWireNumber = 5
	wireTestAllExtensions_OptionalSint64Extension gremlin.ProtoWireNumber = 6
	wireTestAllExtensions_OptionalFixed32Extension gremlin.ProtoWireNumber = 7
	wireTestAllExtensions_OptionalFixed64Extension gremlin.ProtoWireNumber = 8
	wireTestAllExtensions_OptionalSfixed32Extension gremlin.ProtoWireNumber = 9
	wireTestAllExtensions_OptionalSfixed64Extension gremlin.ProtoWireNumber = 10
	wireTestAllExtensions_OptionalFloatExtension gremlin.ProtoWireNumber = 11
	wireTestAllExtensions_OptionalDoubleExtension gremlin.ProtoWireNumber = 12
	wireTestAllExtensions_OptionalBoolExtension gremlin.ProtoWireNumber = 13
	wireTestAllExtensions_OptionalStringExtension gremlin.ProtoWireNumber = 14
	wireTestAllExtensions_OptionalBytesExtension gremlin.ProtoWireNumber = 15
	wireTestAllExtensions_OptionalNestedMessageExtension gremlin.ProtoWireNumber = 18
	wireTestAllExtensions_OptionalForeignMessageExtension gremlin.ProtoWireNumber = 19
	wireTestAllExtensions_OptionalImportMessageExtension gremlin.ProtoWireNumber = 20
	wireTestAllExtensions_OptionalNestedEnumExtension gremlin.ProtoWireNumber = 21
	wireTestAllExtensions_OptionalForeignEnumExtension gremlin.ProtoWireNumber = 22
	wireTestAllExtensions_OptionalImportEnumExtension gremlin.ProtoWireNumber = 23
	wireTestAllExtensions_OptionalStringPieceExtension gremlin.ProtoWireNumber = 24
	wireTestAllExtensions_OptionalCordExtension gremlin.ProtoWireNumber = 25
	wireTestAllExtensions_OptionalPublicImportMessageExtension gremlin.ProtoWireNumber = 26
	wireTestAllExtensions_OptionalLazyMessageExtension gremlin.ProtoWireNumber = 27
	wireTestAllExtensions_OptionalUnverifiedLazyMessageExtension gremlin.ProtoWireNumber = 28
	wireTestAllExtensions_RepeatedInt32Extension gremlin.ProtoWireNumber = 31
	wireTestAllExtensions_RepeatedInt64Extension gremlin.ProtoWireNumber = 32
	wireTestAllExtensions_RepeatedUint32Extension gremlin.ProtoWireNumber = 33
	wireTestAllExtensions_RepeatedUint64Extension gremlin.ProtoWireNumber = 34
	wireTestAllExtensions_RepeatedSint32Extension gremlin.ProtoWireNumber = 35
	wireTestAllExtensions_RepeatedSint64Extension gremlin.ProtoWireNumber = 36
	wireTestAllExtensions_RepeatedFixed32Extension gremlin.ProtoWireNumber = 37
	wireTestAllExtensions_RepeatedFixed64Extension gremlin.ProtoWireNumber = 38
	wireTestAllExtensions_RepeatedSfixed32Extension gremlin.ProtoWireNumber = 39
	wireTestAllExtensions_RepeatedSfixed64Extension gremlin.ProtoWireNumber = 40
	wireTestAllExtensions_RepeatedFloatExtension gremlin.ProtoWireNumber = 41
	wireTestAllExtensions_RepeatedDoubleExtension gremlin.ProtoWireNumber = 42
	wireTestAllExtensions_RepeatedBoolExtension gremlin.ProtoWireNumber = 43
	wireTestAllExtensions_RepeatedStringExtension gremlin.ProtoWireNumber = 44
	wireTestAllExtensions_RepeatedBytesExtension gremlin.ProtoWireNumber = 45
	wireTestAllExtensions_RepeatedNestedMessageExtension gremlin.ProtoWireNumber = 48
	wireTestAllExtensions_RepeatedForeignMessageExtension gremlin.ProtoWireNumber = 49
	wireTestAllExtensions_RepeatedImportMessageExtension gremlin.ProtoWireNumber = 50
	wireTestAllExtensions_RepeatedNestedEnumExtension gremlin.ProtoWireNumber = 51
	wireTestAllExtensions_RepeatedForeignEnumExtension gremlin.ProtoWireNumber = 52
	wireTestAllExtensions_RepeatedImportEnumExtension gremlin.ProtoWireNumber = 53
	wireTestAllExtensions_RepeatedStringPieceExtension gremlin.ProtoWireNumber = 54
	wireTestAllExtensions_RepeatedCordExtension gremlin.ProtoWireNumber = 55
	wireTestAllExtensions_RepeatedLazyMessageExtension gremlin.ProtoWireNumber = 57
	wireTestAllExtensions_DefaultInt32Extension gremlin.ProtoWireNumber = 61
	wireTestAllExtensions_DefaultInt64Extension gremlin.ProtoWireNumber = 62
	wireTestAllExtensions_DefaultUint32Extension gremlin.ProtoWireNumber = 63
	wireTestAllExtensions_DefaultUint64Extension gremlin.ProtoWireNumber = 64
	wireTestAllExtensions_DefaultSint32Extension gremlin.ProtoWireNumber = 65
	wireTestAllExtensions_DefaultSint64Extension gremlin.ProtoWireNumber = 66
	wireTestAllExtensions_DefaultFixed32Extension gremlin.ProtoWireNumber = 67
	wireTestAllExtensions_DefaultFixed64Extension gremlin.ProtoWireNumber = 68
	wireTestAllExtensions_DefaultSfixed32Extension gremlin.ProtoWireNumber = 69
	wireTestAllExtensions_DefaultSfixed64Extension gremlin.ProtoWireNumber = 70
	wireTestAllExtensions_DefaultFloatExtension gremlin.ProtoWireNumber = 71
	wireTestAllExtensions_DefaultDoubleExtension gremlin.ProtoWireNumber = 72
	wireTestAllExtensions_DefaultBoolExtension gremlin.ProtoWireNumber = 73
	wireTestAllExtensions_DefaultStringExtension gremlin.ProtoWireNumber = 74
	wireTestAllExtensions_DefaultBytesExtension gremlin.ProtoWireNumber = 75
	wireTestAllExtensions_DefaultNestedEnumExtension gremlin.ProtoWireNumber = 81
	wireTestAllExtensions_DefaultForeignEnumExtension gremlin.ProtoWireNumber = 82
	wireTestAllExtensions_DefaultImportEnumExtension gremlin.ProtoWireNumber = 83
	wireTestAllExtensions_DefaultStringPieceExtension gremlin.ProtoWireNumber = 84
	wireTestAllExtensions_DefaultCordExtension gremlin.ProtoWireNumber = 85
	wireTestAllExtensions_OneofUint32Extension gremlin.ProtoWireNumber = 111
	wireTestAllExtensions_OneofNestedMessageExtension gremlin.ProtoWireNumber = 112
	wireTestAllExtensions_OneofStringExtension gremlin.ProtoWireNumber = 113
	wireTestAllExtensions_OneofBytesExtension gremlin.ProtoWireNumber = 114
)

type TestAllExtensionsReader struct {
	buf *gremlin.Reader

	dataOptionalInt32Extension     int32
	dataOptionalInt64Extension     int64
	dataOptionalUint32Extension     uint32
	dataOptionalUint64Extension     uint64
	dataOptionalSint32Extension     int32
	dataOptionalSint64Extension     int64
	dataOptionalFixed32Extension     uint32
	dataOptionalFixed64Extension     uint64
	dataOptionalSfixed32Extension     int32
	dataOptionalSfixed64Extension     int64
	dataOptionalFloatExtension     float32
	dataOptionalDoubleExtension     float64
	dataOptionalBoolExtension     bool
	dataOptionalStringExtension     string
	dataOptionalBytesExtension     []byte
	dataOptionalNestedMessageExtension     *TestAllTypes_NestedMessageReader
	dataOptionalForeignMessageExtension     *ForeignMessageReader
	dataOptionalImportMessageExtension     *protobuf_unittest_import.ImportMessageReader
	dataOptionalNestedEnumExtension     TestAllTypes_NestedEnum
	dataOptionalForeignEnumExtension     ForeignEnum
	dataOptionalImportEnumExtension     protobuf_unittest_import.ImportEnum
	dataOptionalStringPieceExtension     string
	dataOptionalCordExtension     string
	dataOptionalPublicImportMessageExtension     *protobuf_unittest_import.PublicImportMessageReader
	dataOptionalLazyMessageExtension     *TestAllTypes_NestedMessageReader
	dataOptionalUnverifiedLazyMessageExtension     *TestAllTypes_NestedMessageReader
	dataRepeatedInt32Extension     []int32
	dataRepeatedInt64Extension     []int64
	dataRepeatedUint32Extension     []uint32
	dataRepeatedUint64Extension     []uint64
	dataRepeatedSint32Extension     []int32
	dataRepeatedSint64Extension     []int64
	dataRepeatedFixed32Extension     []uint32
	dataRepeatedFixed64Extension     []uint64
	dataRepeatedSfixed32Extension     []int32
	dataRepeatedSfixed64Extension     []int64
	dataRepeatedFloatExtension     []float32
	dataRepeatedDoubleExtension     []float64
	dataRepeatedBoolExtension     []bool
	dataRepeatedStringExtension     []string
	dataRepeatedBytesExtension     [][]byte
	dataRepeatedNestedMessageExtension     []*TestAllTypes_NestedMessageReader
	dataRepeatedForeignMessageExtension     []*ForeignMessageReader
	dataRepeatedImportMessageExtension     []*protobuf_unittest_import.ImportMessageReader
	dataRepeatedNestedEnumExtension     []TestAllTypes_NestedEnum
	dataRepeatedForeignEnumExtension     []ForeignEnum
	dataRepeatedImportEnumExtension     []protobuf_unittest_import.ImportEnum
	dataRepeatedStringPieceExtension     []string
	dataRepeatedCordExtension     []string
	dataRepeatedLazyMessageExtension     []*TestAllTypes_NestedMessageReader
	dataDefaultInt32Extension     int32
	dataDefaultInt64Extension     int64
	dataDefaultUint32Extension     uint32
	dataDefaultUint64Extension     uint64
	dataDefaultSint32Extension     int32
	dataDefaultSint64Extension     int64
	dataDefaultFixed32Extension     uint32
	dataDefaultFixed64Extension     uint64
	dataDefaultSfixed32Extension     int32
	dataDefaultSfixed64Extension     int64
	dataDefaultFloatExtension     float32
	dataDefaultDoubleExtension     float64
	dataDefaultBoolExtension     bool
	dataDefaultStringExtension     string
	dataDefaultBytesExtension     []byte
	dataDefaultNestedEnumExtension     TestAllTypes_NestedEnum
	dataDefaultForeignEnumExtension     ForeignEnum
	dataDefaultImportEnumExtension     protobuf_unittest_import.ImportEnum
	dataDefaultStringPieceExtension     string
	dataDefaultCordExtension     string
	dataOneofUint32Extension     uint32
	dataOneofNestedMessageExtension     *TestAllTypes_NestedMessageReader
	dataOneofStringExtension     string
	dataOneofBytesExtension     []byte

	offsetOptionalInt32Extension   int
	offsetOptionalInt64Extension   int
	offsetOptionalUint32Extension   int
	offsetOptionalUint64Extension   int
	offsetOptionalSint32Extension   int
	offsetOptionalSint64Extension   int
	offsetOptionalFixed32Extension   int
	offsetOptionalFixed64Extension   int
	offsetOptionalSfixed32Extension   int
	offsetOptionalSfixed64Extension   int
	offsetOptionalFloatExtension   int
	offsetOptionalDoubleExtension   int
	offsetOptionalBoolExtension   int
	offsetOptionalStringExtension   int
	offsetOptionalBytesExtension   int
	offsetOptionalNestedMessageExtension   int
	offsetOptionalForeignMessageExtension   int
	offsetOptionalImportMessageExtension   int
	offsetOptionalNestedEnumExtension   int
	offsetOptionalForeignEnumExtension   int
	offsetOptionalImportEnumExtension   int
	offsetOptionalStringPieceExtension   int
	offsetOptionalCordExtension   int
	offsetOptionalPublicImportMessageExtension   int
	offsetOptionalLazyMessageExtension   int
	offsetOptionalUnverifiedLazyMessageExtension   int
	offsetRepeatedInt32Extension   []int
	wireTypeRepeatedInt32Extension []gremlin.ProtoWireType
	offsetRepeatedInt64Extension   []int
	wireTypeRepeatedInt64Extension []gremlin.ProtoWireType
	offsetRepeatedUint32Extension   []int
	wireTypeRepeatedUint32Extension []gremlin.ProtoWireType
	offsetRepeatedUint64Extension   []int
	wireTypeRepeatedUint64Extension []gremlin.ProtoWireType
	offsetRepeatedSint32Extension   []int
	wireTypeRepeatedSint32Extension []gremlin.ProtoWireType
	offsetRepeatedSint64Extension   []int
	wireTypeRepeatedSint64Extension []gremlin.ProtoWireType
	offsetRepeatedFixed32Extension   []int
	wireTypeRepeatedFixed32Extension []gremlin.ProtoWireType
	offsetRepeatedFixed64Extension   []int
	wireTypeRepeatedFixed64Extension []gremlin.ProtoWireType
	offsetRepeatedSfixed32Extension   []int
	wireTypeRepeatedSfixed32Extension []gremlin.ProtoWireType
	offsetRepeatedSfixed64Extension   []int
	wireTypeRepeatedSfixed64Extension []gremlin.ProtoWireType
	offsetRepeatedFloatExtension   []int
	wireTypeRepeatedFloatExtension []gremlin.ProtoWireType
	offsetRepeatedDoubleExtension   []int
	wireTypeRepeatedDoubleExtension []gremlin.ProtoWireType
	offsetRepeatedBoolExtension   []int
	wireTypeRepeatedBoolExtension []gremlin.ProtoWireType
	offsetRepeatedStringExtension   []int
	offsetRepeatedBytesExtension   []int
	offsetRepeatedNestedMessageExtension   []int
	offsetRepeatedForeignMessageExtension   []int
	offsetRepeatedImportMessageExtension   []int
	offsetRepeatedNestedEnumExtension   []int
	wireTypeRepeatedNestedEnumExtension []gremlin.ProtoWireType
	offsetRepeatedForeignEnumExtension   []int
	wireTypeRepeatedForeignEnumExtension []gremlin.ProtoWireType
	offsetRepeatedImportEnumExtension   []int
	wireTypeRepeatedImportEnumExtension []gremlin.ProtoWireType
	offsetRepeatedStringPieceExtension   []int
	offsetRepeatedCordExtension   []int
	offsetRepeatedLazyMessageExtension   []int
	offsetDefaultInt32Extension   int
	offsetDefaultInt64Extension   int
	offsetDefaultUint32Extension   int
	offsetDefaultUint64Extension   int
	offsetDefaultSint32Extension   int
	offsetDefaultSint64Extension   int
	offsetDefaultFixed32Extension   int
	offsetDefaultFixed64Extension   int
	offsetDefaultSfixed32Extension   int
	offsetDefaultSfixed64Extension   int
	offsetDefaultFloatExtension   int
	offsetDefaultDoubleExtension   int
	offsetDefaultBoolExtension   int
	offsetDefaultStringExtension   int
	offsetDefaultBytesExtension   int
	offsetDefaultNestedEnumExtension   int
	offsetDefaultForeignEnumExtension   int
	offsetDefaultImportEnumExtension   int
	offsetDefaultStringPieceExtension   int
	offsetDefaultCordExtension   int
	offsetOneofUint32Extension   int
	offsetOneofNestedMessageExtension   int
	offsetOneofStringExtension   int
	offsetOneofBytesExtension   int

	parsedOptionalInt32Extension   bool
	parsedOptionalInt64Extension   bool
	parsedOptionalUint32Extension   bool
	parsedOptionalUint64Extension   bool
	parsedOptionalSint32Extension   bool
	parsedOptionalSint64Extension   bool
	parsedOptionalFixed32Extension   bool
	parsedOptionalFixed64Extension   bool
	parsedOptionalSfixed32Extension   bool
	parsedOptionalSfixed64Extension   bool
	parsedOptionalFloatExtension   bool
	parsedOptionalDoubleExtension   bool
	parsedOptionalBoolExtension   bool
	parsedOptionalStringExtension   bool
	parsedOptionalBytesExtension   bool
	parsedOptionalNestedMessageExtension   bool
	parsedOptionalForeignMessageExtension   bool
	parsedOptionalImportMessageExtension   bool
	parsedOptionalNestedEnumExtension   bool
	parsedOptionalForeignEnumExtension   bool
	parsedOptionalImportEnumExtension   bool
	parsedOptionalStringPieceExtension   bool
	parsedOptionalCordExtension   bool
	parsedOptionalPublicImportMessageExtension   bool
	parsedOptionalLazyMessageExtension   bool
	parsedOptionalUnverifiedLazyMessageExtension   bool
	parsedRepeatedInt32Extension   bool
	parsedRepeatedInt64Extension   bool
	parsedRepeatedUint32Extension   bool
	parsedRepeatedUint64Extension   bool
	parsedRepeatedSint32Extension   bool
	parsedRepeatedSint64Extension   bool
	parsedRepeatedFixed32Extension   bool
	parsedRepeatedFixed64Extension   bool
	parsedRepeatedSfixed32Extension   bool
	parsedRepeatedSfixed64Extension   bool
	parsedRepeatedFloatExtension   bool
	parsedRepeatedDoubleExtension   bool
	parsedRepeatedBoolExtension   bool
	parsedRepeatedStringExtension   bool
	parsedRepeatedBytesExtension   bool
	parsedRepeatedNestedMessageExtension   bool
	parsedRepeatedForeignMessageExtension   bool
	parsedRepeatedImportMessageExtension   bool
	parsedRepeatedNestedEnumExtension   bool
	parsedRepeatedForeignEnumExtension   bool
	parsedRepeatedImportEnumExtension   bool
	parsedRepeatedStringPieceExtension   bool
	parsedRepeatedCordExtension   bool
	parsedRepeatedLazyMessageExtension   bool
	parsedDefaultInt32Extension   bool
	parsedDefaultInt64Extension   bool
	parsedDefaultUint32Extension   bool
	parsedDefaultUint64Extension   bool
	parsedDefaultSint32Extension   bool
	parsedDefaultSint64Extension   bool
	parsedDefaultFixed32Extension   bool
	parsedDefaultFixed64Extension   bool
	parsedDefaultSfixed32Extension   bool
	parsedDefaultSfixed64Extension   bool
	parsedDefaultFloatExtension   bool
	parsedDefaultDoubleExtension   bool
	parsedDefaultBoolExtension   bool
	parsedDefaultStringExtension   bool
	parsedDefaultBytesExtension   bool
	parsedDefaultNestedEnumExtension   bool
	parsedDefaultForeignEnumExtension   bool
	parsedDefaultImportEnumExtension   bool
	parsedDefaultStringPieceExtension   bool
	parsedDefaultCordExtension   bool
	parsedOneofUint32Extension   bool
	parsedOneofNestedMessageExtension   bool
	parsedOneofStringExtension   bool
	parsedOneofBytesExtension   bool
}

func NewTestAllExtensionsReader() *TestAllExtensionsReader {
	return &TestAllExtensionsReader{}
}

func (m *TestAllExtensionsReader) GetOptionalInt32Extension() int32 {
	if m == nil {
		return 0
	}
	return m.readOptionalInt32Extension()
}

func (m *TestAllExtensionsReader) readOptionalInt32Extension() int32 {
	if m.parsedOptionalInt32Extension {
		return m.dataOptionalInt32Extension
	}
	wOffset := m.offsetOptionalInt32Extension
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataOptionalInt32Extension = entry
	m.parsedOptionalInt32Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalInt64Extension() int64 {
	if m == nil {
		return 0
	}
	return m.readOptionalInt64Extension()
}

func (m *TestAllExtensionsReader) readOptionalInt64Extension() int64 {
	if m.parsedOptionalInt64Extension {
		return m.dataOptionalInt64Extension
	}
	wOffset := m.offsetOptionalInt64Extension
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadInt64(wOffset)
	}
	
	m.dataOptionalInt64Extension = entry
	m.parsedOptionalInt64Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalUint32Extension() uint32 {
	if m == nil {
		return 0
	}
	return m.readOptionalUint32Extension()
}

func (m *TestAllExtensionsReader) readOptionalUint32Extension() uint32 {
	if m.parsedOptionalUint32Extension {
		return m.dataOptionalUint32Extension
	}
	wOffset := m.offsetOptionalUint32Extension
	
	var entry uint32
	if wOffset > 0 {
		entry = m.buf.ReadUint32(wOffset)
	}
	
	m.dataOptionalUint32Extension = entry
	m.parsedOptionalUint32Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalUint64Extension() uint64 {
	if m == nil {
		return 0
	}
	return m.readOptionalUint64Extension()
}

func (m *TestAllExtensionsReader) readOptionalUint64Extension() uint64 {
	if m.parsedOptionalUint64Extension {
		return m.dataOptionalUint64Extension
	}
	wOffset := m.offsetOptionalUint64Extension
	
	var entry uint64
	if wOffset > 0 {
		entry = m.buf.ReadUint64(wOffset)
	}
	
	m.dataOptionalUint64Extension = entry
	m.parsedOptionalUint64Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalSint32Extension() int32 {
	if m == nil {
		return 0
	}
	return m.readOptionalSint32Extension()
}

func (m *TestAllExtensionsReader) readOptionalSint32Extension() int32 {
	if m.parsedOptionalSint32Extension {
		return m.dataOptionalSint32Extension
	}
	wOffset := m.offsetOptionalSint32Extension
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadSInt32(wOffset)
	}
	
	m.dataOptionalSint32Extension = entry
	m.parsedOptionalSint32Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalSint64Extension() int64 {
	if m == nil {
		return 0
	}
	return m.readOptionalSint64Extension()
}

func (m *TestAllExtensionsReader) readOptionalSint64Extension() int64 {
	if m.parsedOptionalSint64Extension {
		return m.dataOptionalSint64Extension
	}
	wOffset := m.offsetOptionalSint64Extension
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadSInt64(wOffset)
	}
	
	m.dataOptionalSint64Extension = entry
	m.parsedOptionalSint64Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalFixed32Extension() uint32 {
	if m == nil {
		return 0
	}
	return m.readOptionalFixed32Extension()
}

func (m *TestAllExtensionsReader) readOptionalFixed32Extension() uint32 {
	if m.parsedOptionalFixed32Extension {
		return m.dataOptionalFixed32Extension
	}
	wOffset := m.offsetOptionalFixed32Extension
	
	var entry uint32
	if wOffset > 0 {
		entry = m.buf.ReadFixed32(wOffset)
	}
	
	m.dataOptionalFixed32Extension = entry
	m.parsedOptionalFixed32Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalFixed64Extension() uint64 {
	if m == nil {
		return 0
	}
	return m.readOptionalFixed64Extension()
}

func (m *TestAllExtensionsReader) readOptionalFixed64Extension() uint64 {
	if m.parsedOptionalFixed64Extension {
		return m.dataOptionalFixed64Extension
	}
	wOffset := m.offsetOptionalFixed64Extension
	
	var entry uint64
	if wOffset > 0 {
		entry = m.buf.ReadFixed64(wOffset)
	}
	
	m.dataOptionalFixed64Extension = entry
	m.parsedOptionalFixed64Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalSfixed32Extension() int32 {
	if m == nil {
		return 0
	}
	return m.readOptionalSfixed32Extension()
}

func (m *TestAllExtensionsReader) readOptionalSfixed32Extension() int32 {
	if m.parsedOptionalSfixed32Extension {
		return m.dataOptionalSfixed32Extension
	}
	wOffset := m.offsetOptionalSfixed32Extension
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadSFixed32(wOffset)
	}
	
	m.dataOptionalSfixed32Extension = entry
	m.parsedOptionalSfixed32Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalSfixed64Extension() int64 {
	if m == nil {
		return 0
	}
	return m.readOptionalSfixed64Extension()
}

func (m *TestAllExtensionsReader) readOptionalSfixed64Extension() int64 {
	if m.parsedOptionalSfixed64Extension {
		return m.dataOptionalSfixed64Extension
	}
	wOffset := m.offsetOptionalSfixed64Extension
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadSFixed64(wOffset)
	}
	
	m.dataOptionalSfixed64Extension = entry
	m.parsedOptionalSfixed64Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalFloatExtension() float32 {
	if m == nil {
		return 0
	}
	return m.readOptionalFloatExtension()
}

func (m *TestAllExtensionsReader) readOptionalFloatExtension() float32 {
	if m.parsedOptionalFloatExtension {
		return m.dataOptionalFloatExtension
	}
	wOffset := m.offsetOptionalFloatExtension
	
	var entry float32
	if wOffset > 0 {
		entry = m.buf.ReadFloat32(wOffset)
	}
	
	m.dataOptionalFloatExtension = entry
	m.parsedOptionalFloatExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalDoubleExtension() float64 {
	if m == nil {
		return 0
	}
	return m.readOptionalDoubleExtension()
}

func (m *TestAllExtensionsReader) readOptionalDoubleExtension() float64 {
	if m.parsedOptionalDoubleExtension {
		return m.dataOptionalDoubleExtension
	}
	wOffset := m.offsetOptionalDoubleExtension
	
	var entry float64
	if wOffset > 0 {
		entry = m.buf.ReadFloat64(wOffset)
	}
	
	m.dataOptionalDoubleExtension = entry
	m.parsedOptionalDoubleExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalBoolExtension() bool {
	if m == nil {
		return false
	}
	return m.readOptionalBoolExtension()
}

func (m *TestAllExtensionsReader) readOptionalBoolExtension() bool {
	if m.parsedOptionalBoolExtension {
		return m.dataOptionalBoolExtension
	}
	wOffset := m.offsetOptionalBoolExtension
	
	var entry bool
	if wOffset > 0 {
		entry = m.buf.ReadBool(wOffset)
	}
	
	m.dataOptionalBoolExtension = entry
	m.parsedOptionalBoolExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalStringExtension() string {
	if m == nil {
		return ""
	}
	return m.readOptionalStringExtension()
}

func (m *TestAllExtensionsReader) readOptionalStringExtension() string {
	if m.parsedOptionalStringExtension {
		return m.dataOptionalStringExtension
	}
	wOffset := m.offsetOptionalStringExtension
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataOptionalStringExtension = entry
	m.parsedOptionalStringExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalBytesExtension() []byte {
	if m == nil {
		return nil
	}
	return m.readOptionalBytesExtension()
}

func (m *TestAllExtensionsReader) readOptionalBytesExtension() []byte {
	if m.parsedOptionalBytesExtension {
		return m.dataOptionalBytesExtension
	}
	wOffset := m.offsetOptionalBytesExtension
	
	var entry []byte
	if wOffset > 0 {
		entry = m.buf.ReadBytes(wOffset)
	}
	
	m.dataOptionalBytesExtension = entry
	m.parsedOptionalBytesExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalNestedMessageExtension() *TestAllTypes_NestedMessageReader {
	if m == nil {
		return nil
	}
	return m.readOptionalNestedMessageExtension()
}

func (m *TestAllExtensionsReader) readOptionalNestedMessageExtension() *TestAllTypes_NestedMessageReader {
	if m.parsedOptionalNestedMessageExtension {
		return m.dataOptionalNestedMessageExtension
	}
	wOffset := m.offsetOptionalNestedMessageExtension
	
	var entry *TestAllTypes_NestedMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypes_NestedMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalNestedMessageExtension = entry
	m.parsedOptionalNestedMessageExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalForeignMessageExtension() *ForeignMessageReader {
	if m == nil {
		return nil
	}
	return m.readOptionalForeignMessageExtension()
}

func (m *TestAllExtensionsReader) readOptionalForeignMessageExtension() *ForeignMessageReader {
	if m.parsedOptionalForeignMessageExtension {
		return m.dataOptionalForeignMessageExtension
	}
	wOffset := m.offsetOptionalForeignMessageExtension
	
	var entry *ForeignMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewForeignMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalForeignMessageExtension = entry
	m.parsedOptionalForeignMessageExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalImportMessageExtension() *protobuf_unittest_import.ImportMessageReader {
	if m == nil {
		return nil
	}
	return m.readOptionalImportMessageExtension()
}

func (m *TestAllExtensionsReader) readOptionalImportMessageExtension() *protobuf_unittest_import.ImportMessageReader {
	if m.parsedOptionalImportMessageExtension {
		return m.dataOptionalImportMessageExtension
	}
	wOffset := m.offsetOptionalImportMessageExtension
	
	var entry *protobuf_unittest_import.ImportMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = protobuf_unittest_import.NewImportMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalImportMessageExtension = entry
	m.parsedOptionalImportMessageExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalNestedEnumExtension() TestAllTypes_NestedEnum {
	if m == nil {
		return 0
	}
	return m.readOptionalNestedEnumExtension()
}

func (m *TestAllExtensionsReader) readOptionalNestedEnumExtension() TestAllTypes_NestedEnum {
	if m.parsedOptionalNestedEnumExtension {
		return m.dataOptionalNestedEnumExtension
	}
	wOffset := m.offsetOptionalNestedEnumExtension
	
	var entry TestAllTypes_NestedEnum
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = TestAllTypes_NestedEnum(rawEntry)
	} else {
		entry = 0
	}
	
	m.dataOptionalNestedEnumExtension = entry
	m.parsedOptionalNestedEnumExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalForeignEnumExtension() ForeignEnum {
	if m == nil {
		return 0
	}
	return m.readOptionalForeignEnumExtension()
}

func (m *TestAllExtensionsReader) readOptionalForeignEnumExtension() ForeignEnum {
	if m.parsedOptionalForeignEnumExtension {
		return m.dataOptionalForeignEnumExtension
	}
	wOffset := m.offsetOptionalForeignEnumExtension
	
	var entry ForeignEnum
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = ForeignEnum(rawEntry)
	} else {
		entry = 0
	}
	
	m.dataOptionalForeignEnumExtension = entry
	m.parsedOptionalForeignEnumExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalImportEnumExtension() protobuf_unittest_import.ImportEnum {
	if m == nil {
		return 0
	}
	return m.readOptionalImportEnumExtension()
}

func (m *TestAllExtensionsReader) readOptionalImportEnumExtension() protobuf_unittest_import.ImportEnum {
	if m.parsedOptionalImportEnumExtension {
		return m.dataOptionalImportEnumExtension
	}
	wOffset := m.offsetOptionalImportEnumExtension
	
	var entry protobuf_unittest_import.ImportEnum
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = protobuf_unittest_import.ImportEnum(rawEntry)
	} else {
		entry = 0
	}
	
	m.dataOptionalImportEnumExtension = entry
	m.parsedOptionalImportEnumExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalStringPieceExtension() string {
	if m == nil {
		return ""
	}
	return m.readOptionalStringPieceExtension()
}

func (m *TestAllExtensionsReader) readOptionalStringPieceExtension() string {
	if m.parsedOptionalStringPieceExtension {
		return m.dataOptionalStringPieceExtension
	}
	wOffset := m.offsetOptionalStringPieceExtension
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataOptionalStringPieceExtension = entry
	m.parsedOptionalStringPieceExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalCordExtension() string {
	if m == nil {
		return ""
	}
	return m.readOptionalCordExtension()
}

func (m *TestAllExtensionsReader) readOptionalCordExtension() string {
	if m.parsedOptionalCordExtension {
		return m.dataOptionalCordExtension
	}
	wOffset := m.offsetOptionalCordExtension
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataOptionalCordExtension = entry
	m.parsedOptionalCordExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalPublicImportMessageExtension() *protobuf_unittest_import.PublicImportMessageReader {
	if m == nil {
		return nil
	}
	return m.readOptionalPublicImportMessageExtension()
}

func (m *TestAllExtensionsReader) readOptionalPublicImportMessageExtension() *protobuf_unittest_import.PublicImportMessageReader {
	if m.parsedOptionalPublicImportMessageExtension {
		return m.dataOptionalPublicImportMessageExtension
	}
	wOffset := m.offsetOptionalPublicImportMessageExtension
	
	var entry *protobuf_unittest_import.PublicImportMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = protobuf_unittest_import.NewPublicImportMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalPublicImportMessageExtension = entry
	m.parsedOptionalPublicImportMessageExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalLazyMessageExtension() *TestAllTypes_NestedMessageReader {
	if m == nil {
		return nil
	}
	return m.readOptionalLazyMessageExtension()
}

func (m *TestAllExtensionsReader) readOptionalLazyMessageExtension() *TestAllTypes_NestedMessageReader {
	if m.parsedOptionalLazyMessageExtension {
		return m.dataOptionalLazyMessageExtension
	}
	wOffset := m.offsetOptionalLazyMessageExtension
	
	var entry *TestAllTypes_NestedMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypes_NestedMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalLazyMessageExtension = entry
	m.parsedOptionalLazyMessageExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOptionalUnverifiedLazyMessageExtension() *TestAllTypes_NestedMessageReader {
	if m == nil {
		return nil
	}
	return m.readOptionalUnverifiedLazyMessageExtension()
}

func (m *TestAllExtensionsReader) readOptionalUnverifiedLazyMessageExtension() *TestAllTypes_NestedMessageReader {
	if m.parsedOptionalUnverifiedLazyMessageExtension {
		return m.dataOptionalUnverifiedLazyMessageExtension
	}
	wOffset := m.offsetOptionalUnverifiedLazyMessageExtension
	
	var entry *TestAllTypes_NestedMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypes_NestedMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalUnverifiedLazyMessageExtension = entry
	m.parsedOptionalUnverifiedLazyMessageExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedInt32Extension() []int32 {
	if m == nil {
		return nil
	}
	return m.readRepeatedInt32Extension()
}

func (m *TestAllExtensionsReader) readRepeatedInt32Extension() []int32 {
	if m.parsedRepeatedInt32Extension {
		return m.dataRepeatedInt32Extension
	}
	wOffset := m.offsetRepeatedInt32Extension
	var wType = m.wireTypeRepeatedInt32Extension
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadInt32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedInt32Extension = entry
	m.parsedRepeatedInt32Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedInt64Extension() []int64 {
	if m == nil {
		return nil
	}
	return m.readRepeatedInt64Extension()
}

func (m *TestAllExtensionsReader) readRepeatedInt64Extension() []int64 {
	if m.parsedRepeatedInt64Extension {
		return m.dataRepeatedInt64Extension
	}
	wOffset := m.offsetRepeatedInt64Extension
	var wType = m.wireTypeRepeatedInt64Extension
	
	var entry []int64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadInt64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int64
			if wOffset > 0 {
				listEntry = m.buf.ReadInt64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedInt64Extension = entry
	m.parsedRepeatedInt64Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedUint32Extension() []uint32 {
	if m == nil {
		return nil
	}
	return m.readRepeatedUint32Extension()
}

func (m *TestAllExtensionsReader) readRepeatedUint32Extension() []uint32 {
	if m.parsedRepeatedUint32Extension {
		return m.dataRepeatedUint32Extension
	}
	wOffset := m.offsetRepeatedUint32Extension
	var wType = m.wireTypeRepeatedUint32Extension
	
	var entry []uint32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadUint32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint32
			if wOffset > 0 {
				listEntry = m.buf.ReadUint32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedUint32Extension = entry
	m.parsedRepeatedUint32Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedUint64Extension() []uint64 {
	if m == nil {
		return nil
	}
	return m.readRepeatedUint64Extension()
}

func (m *TestAllExtensionsReader) readRepeatedUint64Extension() []uint64 {
	if m.parsedRepeatedUint64Extension {
		return m.dataRepeatedUint64Extension
	}
	wOffset := m.offsetRepeatedUint64Extension
	var wType = m.wireTypeRepeatedUint64Extension
	
	var entry []uint64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadUint64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint64
			if wOffset > 0 {
				listEntry = m.buf.ReadUint64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedUint64Extension = entry
	m.parsedRepeatedUint64Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedSint32Extension() []int32 {
	if m == nil {
		return nil
	}
	return m.readRepeatedSint32Extension()
}

func (m *TestAllExtensionsReader) readRepeatedSint32Extension() []int32 {
	if m.parsedRepeatedSint32Extension {
		return m.dataRepeatedSint32Extension
	}
	wOffset := m.offsetRepeatedSint32Extension
	var wType = m.wireTypeRepeatedSint32Extension
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSInt32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadSInt32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedSint32Extension = entry
	m.parsedRepeatedSint32Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedSint64Extension() []int64 {
	if m == nil {
		return nil
	}
	return m.readRepeatedSint64Extension()
}

func (m *TestAllExtensionsReader) readRepeatedSint64Extension() []int64 {
	if m.parsedRepeatedSint64Extension {
		return m.dataRepeatedSint64Extension
	}
	wOffset := m.offsetRepeatedSint64Extension
	var wType = m.wireTypeRepeatedSint64Extension
	
	var entry []int64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSInt64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int64
			if wOffset > 0 {
				listEntry = m.buf.ReadSInt64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedSint64Extension = entry
	m.parsedRepeatedSint64Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedFixed32Extension() []uint32 {
	if m == nil {
		return nil
	}
	return m.readRepeatedFixed32Extension()
}

func (m *TestAllExtensionsReader) readRepeatedFixed32Extension() []uint32 {
	if m.parsedRepeatedFixed32Extension {
		return m.dataRepeatedFixed32Extension
	}
	wOffset := m.offsetRepeatedFixed32Extension
	var wType = m.wireTypeRepeatedFixed32Extension
	
	var entry []uint32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFixed32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint32
			if wOffset > 0 {
				listEntry = m.buf.ReadFixed32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedFixed32Extension = entry
	m.parsedRepeatedFixed32Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedFixed64Extension() []uint64 {
	if m == nil {
		return nil
	}
	return m.readRepeatedFixed64Extension()
}

func (m *TestAllExtensionsReader) readRepeatedFixed64Extension() []uint64 {
	if m.parsedRepeatedFixed64Extension {
		return m.dataRepeatedFixed64Extension
	}
	wOffset := m.offsetRepeatedFixed64Extension
	var wType = m.wireTypeRepeatedFixed64Extension
	
	var entry []uint64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFixed64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint64
			if wOffset > 0 {
				listEntry = m.buf.ReadFixed64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedFixed64Extension = entry
	m.parsedRepeatedFixed64Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedSfixed32Extension() []int32 {
	if m == nil {
		return nil
	}
	return m.readRepeatedSfixed32Extension()
}

func (m *TestAllExtensionsReader) readRepeatedSfixed32Extension() []int32 {
	if m.parsedRepeatedSfixed32Extension {
		return m.dataRepeatedSfixed32Extension
	}
	wOffset := m.offsetRepeatedSfixed32Extension
	var wType = m.wireTypeRepeatedSfixed32Extension
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSFixed32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadSFixed32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedSfixed32Extension = entry
	m.parsedRepeatedSfixed32Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedSfixed64Extension() []int64 {
	if m == nil {
		return nil
	}
	return m.readRepeatedSfixed64Extension()
}

func (m *TestAllExtensionsReader) readRepeatedSfixed64Extension() []int64 {
	if m.parsedRepeatedSfixed64Extension {
		return m.dataRepeatedSfixed64Extension
	}
	wOffset := m.offsetRepeatedSfixed64Extension
	var wType = m.wireTypeRepeatedSfixed64Extension
	
	var entry []int64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSFixed64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int64
			if wOffset > 0 {
				listEntry = m.buf.ReadSFixed64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedSfixed64Extension = entry
	m.parsedRepeatedSfixed64Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedFloatExtension() []float32 {
	if m == nil {
		return nil
	}
	return m.readRepeatedFloatExtension()
}

func (m *TestAllExtensionsReader) readRepeatedFloatExtension() []float32 {
	if m.parsedRepeatedFloatExtension {
		return m.dataRepeatedFloatExtension
	}
	wOffset := m.offsetRepeatedFloatExtension
	var wType = m.wireTypeRepeatedFloatExtension
	
	var entry []float32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry float32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFloat32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry float32
			if wOffset > 0 {
				listEntry = m.buf.ReadFloat32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedFloatExtension = entry
	m.parsedRepeatedFloatExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedDoubleExtension() []float64 {
	if m == nil {
		return nil
	}
	return m.readRepeatedDoubleExtension()
}

func (m *TestAllExtensionsReader) readRepeatedDoubleExtension() []float64 {
	if m.parsedRepeatedDoubleExtension {
		return m.dataRepeatedDoubleExtension
	}
	wOffset := m.offsetRepeatedDoubleExtension
	var wType = m.wireTypeRepeatedDoubleExtension
	
	var entry []float64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry float64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFloat64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry float64
			if wOffset > 0 {
				listEntry = m.buf.ReadFloat64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedDoubleExtension = entry
	m.parsedRepeatedDoubleExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedBoolExtension() []bool {
	if m == nil {
		return nil
	}
	return m.readRepeatedBoolExtension()
}

func (m *TestAllExtensionsReader) readRepeatedBoolExtension() []bool {
	if m.parsedRepeatedBoolExtension {
		return m.dataRepeatedBoolExtension
	}
	wOffset := m.offsetRepeatedBoolExtension
	var wType = m.wireTypeRepeatedBoolExtension
	
	var entry []bool
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry bool
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadBool(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry bool
			if wOffset > 0 {
				listEntry = m.buf.ReadBool(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedBoolExtension = entry
	m.parsedRepeatedBoolExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedStringExtension() []string {
	if m == nil {
		return nil
	}
	return m.readRepeatedStringExtension()
}

func (m *TestAllExtensionsReader) readRepeatedStringExtension() []string {
	if m.parsedRepeatedStringExtension {
		return m.dataRepeatedStringExtension
	}
	wOffset := m.offsetRepeatedStringExtension
	
	var entry []string
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry string
		if wOffset > 0 {
			listEntry = m.buf.ReadString(wOffset)
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedStringExtension = entry
	m.parsedRepeatedStringExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedBytesExtension() [][]byte {
	if m == nil {
		return nil
	}
	return m.readRepeatedBytesExtension()
}

func (m *TestAllExtensionsReader) readRepeatedBytesExtension() [][]byte {
	if m.parsedRepeatedBytesExtension {
		return m.dataRepeatedBytesExtension
	}
	wOffset := m.offsetRepeatedBytesExtension
	
	var entry [][]byte
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry []byte
		if wOffset > 0 {
			listEntry = m.buf.ReadBytes(wOffset)
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedBytesExtension = entry
	m.parsedRepeatedBytesExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedNestedMessageExtension() []*TestAllTypes_NestedMessageReader {
	if m == nil {
		return nil
	}
	return m.readRepeatedNestedMessageExtension()
}

func (m *TestAllExtensionsReader) readRepeatedNestedMessageExtension() []*TestAllTypes_NestedMessageReader {
	if m.parsedRepeatedNestedMessageExtension {
		return m.dataRepeatedNestedMessageExtension
	}
	wOffset := m.offsetRepeatedNestedMessageExtension
	
	var entry []*TestAllTypes_NestedMessageReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *TestAllTypes_NestedMessageReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewTestAllTypes_NestedMessageReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedNestedMessageExtension = entry
	m.parsedRepeatedNestedMessageExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedForeignMessageExtension() []*ForeignMessageReader {
	if m == nil {
		return nil
	}
	return m.readRepeatedForeignMessageExtension()
}

func (m *TestAllExtensionsReader) readRepeatedForeignMessageExtension() []*ForeignMessageReader {
	if m.parsedRepeatedForeignMessageExtension {
		return m.dataRepeatedForeignMessageExtension
	}
	wOffset := m.offsetRepeatedForeignMessageExtension
	
	var entry []*ForeignMessageReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *ForeignMessageReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewForeignMessageReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedForeignMessageExtension = entry
	m.parsedRepeatedForeignMessageExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedImportMessageExtension() []*protobuf_unittest_import.ImportMessageReader {
	if m == nil {
		return nil
	}
	return m.readRepeatedImportMessageExtension()
}

func (m *TestAllExtensionsReader) readRepeatedImportMessageExtension() []*protobuf_unittest_import.ImportMessageReader {
	if m.parsedRepeatedImportMessageExtension {
		return m.dataRepeatedImportMessageExtension
	}
	wOffset := m.offsetRepeatedImportMessageExtension
	
	var entry []*protobuf_unittest_import.ImportMessageReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *protobuf_unittest_import.ImportMessageReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = protobuf_unittest_import.NewImportMessageReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedImportMessageExtension = entry
	m.parsedRepeatedImportMessageExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedNestedEnumExtension() []TestAllTypes_NestedEnum {
	if m == nil {
		return nil
	}
	return m.readRepeatedNestedEnumExtension()
}

func (m *TestAllExtensionsReader) readRepeatedNestedEnumExtension() []TestAllTypes_NestedEnum {
	if m.parsedRepeatedNestedEnumExtension {
		return m.dataRepeatedNestedEnumExtension
	}
	wOffset := m.offsetRepeatedNestedEnumExtension
	var wType = m.wireTypeRepeatedNestedEnumExtension
	
	var entry []TestAllTypes_NestedEnum
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry TestAllTypes_NestedEnum
				var listEntrySize int
				if wOffset > 0 {
					rawEntry, size := m.buf.SizedReadInt32(wOffset)
					listEntry = TestAllTypes_NestedEnum(rawEntry)
					listEntrySize = size
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry TestAllTypes_NestedEnum
			if wOffset > 0 {
				rawEntry := m.buf.ReadInt32(wOffset)
				listEntry = TestAllTypes_NestedEnum(rawEntry)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedNestedEnumExtension = entry
	m.parsedRepeatedNestedEnumExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedForeignEnumExtension() []ForeignEnum {
	if m == nil {
		return nil
	}
	return m.readRepeatedForeignEnumExtension()
}

func (m *TestAllExtensionsReader) readRepeatedForeignEnumExtension() []ForeignEnum {
	if m.parsedRepeatedForeignEnumExtension {
		return m.dataRepeatedForeignEnumExtension
	}
	wOffset := m.offsetRepeatedForeignEnumExtension
	var wType = m.wireTypeRepeatedForeignEnumExtension
	
	var entry []ForeignEnum
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry ForeignEnum
				var listEntrySize int
				if wOffset > 0 {
					rawEntry, size := m.buf.SizedReadInt32(wOffset)
					listEntry = ForeignEnum(rawEntry)
					listEntrySize = size
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry ForeignEnum
			if wOffset > 0 {
				rawEntry := m.buf.ReadInt32(wOffset)
				listEntry = ForeignEnum(rawEntry)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedForeignEnumExtension = entry
	m.parsedRepeatedForeignEnumExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedImportEnumExtension() []protobuf_unittest_import.ImportEnum {
	if m == nil {
		return nil
	}
	return m.readRepeatedImportEnumExtension()
}

func (m *TestAllExtensionsReader) readRepeatedImportEnumExtension() []protobuf_unittest_import.ImportEnum {
	if m.parsedRepeatedImportEnumExtension {
		return m.dataRepeatedImportEnumExtension
	}
	wOffset := m.offsetRepeatedImportEnumExtension
	var wType = m.wireTypeRepeatedImportEnumExtension
	
	var entry []protobuf_unittest_import.ImportEnum
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry protobuf_unittest_import.ImportEnum
				var listEntrySize int
				if wOffset > 0 {
					rawEntry, size := m.buf.SizedReadInt32(wOffset)
					listEntry = protobuf_unittest_import.ImportEnum(rawEntry)
					listEntrySize = size
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry protobuf_unittest_import.ImportEnum
			if wOffset > 0 {
				rawEntry := m.buf.ReadInt32(wOffset)
				listEntry = protobuf_unittest_import.ImportEnum(rawEntry)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedImportEnumExtension = entry
	m.parsedRepeatedImportEnumExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedStringPieceExtension() []string {
	if m == nil {
		return nil
	}
	return m.readRepeatedStringPieceExtension()
}

func (m *TestAllExtensionsReader) readRepeatedStringPieceExtension() []string {
	if m.parsedRepeatedStringPieceExtension {
		return m.dataRepeatedStringPieceExtension
	}
	wOffset := m.offsetRepeatedStringPieceExtension
	
	var entry []string
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry string
		if wOffset > 0 {
			listEntry = m.buf.ReadString(wOffset)
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedStringPieceExtension = entry
	m.parsedRepeatedStringPieceExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedCordExtension() []string {
	if m == nil {
		return nil
	}
	return m.readRepeatedCordExtension()
}

func (m *TestAllExtensionsReader) readRepeatedCordExtension() []string {
	if m.parsedRepeatedCordExtension {
		return m.dataRepeatedCordExtension
	}
	wOffset := m.offsetRepeatedCordExtension
	
	var entry []string
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry string
		if wOffset > 0 {
			listEntry = m.buf.ReadString(wOffset)
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedCordExtension = entry
	m.parsedRepeatedCordExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetRepeatedLazyMessageExtension() []*TestAllTypes_NestedMessageReader {
	if m == nil {
		return nil
	}
	return m.readRepeatedLazyMessageExtension()
}

func (m *TestAllExtensionsReader) readRepeatedLazyMessageExtension() []*TestAllTypes_NestedMessageReader {
	if m.parsedRepeatedLazyMessageExtension {
		return m.dataRepeatedLazyMessageExtension
	}
	wOffset := m.offsetRepeatedLazyMessageExtension
	
	var entry []*TestAllTypes_NestedMessageReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *TestAllTypes_NestedMessageReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewTestAllTypes_NestedMessageReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedLazyMessageExtension = entry
	m.parsedRepeatedLazyMessageExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetDefaultInt32Extension() int32 {
	if m == nil {
		return 41
	}
	return m.readDefaultInt32Extension()
}

func (m *TestAllExtensionsReader) readDefaultInt32Extension() int32 {
	if m.parsedDefaultInt32Extension {
		return m.dataDefaultInt32Extension
	}
	wOffset := m.offsetDefaultInt32Extension
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	} else {
		entry = 41
	}
	
	m.dataDefaultInt32Extension = entry
	m.parsedDefaultInt32Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetDefaultInt64Extension() int64 {
	if m == nil {
		return 42
	}
	return m.readDefaultInt64Extension()
}

func (m *TestAllExtensionsReader) readDefaultInt64Extension() int64 {
	if m.parsedDefaultInt64Extension {
		return m.dataDefaultInt64Extension
	}
	wOffset := m.offsetDefaultInt64Extension
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadInt64(wOffset)
	} else {
		entry = 42
	}
	
	m.dataDefaultInt64Extension = entry
	m.parsedDefaultInt64Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetDefaultUint32Extension() uint32 {
	if m == nil {
		return 43
	}
	return m.readDefaultUint32Extension()
}

func (m *TestAllExtensionsReader) readDefaultUint32Extension() uint32 {
	if m.parsedDefaultUint32Extension {
		return m.dataDefaultUint32Extension
	}
	wOffset := m.offsetDefaultUint32Extension
	
	var entry uint32
	if wOffset > 0 {
		entry = m.buf.ReadUint32(wOffset)
	} else {
		entry = 43
	}
	
	m.dataDefaultUint32Extension = entry
	m.parsedDefaultUint32Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetDefaultUint64Extension() uint64 {
	if m == nil {
		return 44
	}
	return m.readDefaultUint64Extension()
}

func (m *TestAllExtensionsReader) readDefaultUint64Extension() uint64 {
	if m.parsedDefaultUint64Extension {
		return m.dataDefaultUint64Extension
	}
	wOffset := m.offsetDefaultUint64Extension
	
	var entry uint64
	if wOffset > 0 {
		entry = m.buf.ReadUint64(wOffset)
	} else {
		entry = 44
	}
	
	m.dataDefaultUint64Extension = entry
	m.parsedDefaultUint64Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetDefaultSint32Extension() int32 {
	if m == nil {
		return -45
	}
	return m.readDefaultSint32Extension()
}

func (m *TestAllExtensionsReader) readDefaultSint32Extension() int32 {
	if m.parsedDefaultSint32Extension {
		return m.dataDefaultSint32Extension
	}
	wOffset := m.offsetDefaultSint32Extension
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadSInt32(wOffset)
	} else {
		entry = -45
	}
	
	m.dataDefaultSint32Extension = entry
	m.parsedDefaultSint32Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetDefaultSint64Extension() int64 {
	if m == nil {
		return 46
	}
	return m.readDefaultSint64Extension()
}

func (m *TestAllExtensionsReader) readDefaultSint64Extension() int64 {
	if m.parsedDefaultSint64Extension {
		return m.dataDefaultSint64Extension
	}
	wOffset := m.offsetDefaultSint64Extension
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadSInt64(wOffset)
	} else {
		entry = 46
	}
	
	m.dataDefaultSint64Extension = entry
	m.parsedDefaultSint64Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetDefaultFixed32Extension() uint32 {
	if m == nil {
		return 47
	}
	return m.readDefaultFixed32Extension()
}

func (m *TestAllExtensionsReader) readDefaultFixed32Extension() uint32 {
	if m.parsedDefaultFixed32Extension {
		return m.dataDefaultFixed32Extension
	}
	wOffset := m.offsetDefaultFixed32Extension
	
	var entry uint32
	if wOffset > 0 {
		entry = m.buf.ReadFixed32(wOffset)
	} else {
		entry = 47
	}
	
	m.dataDefaultFixed32Extension = entry
	m.parsedDefaultFixed32Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetDefaultFixed64Extension() uint64 {
	if m == nil {
		return 48
	}
	return m.readDefaultFixed64Extension()
}

func (m *TestAllExtensionsReader) readDefaultFixed64Extension() uint64 {
	if m.parsedDefaultFixed64Extension {
		return m.dataDefaultFixed64Extension
	}
	wOffset := m.offsetDefaultFixed64Extension
	
	var entry uint64
	if wOffset > 0 {
		entry = m.buf.ReadFixed64(wOffset)
	} else {
		entry = 48
	}
	
	m.dataDefaultFixed64Extension = entry
	m.parsedDefaultFixed64Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetDefaultSfixed32Extension() int32 {
	if m == nil {
		return 49
	}
	return m.readDefaultSfixed32Extension()
}

func (m *TestAllExtensionsReader) readDefaultSfixed32Extension() int32 {
	if m.parsedDefaultSfixed32Extension {
		return m.dataDefaultSfixed32Extension
	}
	wOffset := m.offsetDefaultSfixed32Extension
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadSFixed32(wOffset)
	} else {
		entry = 49
	}
	
	m.dataDefaultSfixed32Extension = entry
	m.parsedDefaultSfixed32Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetDefaultSfixed64Extension() int64 {
	if m == nil {
		return -50
	}
	return m.readDefaultSfixed64Extension()
}

func (m *TestAllExtensionsReader) readDefaultSfixed64Extension() int64 {
	if m.parsedDefaultSfixed64Extension {
		return m.dataDefaultSfixed64Extension
	}
	wOffset := m.offsetDefaultSfixed64Extension
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadSFixed64(wOffset)
	} else {
		entry = -50
	}
	
	m.dataDefaultSfixed64Extension = entry
	m.parsedDefaultSfixed64Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetDefaultFloatExtension() float32 {
	if m == nil {
		return 51.5
	}
	return m.readDefaultFloatExtension()
}

func (m *TestAllExtensionsReader) readDefaultFloatExtension() float32 {
	if m.parsedDefaultFloatExtension {
		return m.dataDefaultFloatExtension
	}
	wOffset := m.offsetDefaultFloatExtension
	
	var entry float32
	if wOffset > 0 {
		entry = m.buf.ReadFloat32(wOffset)
	} else {
		entry = 51.5
	}
	
	m.dataDefaultFloatExtension = entry
	m.parsedDefaultFloatExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetDefaultDoubleExtension() float64 {
	if m == nil {
		return 52e3
	}
	return m.readDefaultDoubleExtension()
}

func (m *TestAllExtensionsReader) readDefaultDoubleExtension() float64 {
	if m.parsedDefaultDoubleExtension {
		return m.dataDefaultDoubleExtension
	}
	wOffset := m.offsetDefaultDoubleExtension
	
	var entry float64
	if wOffset > 0 {
		entry = m.buf.ReadFloat64(wOffset)
	} else {
		entry = 52e3
	}
	
	m.dataDefaultDoubleExtension = entry
	m.parsedDefaultDoubleExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetDefaultBoolExtension() bool {
	if m == nil {
		return true
	}
	return m.readDefaultBoolExtension()
}

func (m *TestAllExtensionsReader) readDefaultBoolExtension() bool {
	if m.parsedDefaultBoolExtension {
		return m.dataDefaultBoolExtension
	}
	wOffset := m.offsetDefaultBoolExtension
	
	var entry bool
	if wOffset > 0 {
		entry = m.buf.ReadBool(wOffset)
	} else {
		entry = true
	}
	
	m.dataDefaultBoolExtension = entry
	m.parsedDefaultBoolExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetDefaultStringExtension() string {
	if m == nil {
		return "hello"
	}
	return m.readDefaultStringExtension()
}

func (m *TestAllExtensionsReader) readDefaultStringExtension() string {
	if m.parsedDefaultStringExtension {
		return m.dataDefaultStringExtension
	}
	wOffset := m.offsetDefaultStringExtension
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	} else {
		entry = "hello"
	}
	
	m.dataDefaultStringExtension = entry
	m.parsedDefaultStringExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetDefaultBytesExtension() []byte {
	if m == nil {
		return []byte("world")
	}
	return m.readDefaultBytesExtension()
}

func (m *TestAllExtensionsReader) readDefaultBytesExtension() []byte {
	if m.parsedDefaultBytesExtension {
		return m.dataDefaultBytesExtension
	}
	wOffset := m.offsetDefaultBytesExtension
	
	var entry []byte
	if wOffset > 0 {
		entry = m.buf.ReadBytes(wOffset)
	} else {
		entry = []byte("world")
	}
	
	m.dataDefaultBytesExtension = entry
	m.parsedDefaultBytesExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetDefaultNestedEnumExtension() TestAllTypes_NestedEnum {
	if m == nil {
		return 0
	}
	return m.readDefaultNestedEnumExtension()
}

func (m *TestAllExtensionsReader) readDefaultNestedEnumExtension() TestAllTypes_NestedEnum {
	if m.parsedDefaultNestedEnumExtension {
		return m.dataDefaultNestedEnumExtension
	}
	wOffset := m.offsetDefaultNestedEnumExtension
	
	var entry TestAllTypes_NestedEnum
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = TestAllTypes_NestedEnum(rawEntry)
	} else {
		entry = 0
	}
	
	m.dataDefaultNestedEnumExtension = entry
	m.parsedDefaultNestedEnumExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetDefaultForeignEnumExtension() ForeignEnum {
	if m == nil {
		return 0
	}
	return m.readDefaultForeignEnumExtension()
}

func (m *TestAllExtensionsReader) readDefaultForeignEnumExtension() ForeignEnum {
	if m.parsedDefaultForeignEnumExtension {
		return m.dataDefaultForeignEnumExtension
	}
	wOffset := m.offsetDefaultForeignEnumExtension
	
	var entry ForeignEnum
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = ForeignEnum(rawEntry)
	} else {
		entry = 0
	}
	
	m.dataDefaultForeignEnumExtension = entry
	m.parsedDefaultForeignEnumExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetDefaultImportEnumExtension() protobuf_unittest_import.ImportEnum {
	if m == nil {
		return 0
	}
	return m.readDefaultImportEnumExtension()
}

func (m *TestAllExtensionsReader) readDefaultImportEnumExtension() protobuf_unittest_import.ImportEnum {
	if m.parsedDefaultImportEnumExtension {
		return m.dataDefaultImportEnumExtension
	}
	wOffset := m.offsetDefaultImportEnumExtension
	
	var entry protobuf_unittest_import.ImportEnum
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = protobuf_unittest_import.ImportEnum(rawEntry)
	} else {
		entry = 0
	}
	
	m.dataDefaultImportEnumExtension = entry
	m.parsedDefaultImportEnumExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetDefaultStringPieceExtension() string {
	if m == nil {
		return "abc"
	}
	return m.readDefaultStringPieceExtension()
}

func (m *TestAllExtensionsReader) readDefaultStringPieceExtension() string {
	if m.parsedDefaultStringPieceExtension {
		return m.dataDefaultStringPieceExtension
	}
	wOffset := m.offsetDefaultStringPieceExtension
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	} else {
		entry = "abc"
	}
	
	m.dataDefaultStringPieceExtension = entry
	m.parsedDefaultStringPieceExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetDefaultCordExtension() string {
	if m == nil {
		return "123"
	}
	return m.readDefaultCordExtension()
}

func (m *TestAllExtensionsReader) readDefaultCordExtension() string {
	if m.parsedDefaultCordExtension {
		return m.dataDefaultCordExtension
	}
	wOffset := m.offsetDefaultCordExtension
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	} else {
		entry = "123"
	}
	
	m.dataDefaultCordExtension = entry
	m.parsedDefaultCordExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOneofUint32Extension() uint32 {
	if m == nil {
		return 0
	}
	return m.readOneofUint32Extension()
}

func (m *TestAllExtensionsReader) readOneofUint32Extension() uint32 {
	if m.parsedOneofUint32Extension {
		return m.dataOneofUint32Extension
	}
	wOffset := m.offsetOneofUint32Extension
	
	var entry uint32
	if wOffset > 0 {
		entry = m.buf.ReadUint32(wOffset)
	}
	
	m.dataOneofUint32Extension = entry
	m.parsedOneofUint32Extension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOneofNestedMessageExtension() *TestAllTypes_NestedMessageReader {
	if m == nil {
		return nil
	}
	return m.readOneofNestedMessageExtension()
}

func (m *TestAllExtensionsReader) readOneofNestedMessageExtension() *TestAllTypes_NestedMessageReader {
	if m.parsedOneofNestedMessageExtension {
		return m.dataOneofNestedMessageExtension
	}
	wOffset := m.offsetOneofNestedMessageExtension
	
	var entry *TestAllTypes_NestedMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypes_NestedMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOneofNestedMessageExtension = entry
	m.parsedOneofNestedMessageExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOneofStringExtension() string {
	if m == nil {
		return ""
	}
	return m.readOneofStringExtension()
}

func (m *TestAllExtensionsReader) readOneofStringExtension() string {
	if m.parsedOneofStringExtension {
		return m.dataOneofStringExtension
	}
	wOffset := m.offsetOneofStringExtension
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataOneofStringExtension = entry
	m.parsedOneofStringExtension = true
	return entry
}

func (m *TestAllExtensionsReader) GetOneofBytesExtension() []byte {
	if m == nil {
		return nil
	}
	return m.readOneofBytesExtension()
}

func (m *TestAllExtensionsReader) readOneofBytesExtension() []byte {
	if m.parsedOneofBytesExtension {
		return m.dataOneofBytesExtension
	}
	wOffset := m.offsetOneofBytesExtension
	
	var entry []byte
	if wOffset > 0 {
		entry = m.buf.ReadBytes(wOffset)
	}
	
	m.dataOneofBytesExtension = entry
	m.parsedOneofBytesExtension = true
	return entry
}

func (m *TestAllExtensionsReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestAllExtensions_OptionalInt32Extension:
			m.offsetOptionalInt32Extension = offset
		case wireTestAllExtensions_OptionalInt64Extension:
			m.offsetOptionalInt64Extension = offset
		case wireTestAllExtensions_OptionalUint32Extension:
			m.offsetOptionalUint32Extension = offset
		case wireTestAllExtensions_OptionalUint64Extension:
			m.offsetOptionalUint64Extension = offset
		case wireTestAllExtensions_OptionalSint32Extension:
			m.offsetOptionalSint32Extension = offset
		case wireTestAllExtensions_OptionalSint64Extension:
			m.offsetOptionalSint64Extension = offset
		case wireTestAllExtensions_OptionalFixed32Extension:
			m.offsetOptionalFixed32Extension = offset
		case wireTestAllExtensions_OptionalFixed64Extension:
			m.offsetOptionalFixed64Extension = offset
		case wireTestAllExtensions_OptionalSfixed32Extension:
			m.offsetOptionalSfixed32Extension = offset
		case wireTestAllExtensions_OptionalSfixed64Extension:
			m.offsetOptionalSfixed64Extension = offset
		case wireTestAllExtensions_OptionalFloatExtension:
			m.offsetOptionalFloatExtension = offset
		case wireTestAllExtensions_OptionalDoubleExtension:
			m.offsetOptionalDoubleExtension = offset
		case wireTestAllExtensions_OptionalBoolExtension:
			m.offsetOptionalBoolExtension = offset
		case wireTestAllExtensions_OptionalStringExtension:
			m.offsetOptionalStringExtension = offset
		case wireTestAllExtensions_OptionalBytesExtension:
			m.offsetOptionalBytesExtension = offset
		case wireTestAllExtensions_OptionalNestedMessageExtension:
			m.offsetOptionalNestedMessageExtension = offset
		case wireTestAllExtensions_OptionalForeignMessageExtension:
			m.offsetOptionalForeignMessageExtension = offset
		case wireTestAllExtensions_OptionalImportMessageExtension:
			m.offsetOptionalImportMessageExtension = offset
		case wireTestAllExtensions_OptionalNestedEnumExtension:
			m.offsetOptionalNestedEnumExtension = offset
		case wireTestAllExtensions_OptionalForeignEnumExtension:
			m.offsetOptionalForeignEnumExtension = offset
		case wireTestAllExtensions_OptionalImportEnumExtension:
			m.offsetOptionalImportEnumExtension = offset
		case wireTestAllExtensions_OptionalStringPieceExtension:
			m.offsetOptionalStringPieceExtension = offset
		case wireTestAllExtensions_OptionalCordExtension:
			m.offsetOptionalCordExtension = offset
		case wireTestAllExtensions_OptionalPublicImportMessageExtension:
			m.offsetOptionalPublicImportMessageExtension = offset
		case wireTestAllExtensions_OptionalLazyMessageExtension:
			m.offsetOptionalLazyMessageExtension = offset
		case wireTestAllExtensions_OptionalUnverifiedLazyMessageExtension:
			m.offsetOptionalUnverifiedLazyMessageExtension = offset
		case wireTestAllExtensions_RepeatedInt32Extension:
			m.offsetRepeatedInt32Extension = append(m.offsetRepeatedInt32Extension, offset)
			m.wireTypeRepeatedInt32Extension = append(m.wireTypeRepeatedInt32Extension, wire)
		case wireTestAllExtensions_RepeatedInt64Extension:
			m.offsetRepeatedInt64Extension = append(m.offsetRepeatedInt64Extension, offset)
			m.wireTypeRepeatedInt64Extension = append(m.wireTypeRepeatedInt64Extension, wire)
		case wireTestAllExtensions_RepeatedUint32Extension:
			m.offsetRepeatedUint32Extension = append(m.offsetRepeatedUint32Extension, offset)
			m.wireTypeRepeatedUint32Extension = append(m.wireTypeRepeatedUint32Extension, wire)
		case wireTestAllExtensions_RepeatedUint64Extension:
			m.offsetRepeatedUint64Extension = append(m.offsetRepeatedUint64Extension, offset)
			m.wireTypeRepeatedUint64Extension = append(m.wireTypeRepeatedUint64Extension, wire)
		case wireTestAllExtensions_RepeatedSint32Extension:
			m.offsetRepeatedSint32Extension = append(m.offsetRepeatedSint32Extension, offset)
			m.wireTypeRepeatedSint32Extension = append(m.wireTypeRepeatedSint32Extension, wire)
		case wireTestAllExtensions_RepeatedSint64Extension:
			m.offsetRepeatedSint64Extension = append(m.offsetRepeatedSint64Extension, offset)
			m.wireTypeRepeatedSint64Extension = append(m.wireTypeRepeatedSint64Extension, wire)
		case wireTestAllExtensions_RepeatedFixed32Extension:
			m.offsetRepeatedFixed32Extension = append(m.offsetRepeatedFixed32Extension, offset)
			m.wireTypeRepeatedFixed32Extension = append(m.wireTypeRepeatedFixed32Extension, wire)
		case wireTestAllExtensions_RepeatedFixed64Extension:
			m.offsetRepeatedFixed64Extension = append(m.offsetRepeatedFixed64Extension, offset)
			m.wireTypeRepeatedFixed64Extension = append(m.wireTypeRepeatedFixed64Extension, wire)
		case wireTestAllExtensions_RepeatedSfixed32Extension:
			m.offsetRepeatedSfixed32Extension = append(m.offsetRepeatedSfixed32Extension, offset)
			m.wireTypeRepeatedSfixed32Extension = append(m.wireTypeRepeatedSfixed32Extension, wire)
		case wireTestAllExtensions_RepeatedSfixed64Extension:
			m.offsetRepeatedSfixed64Extension = append(m.offsetRepeatedSfixed64Extension, offset)
			m.wireTypeRepeatedSfixed64Extension = append(m.wireTypeRepeatedSfixed64Extension, wire)
		case wireTestAllExtensions_RepeatedFloatExtension:
			m.offsetRepeatedFloatExtension = append(m.offsetRepeatedFloatExtension, offset)
			m.wireTypeRepeatedFloatExtension = append(m.wireTypeRepeatedFloatExtension, wire)
		case wireTestAllExtensions_RepeatedDoubleExtension:
			m.offsetRepeatedDoubleExtension = append(m.offsetRepeatedDoubleExtension, offset)
			m.wireTypeRepeatedDoubleExtension = append(m.wireTypeRepeatedDoubleExtension, wire)
		case wireTestAllExtensions_RepeatedBoolExtension:
			m.offsetRepeatedBoolExtension = append(m.offsetRepeatedBoolExtension, offset)
			m.wireTypeRepeatedBoolExtension = append(m.wireTypeRepeatedBoolExtension, wire)
		case wireTestAllExtensions_RepeatedStringExtension:
			m.offsetRepeatedStringExtension = append(m.offsetRepeatedStringExtension, offset)
		case wireTestAllExtensions_RepeatedBytesExtension:
			m.offsetRepeatedBytesExtension = append(m.offsetRepeatedBytesExtension, offset)
		case wireTestAllExtensions_RepeatedNestedMessageExtension:
			m.offsetRepeatedNestedMessageExtension = append(m.offsetRepeatedNestedMessageExtension, offset)
		case wireTestAllExtensions_RepeatedForeignMessageExtension:
			m.offsetRepeatedForeignMessageExtension = append(m.offsetRepeatedForeignMessageExtension, offset)
		case wireTestAllExtensions_RepeatedImportMessageExtension:
			m.offsetRepeatedImportMessageExtension = append(m.offsetRepeatedImportMessageExtension, offset)
		case wireTestAllExtensions_RepeatedNestedEnumExtension:
			m.offsetRepeatedNestedEnumExtension = append(m.offsetRepeatedNestedEnumExtension, offset)
			m.wireTypeRepeatedNestedEnumExtension = append(m.wireTypeRepeatedNestedEnumExtension, wire)
		case wireTestAllExtensions_RepeatedForeignEnumExtension:
			m.offsetRepeatedForeignEnumExtension = append(m.offsetRepeatedForeignEnumExtension, offset)
			m.wireTypeRepeatedForeignEnumExtension = append(m.wireTypeRepeatedForeignEnumExtension, wire)
		case wireTestAllExtensions_RepeatedImportEnumExtension:
			m.offsetRepeatedImportEnumExtension = append(m.offsetRepeatedImportEnumExtension, offset)
			m.wireTypeRepeatedImportEnumExtension = append(m.wireTypeRepeatedImportEnumExtension, wire)
		case wireTestAllExtensions_RepeatedStringPieceExtension:
			m.offsetRepeatedStringPieceExtension = append(m.offsetRepeatedStringPieceExtension, offset)
		case wireTestAllExtensions_RepeatedCordExtension:
			m.offsetRepeatedCordExtension = append(m.offsetRepeatedCordExtension, offset)
		case wireTestAllExtensions_RepeatedLazyMessageExtension:
			m.offsetRepeatedLazyMessageExtension = append(m.offsetRepeatedLazyMessageExtension, offset)
		case wireTestAllExtensions_DefaultInt32Extension:
			m.offsetDefaultInt32Extension = offset
		case wireTestAllExtensions_DefaultInt64Extension:
			m.offsetDefaultInt64Extension = offset
		case wireTestAllExtensions_DefaultUint32Extension:
			m.offsetDefaultUint32Extension = offset
		case wireTestAllExtensions_DefaultUint64Extension:
			m.offsetDefaultUint64Extension = offset
		case wireTestAllExtensions_DefaultSint32Extension:
			m.offsetDefaultSint32Extension = offset
		case wireTestAllExtensions_DefaultSint64Extension:
			m.offsetDefaultSint64Extension = offset
		case wireTestAllExtensions_DefaultFixed32Extension:
			m.offsetDefaultFixed32Extension = offset
		case wireTestAllExtensions_DefaultFixed64Extension:
			m.offsetDefaultFixed64Extension = offset
		case wireTestAllExtensions_DefaultSfixed32Extension:
			m.offsetDefaultSfixed32Extension = offset
		case wireTestAllExtensions_DefaultSfixed64Extension:
			m.offsetDefaultSfixed64Extension = offset
		case wireTestAllExtensions_DefaultFloatExtension:
			m.offsetDefaultFloatExtension = offset
		case wireTestAllExtensions_DefaultDoubleExtension:
			m.offsetDefaultDoubleExtension = offset
		case wireTestAllExtensions_DefaultBoolExtension:
			m.offsetDefaultBoolExtension = offset
		case wireTestAllExtensions_DefaultStringExtension:
			m.offsetDefaultStringExtension = offset
		case wireTestAllExtensions_DefaultBytesExtension:
			m.offsetDefaultBytesExtension = offset
		case wireTestAllExtensions_DefaultNestedEnumExtension:
			m.offsetDefaultNestedEnumExtension = offset
		case wireTestAllExtensions_DefaultForeignEnumExtension:
			m.offsetDefaultForeignEnumExtension = offset
		case wireTestAllExtensions_DefaultImportEnumExtension:
			m.offsetDefaultImportEnumExtension = offset
		case wireTestAllExtensions_DefaultStringPieceExtension:
			m.offsetDefaultStringPieceExtension = offset
		case wireTestAllExtensions_DefaultCordExtension:
			m.offsetDefaultCordExtension = offset
		case wireTestAllExtensions_OneofUint32Extension:
			m.offsetOneofUint32Extension = offset
		case wireTestAllExtensions_OneofNestedMessageExtension:
			m.offsetOneofNestedMessageExtension = offset
		case wireTestAllExtensions_OneofStringExtension:
			m.offsetOneofStringExtension = offset
		case wireTestAllExtensions_OneofBytesExtension:
			m.offsetOneofBytesExtension = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestAllExtensionsReader) ToStruct() *TestAllExtensions {
	if m == nil {
		return nil
	}
	res := &TestAllExtensions{}
	res.OptionalInt32Extension = m.GetOptionalInt32Extension()
	res.OptionalInt64Extension = m.GetOptionalInt64Extension()
	res.OptionalUint32Extension = m.GetOptionalUint32Extension()
	res.OptionalUint64Extension = m.GetOptionalUint64Extension()
	res.OptionalSint32Extension = m.GetOptionalSint32Extension()
	res.OptionalSint64Extension = m.GetOptionalSint64Extension()
	res.OptionalFixed32Extension = m.GetOptionalFixed32Extension()
	res.OptionalFixed64Extension = m.GetOptionalFixed64Extension()
	res.OptionalSfixed32Extension = m.GetOptionalSfixed32Extension()
	res.OptionalSfixed64Extension = m.GetOptionalSfixed64Extension()
	res.OptionalFloatExtension = m.GetOptionalFloatExtension()
	res.OptionalDoubleExtension = m.GetOptionalDoubleExtension()
	res.OptionalBoolExtension = m.GetOptionalBoolExtension()
	res.OptionalStringExtension = m.GetOptionalStringExtension()
	res.OptionalBytesExtension = m.GetOptionalBytesExtension()

	{
		var data = m.GetOptionalNestedMessageExtension()
		var structData *TestAllTypes_NestedMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalNestedMessageExtension = structData
	}

	{
		var data = m.GetOptionalForeignMessageExtension()
		var structData *ForeignMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalForeignMessageExtension = structData
	}

	{
		var data = m.GetOptionalImportMessageExtension()
		var structData *protobuf_unittest_import.ImportMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalImportMessageExtension = structData
	}
	res.OptionalNestedEnumExtension = m.GetOptionalNestedEnumExtension()
	res.OptionalForeignEnumExtension = m.GetOptionalForeignEnumExtension()
	res.OptionalImportEnumExtension = m.GetOptionalImportEnumExtension()
	res.OptionalStringPieceExtension = m.GetOptionalStringPieceExtension()
	res.OptionalCordExtension = m.GetOptionalCordExtension()

	{
		var data = m.GetOptionalPublicImportMessageExtension()
		var structData *protobuf_unittest_import.PublicImportMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalPublicImportMessageExtension = structData
	}

	{
		var data = m.GetOptionalLazyMessageExtension()
		var structData *TestAllTypes_NestedMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalLazyMessageExtension = structData
	}

	{
		var data = m.GetOptionalUnverifiedLazyMessageExtension()
		var structData *TestAllTypes_NestedMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalUnverifiedLazyMessageExtension = structData
	}
	res.RepeatedInt32Extension = m.GetRepeatedInt32Extension()
	res.RepeatedInt64Extension = m.GetRepeatedInt64Extension()
	res.RepeatedUint32Extension = m.GetRepeatedUint32Extension()
	res.RepeatedUint64Extension = m.GetRepeatedUint64Extension()
	res.RepeatedSint32Extension = m.GetRepeatedSint32Extension()
	res.RepeatedSint64Extension = m.GetRepeatedSint64Extension()
	res.RepeatedFixed32Extension = m.GetRepeatedFixed32Extension()
	res.RepeatedFixed64Extension = m.GetRepeatedFixed64Extension()
	res.RepeatedSfixed32Extension = m.GetRepeatedSfixed32Extension()
	res.RepeatedSfixed64Extension = m.GetRepeatedSfixed64Extension()
	res.RepeatedFloatExtension = m.GetRepeatedFloatExtension()
	res.RepeatedDoubleExtension = m.GetRepeatedDoubleExtension()
	res.RepeatedBoolExtension = m.GetRepeatedBoolExtension()
	res.RepeatedStringExtension = m.GetRepeatedStringExtension()
	res.RepeatedBytesExtension = m.GetRepeatedBytesExtension()

	{
		var data = m.GetRepeatedNestedMessageExtension()
		var structData []*TestAllTypes_NestedMessage
		if len(data) > 0 {
			structData = make([]*TestAllTypes_NestedMessage, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.RepeatedNestedMessageExtension = structData
	}

	{
		var data = m.GetRepeatedForeignMessageExtension()
		var structData []*ForeignMessage
		if len(data) > 0 {
			structData = make([]*ForeignMessage, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.RepeatedForeignMessageExtension = structData
	}

	{
		var data = m.GetRepeatedImportMessageExtension()
		var structData []*protobuf_unittest_import.ImportMessage
		if len(data) > 0 {
			structData = make([]*protobuf_unittest_import.ImportMessage, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.RepeatedImportMessageExtension = structData
	}
	res.RepeatedNestedEnumExtension = m.GetRepeatedNestedEnumExtension()
	res.RepeatedForeignEnumExtension = m.GetRepeatedForeignEnumExtension()
	res.RepeatedImportEnumExtension = m.GetRepeatedImportEnumExtension()
	res.RepeatedStringPieceExtension = m.GetRepeatedStringPieceExtension()
	res.RepeatedCordExtension = m.GetRepeatedCordExtension()

	{
		var data = m.GetRepeatedLazyMessageExtension()
		var structData []*TestAllTypes_NestedMessage
		if len(data) > 0 {
			structData = make([]*TestAllTypes_NestedMessage, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.RepeatedLazyMessageExtension = structData
	}
	res.DefaultInt32Extension = m.GetDefaultInt32Extension()
	res.DefaultInt64Extension = m.GetDefaultInt64Extension()
	res.DefaultUint32Extension = m.GetDefaultUint32Extension()
	res.DefaultUint64Extension = m.GetDefaultUint64Extension()
	res.DefaultSint32Extension = m.GetDefaultSint32Extension()
	res.DefaultSint64Extension = m.GetDefaultSint64Extension()
	res.DefaultFixed32Extension = m.GetDefaultFixed32Extension()
	res.DefaultFixed64Extension = m.GetDefaultFixed64Extension()
	res.DefaultSfixed32Extension = m.GetDefaultSfixed32Extension()
	res.DefaultSfixed64Extension = m.GetDefaultSfixed64Extension()
	res.DefaultFloatExtension = m.GetDefaultFloatExtension()
	res.DefaultDoubleExtension = m.GetDefaultDoubleExtension()
	res.DefaultBoolExtension = m.GetDefaultBoolExtension()
	res.DefaultStringExtension = m.GetDefaultStringExtension()
	res.DefaultBytesExtension = m.GetDefaultBytesExtension()
	res.DefaultNestedEnumExtension = m.GetDefaultNestedEnumExtension()
	res.DefaultForeignEnumExtension = m.GetDefaultForeignEnumExtension()
	res.DefaultImportEnumExtension = m.GetDefaultImportEnumExtension()
	res.DefaultStringPieceExtension = m.GetDefaultStringPieceExtension()
	res.DefaultCordExtension = m.GetDefaultCordExtension()
	res.OneofUint32Extension = m.GetOneofUint32Extension()

	{
		var data = m.GetOneofNestedMessageExtension()
		var structData *TestAllTypes_NestedMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.OneofNestedMessageExtension = structData
	}
	res.OneofStringExtension = m.GetOneofStringExtension()
	res.OneofBytesExtension = m.GetOneofBytesExtension()

	return res
}

func (s *TestAllExtensionsReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestAllExtensions struct {
	OptionalInt32Extension	int32	`json:"optional_int32_extension,omitempty"`
	OptionalInt64Extension	int64	`json:"optional_int64_extension,omitempty"`
	OptionalUint32Extension	uint32	`json:"optional_uint32_extension,omitempty"`
	OptionalUint64Extension	uint64	`json:"optional_uint64_extension,omitempty"`
	OptionalSint32Extension	int32	`json:"optional_sint32_extension,omitempty"`
	OptionalSint64Extension	int64	`json:"optional_sint64_extension,omitempty"`
	OptionalFixed32Extension	uint32	`json:"optional_fixed32_extension,omitempty"`
	OptionalFixed64Extension	uint64	`json:"optional_fixed64_extension,omitempty"`
	OptionalSfixed32Extension	int32	`json:"optional_sfixed32_extension,omitempty"`
	OptionalSfixed64Extension	int64	`json:"optional_sfixed64_extension,omitempty"`
	OptionalFloatExtension	float32	`json:"optional_float_extension,omitempty"`
	OptionalDoubleExtension	float64	`json:"optional_double_extension,omitempty"`
	OptionalBoolExtension	bool	`json:"optional_bool_extension,omitempty"`
	OptionalStringExtension	string	`json:"optional_string_extension,omitempty"`
	OptionalBytesExtension	[]byte	`json:"optional_bytes_extension,omitempty"`
	OptionalNestedMessageExtension	*TestAllTypes_NestedMessage	`json:"optional_nested_message_extension,omitempty"`
	OptionalForeignMessageExtension	*ForeignMessage	`json:"optional_foreign_message_extension,omitempty"`
	OptionalImportMessageExtension	*protobuf_unittest_import.ImportMessage	`json:"optional_import_message_extension,omitempty"`
	OptionalNestedEnumExtension	TestAllTypes_NestedEnum	`json:"optional_nested_enum_extension,omitempty"`
	OptionalForeignEnumExtension	ForeignEnum	`json:"optional_foreign_enum_extension,omitempty"`
	OptionalImportEnumExtension	protobuf_unittest_import.ImportEnum	`json:"optional_import_enum_extension,omitempty"`
	OptionalStringPieceExtension	string	`json:"optional_string_piece_extension,omitempty"`
	OptionalCordExtension	string	`json:"optional_cord_extension,omitempty"`
	OptionalPublicImportMessageExtension	*protobuf_unittest_import.PublicImportMessage	`json:"optional_public_import_message_extension,omitempty"`
	OptionalLazyMessageExtension	*TestAllTypes_NestedMessage	`json:"optional_lazy_message_extension,omitempty"`
	OptionalUnverifiedLazyMessageExtension	*TestAllTypes_NestedMessage	`json:"optional_unverified_lazy_message_extension,omitempty"`
	RepeatedInt32Extension	[]int32	`json:"repeated_int32_extension,omitempty"`
	RepeatedInt64Extension	[]int64	`json:"repeated_int64_extension,omitempty"`
	RepeatedUint32Extension	[]uint32	`json:"repeated_uint32_extension,omitempty"`
	RepeatedUint64Extension	[]uint64	`json:"repeated_uint64_extension,omitempty"`
	RepeatedSint32Extension	[]int32	`json:"repeated_sint32_extension,omitempty"`
	RepeatedSint64Extension	[]int64	`json:"repeated_sint64_extension,omitempty"`
	RepeatedFixed32Extension	[]uint32	`json:"repeated_fixed32_extension,omitempty"`
	RepeatedFixed64Extension	[]uint64	`json:"repeated_fixed64_extension,omitempty"`
	RepeatedSfixed32Extension	[]int32	`json:"repeated_sfixed32_extension,omitempty"`
	RepeatedSfixed64Extension	[]int64	`json:"repeated_sfixed64_extension,omitempty"`
	RepeatedFloatExtension	[]float32	`json:"repeated_float_extension,omitempty"`
	RepeatedDoubleExtension	[]float64	`json:"repeated_double_extension,omitempty"`
	RepeatedBoolExtension	[]bool	`json:"repeated_bool_extension,omitempty"`
	RepeatedStringExtension	[]string	`json:"repeated_string_extension,omitempty"`
	RepeatedBytesExtension	[][]byte	`json:"repeated_bytes_extension,omitempty"`
	RepeatedNestedMessageExtension	[]*TestAllTypes_NestedMessage	`json:"repeated_nested_message_extension,omitempty"`
	RepeatedForeignMessageExtension	[]*ForeignMessage	`json:"repeated_foreign_message_extension,omitempty"`
	RepeatedImportMessageExtension	[]*protobuf_unittest_import.ImportMessage	`json:"repeated_import_message_extension,omitempty"`
	RepeatedNestedEnumExtension	[]TestAllTypes_NestedEnum	`json:"repeated_nested_enum_extension,omitempty"`
	RepeatedForeignEnumExtension	[]ForeignEnum	`json:"repeated_foreign_enum_extension,omitempty"`
	RepeatedImportEnumExtension	[]protobuf_unittest_import.ImportEnum	`json:"repeated_import_enum_extension,omitempty"`
	RepeatedStringPieceExtension	[]string	`json:"repeated_string_piece_extension,omitempty"`
	RepeatedCordExtension	[]string	`json:"repeated_cord_extension,omitempty"`
	RepeatedLazyMessageExtension	[]*TestAllTypes_NestedMessage	`json:"repeated_lazy_message_extension,omitempty"`
	DefaultInt32Extension	int32	`json:"default_int32_extension,omitempty"`
	DefaultInt64Extension	int64	`json:"default_int64_extension,omitempty"`
	DefaultUint32Extension	uint32	`json:"default_uint32_extension,omitempty"`
	DefaultUint64Extension	uint64	`json:"default_uint64_extension,omitempty"`
	DefaultSint32Extension	int32	`json:"default_sint32_extension,omitempty"`
	DefaultSint64Extension	int64	`json:"default_sint64_extension,omitempty"`
	DefaultFixed32Extension	uint32	`json:"default_fixed32_extension,omitempty"`
	DefaultFixed64Extension	uint64	`json:"default_fixed64_extension,omitempty"`
	DefaultSfixed32Extension	int32	`json:"default_sfixed32_extension,omitempty"`
	DefaultSfixed64Extension	int64	`json:"default_sfixed64_extension,omitempty"`
	DefaultFloatExtension	float32	`json:"default_float_extension,omitempty"`
	DefaultDoubleExtension	float64	`json:"default_double_extension,omitempty"`
	DefaultBoolExtension	bool	`json:"default_bool_extension,omitempty"`
	DefaultStringExtension	string	`json:"default_string_extension,omitempty"`
	DefaultBytesExtension	[]byte	`json:"default_bytes_extension,omitempty"`
	DefaultNestedEnumExtension	TestAllTypes_NestedEnum	`json:"default_nested_enum_extension,omitempty"`
	DefaultForeignEnumExtension	ForeignEnum	`json:"default_foreign_enum_extension,omitempty"`
	DefaultImportEnumExtension	protobuf_unittest_import.ImportEnum	`json:"default_import_enum_extension,omitempty"`
	DefaultStringPieceExtension	string	`json:"default_string_piece_extension,omitempty"`
	DefaultCordExtension	string	`json:"default_cord_extension,omitempty"`
	OneofUint32Extension	uint32	`json:"oneof_uint32_extension,omitempty"`
	OneofNestedMessageExtension	*TestAllTypes_NestedMessage	`json:"oneof_nested_message_extension,omitempty"`
	OneofStringExtension	string	`json:"oneof_string_extension,omitempty"`
	OneofBytesExtension	[]byte	`json:"oneof_bytes_extension,omitempty"`
}

func (s *TestAllExtensions) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestAllExtensions) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.OptionalInt32Extension != 0 {
		res.AppendInt32(wireTestAllExtensions_OptionalInt32Extension, s.OptionalInt32Extension)
	}
	if s.OptionalInt64Extension != 0 {
		res.AppendInt64(wireTestAllExtensions_OptionalInt64Extension, s.OptionalInt64Extension)
	}
	if s.OptionalUint32Extension != 0 {
		res.AppendUint32(wireTestAllExtensions_OptionalUint32Extension, s.OptionalUint32Extension)
	}
	if s.OptionalUint64Extension != 0 {
		res.AppendUint64(wireTestAllExtensions_OptionalUint64Extension, s.OptionalUint64Extension)
	}
	if s.OptionalSint32Extension != 0 {
		res.AppendSInt32(wireTestAllExtensions_OptionalSint32Extension, s.OptionalSint32Extension)
	}
	if s.OptionalSint64Extension != 0 {
		res.AppendSInt64(wireTestAllExtensions_OptionalSint64Extension, s.OptionalSint64Extension)
	}
	if s.OptionalFixed32Extension != 0 {
		res.AppendFixed32(wireTestAllExtensions_OptionalFixed32Extension, s.OptionalFixed32Extension)
	}
	if s.OptionalFixed64Extension != 0 {
		res.AppendFixed64(wireTestAllExtensions_OptionalFixed64Extension, s.OptionalFixed64Extension)
	}
	if s.OptionalSfixed32Extension != 0 {
		res.AppendSFixed32(wireTestAllExtensions_OptionalSfixed32Extension, s.OptionalSfixed32Extension)
	}
	if s.OptionalSfixed64Extension != 0 {
		res.AppendSFixed64(wireTestAllExtensions_OptionalSfixed64Extension, s.OptionalSfixed64Extension)
	}
	if s.OptionalFloatExtension != 0 {
		res.AppendFloat32(wireTestAllExtensions_OptionalFloatExtension, s.OptionalFloatExtension)
	}
	if s.OptionalDoubleExtension != 0 {
		res.AppendFloat64(wireTestAllExtensions_OptionalDoubleExtension, s.OptionalDoubleExtension)
	}
	if s.OptionalBoolExtension {
		res.AppendBool(wireTestAllExtensions_OptionalBoolExtension, s.OptionalBoolExtension)
	}
	if s.OptionalStringExtension != "" {
		res.AppendString(wireTestAllExtensions_OptionalStringExtension, s.OptionalStringExtension)
	}
	if len(s.OptionalBytesExtension) != 0 {
		res.AppendBytes(wireTestAllExtensions_OptionalBytesExtension, s.OptionalBytesExtension)
	}
	if s.OptionalNestedMessageExtension != nil {
		structSize := s.OptionalNestedMessageExtension.XXX_PbContentSize()
		res.AppendBytesTag(wireTestAllExtensions_OptionalNestedMessageExtension, structSize)
		s.OptionalNestedMessageExtension.MarshalTo(res)
	}
	if s.OptionalForeignMessageExtension != nil {
		structSize := s.OptionalForeignMessageExtension.XXX_PbContentSize()
		res.AppendBytesTag(wireTestAllExtensions_OptionalForeignMessageExtension, structSize)
		s.OptionalForeignMessageExtension.MarshalTo(res)
	}
	if s.OptionalImportMessageExtension != nil {
		structSize := s.OptionalImportMessageExtension.XXX_PbContentSize()
		res.AppendBytesTag(wireTestAllExtensions_OptionalImportMessageExtension, structSize)
		s.OptionalImportMessageExtension.MarshalTo(res)
	}
	if s.OptionalNestedEnumExtension != 0 {
		res.AppendInt32(wireTestAllExtensions_OptionalNestedEnumExtension, int32(s.OptionalNestedEnumExtension))
	}
	if s.OptionalForeignEnumExtension != 0 {
		res.AppendInt32(wireTestAllExtensions_OptionalForeignEnumExtension, int32(s.OptionalForeignEnumExtension))
	}
	if s.OptionalImportEnumExtension != 0 {
		res.AppendInt32(wireTestAllExtensions_OptionalImportEnumExtension, int32(s.OptionalImportEnumExtension))
	}
	if s.OptionalStringPieceExtension != "" {
		res.AppendString(wireTestAllExtensions_OptionalStringPieceExtension, s.OptionalStringPieceExtension)
	}
	if s.OptionalCordExtension != "" {
		res.AppendString(wireTestAllExtensions_OptionalCordExtension, s.OptionalCordExtension)
	}
	if s.OptionalPublicImportMessageExtension != nil {
		structSize := s.OptionalPublicImportMessageExtension.XXX_PbContentSize()
		res.AppendBytesTag(wireTestAllExtensions_OptionalPublicImportMessageExtension, structSize)
		s.OptionalPublicImportMessageExtension.MarshalTo(res)
	}
	if s.OptionalLazyMessageExtension != nil {
		structSize := s.OptionalLazyMessageExtension.XXX_PbContentSize()
		res.AppendBytesTag(wireTestAllExtensions_OptionalLazyMessageExtension, structSize)
		s.OptionalLazyMessageExtension.MarshalTo(res)
	}
	if s.OptionalUnverifiedLazyMessageExtension != nil {
		structSize := s.OptionalUnverifiedLazyMessageExtension.XXX_PbContentSize()
		res.AppendBytesTag(wireTestAllExtensions_OptionalUnverifiedLazyMessageExtension, structSize)
		s.OptionalUnverifiedLazyMessageExtension.MarshalTo(res)
	}
	if len(s.RepeatedInt32Extension) > 0 {
		if len(s.RepeatedInt32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedInt32Extension {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllExtensions_RepeatedInt32Extension, listBytesSize)
			for _, entry := range s.RepeatedInt32Extension {
				res.AppendInt32WithoutTag(entry)
			}
		} else if len(s.RepeatedInt32Extension) == 1 {
			res.AppendInt32(wireTestAllExtensions_RepeatedInt32Extension, s.RepeatedInt32Extension[0])
		}
	}
	if len(s.RepeatedInt64Extension) > 0 {
		if len(s.RepeatedInt64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedInt64Extension {
				var entrySize = 0
				entrySize = gremlin.SizeInt64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllExtensions_RepeatedInt64Extension, listBytesSize)
			for _, entry := range s.RepeatedInt64Extension {
				res.AppendInt64WithoutTag(entry)
			}
		} else if len(s.RepeatedInt64Extension) == 1 {
			res.AppendInt64(wireTestAllExtensions_RepeatedInt64Extension, s.RepeatedInt64Extension[0])
		}
	}
	if len(s.RepeatedUint32Extension) > 0 {
		if len(s.RepeatedUint32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedUint32Extension {
				var entrySize = 0
				entrySize = gremlin.SizeUint32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllExtensions_RepeatedUint32Extension, listBytesSize)
			for _, entry := range s.RepeatedUint32Extension {
				res.AppendUint32WithoutTag(entry)
			}
		} else if len(s.RepeatedUint32Extension) == 1 {
			res.AppendUint32(wireTestAllExtensions_RepeatedUint32Extension, s.RepeatedUint32Extension[0])
		}
	}
	if len(s.RepeatedUint64Extension) > 0 {
		if len(s.RepeatedUint64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedUint64Extension {
				var entrySize = 0
				entrySize = gremlin.SizeUint64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllExtensions_RepeatedUint64Extension, listBytesSize)
			for _, entry := range s.RepeatedUint64Extension {
				res.AppendUint64WithoutTag(entry)
			}
		} else if len(s.RepeatedUint64Extension) == 1 {
			res.AppendUint64(wireTestAllExtensions_RepeatedUint64Extension, s.RepeatedUint64Extension[0])
		}
	}
	if len(s.RepeatedSint32Extension) > 0 {
		if len(s.RepeatedSint32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedSint32Extension {
				var entrySize = 0
				entrySize = gremlin.SizeSInt32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllExtensions_RepeatedSint32Extension, listBytesSize)
			for _, entry := range s.RepeatedSint32Extension {
				res.AppendSInt32WithoutTag(entry)
			}
		} else if len(s.RepeatedSint32Extension) == 1 {
			res.AppendSInt32(wireTestAllExtensions_RepeatedSint32Extension, s.RepeatedSint32Extension[0])
		}
	}
	if len(s.RepeatedSint64Extension) > 0 {
		if len(s.RepeatedSint64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedSint64Extension {
				var entrySize = 0
				entrySize = gremlin.SizeSInt64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllExtensions_RepeatedSint64Extension, listBytesSize)
			for _, entry := range s.RepeatedSint64Extension {
				res.AppendSInt64WithoutTag(entry)
			}
		} else if len(s.RepeatedSint64Extension) == 1 {
			res.AppendSInt64(wireTestAllExtensions_RepeatedSint64Extension, s.RepeatedSint64Extension[0])
		}
	}
	if len(s.RepeatedFixed32Extension) > 0 {
		if len(s.RepeatedFixed32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedFixed32Extension {
				var entrySize = 0
				entrySize = gremlin.SizeFixed32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllExtensions_RepeatedFixed32Extension, listBytesSize)
			for _, entry := range s.RepeatedFixed32Extension {
				res.AppendFixed32WithoutTag(entry)
			}
		} else if len(s.RepeatedFixed32Extension) == 1 {
			res.AppendFixed32(wireTestAllExtensions_RepeatedFixed32Extension, s.RepeatedFixed32Extension[0])
		}
	}
	if len(s.RepeatedFixed64Extension) > 0 {
		if len(s.RepeatedFixed64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedFixed64Extension {
				var entrySize = 0
				entrySize = gremlin.SizeFixed64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllExtensions_RepeatedFixed64Extension, listBytesSize)
			for _, entry := range s.RepeatedFixed64Extension {
				res.AppendFixed64WithoutTag(entry)
			}
		} else if len(s.RepeatedFixed64Extension) == 1 {
			res.AppendFixed64(wireTestAllExtensions_RepeatedFixed64Extension, s.RepeatedFixed64Extension[0])
		}
	}
	if len(s.RepeatedSfixed32Extension) > 0 {
		if len(s.RepeatedSfixed32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedSfixed32Extension {
				var entrySize = 0
				entrySize = gremlin.SizeSFixed32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllExtensions_RepeatedSfixed32Extension, listBytesSize)
			for _, entry := range s.RepeatedSfixed32Extension {
				res.AppendSFixed32WithoutTag(entry)
			}
		} else if len(s.RepeatedSfixed32Extension) == 1 {
			res.AppendSFixed32(wireTestAllExtensions_RepeatedSfixed32Extension, s.RepeatedSfixed32Extension[0])
		}
	}
	if len(s.RepeatedSfixed64Extension) > 0 {
		if len(s.RepeatedSfixed64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedSfixed64Extension {
				var entrySize = 0
				entrySize = gremlin.SizeSFixed64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllExtensions_RepeatedSfixed64Extension, listBytesSize)
			for _, entry := range s.RepeatedSfixed64Extension {
				res.AppendSFixed64WithoutTag(entry)
			}
		} else if len(s.RepeatedSfixed64Extension) == 1 {
			res.AppendSFixed64(wireTestAllExtensions_RepeatedSfixed64Extension, s.RepeatedSfixed64Extension[0])
		}
	}
	if len(s.RepeatedFloatExtension) > 0 {
		if len(s.RepeatedFloatExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedFloatExtension {
				var entrySize = 0
				entrySize = gremlin.SizeFloat32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllExtensions_RepeatedFloatExtension, listBytesSize)
			for _, entry := range s.RepeatedFloatExtension {
				res.AppendFloat32WithoutTag(entry)
			}
		} else if len(s.RepeatedFloatExtension) == 1 {
			res.AppendFloat32(wireTestAllExtensions_RepeatedFloatExtension, s.RepeatedFloatExtension[0])
		}
	}
	if len(s.RepeatedDoubleExtension) > 0 {
		if len(s.RepeatedDoubleExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedDoubleExtension {
				var entrySize = 0
				entrySize = gremlin.SizeFloat64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllExtensions_RepeatedDoubleExtension, listBytesSize)
			for _, entry := range s.RepeatedDoubleExtension {
				res.AppendFloat64WithoutTag(entry)
			}
		} else if len(s.RepeatedDoubleExtension) == 1 {
			res.AppendFloat64(wireTestAllExtensions_RepeatedDoubleExtension, s.RepeatedDoubleExtension[0])
		}
	}
	if len(s.RepeatedBoolExtension) > 0 {
		if len(s.RepeatedBoolExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedBoolExtension {
				var entrySize = 0
				entrySize = gremlin.SizeBool(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllExtensions_RepeatedBoolExtension, listBytesSize)
			for _, entry := range s.RepeatedBoolExtension {
				res.AppendBoolWithoutTag(entry)
			}
		} else if len(s.RepeatedBoolExtension) == 1 {
			res.AppendBool(wireTestAllExtensions_RepeatedBoolExtension, s.RepeatedBoolExtension[0])
		}
	}
	if len(s.RepeatedStringExtension) > 0 {
		for _, entry := range s.RepeatedStringExtension {
			res.AppendString(wireTestAllExtensions_RepeatedStringExtension, entry)
		}
	}
	if len(s.RepeatedBytesExtension) > 0 {
		for _, entry := range s.RepeatedBytesExtension {
			res.AppendBytes(wireTestAllExtensions_RepeatedBytesExtension, entry)
		}
	}
	if len(s.RepeatedNestedMessageExtension) > 0 {
		for _, entry := range s.RepeatedNestedMessageExtension {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireTestAllExtensions_RepeatedNestedMessageExtension, structSize)
			entry.MarshalTo(res)
		}
	}
	if len(s.RepeatedForeignMessageExtension) > 0 {
		for _, entry := range s.RepeatedForeignMessageExtension {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireTestAllExtensions_RepeatedForeignMessageExtension, structSize)
			entry.MarshalTo(res)
		}
	}
	if len(s.RepeatedImportMessageExtension) > 0 {
		for _, entry := range s.RepeatedImportMessageExtension {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireTestAllExtensions_RepeatedImportMessageExtension, structSize)
			entry.MarshalTo(res)
		}
	}
	if len(s.RepeatedNestedEnumExtension) > 0 {
		if len(s.RepeatedNestedEnumExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedNestedEnumExtension {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(int32(entry))
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllExtensions_RepeatedNestedEnumExtension, listBytesSize)
			for _, entry := range s.RepeatedNestedEnumExtension {
				res.AppendInt32WithoutTag(int32(entry))
			}
		} else if len(s.RepeatedNestedEnumExtension) == 1 {
			res.AppendInt32(wireTestAllExtensions_RepeatedNestedEnumExtension, int32(s.RepeatedNestedEnumExtension[0]))
		}
	}
	if len(s.RepeatedForeignEnumExtension) > 0 {
		if len(s.RepeatedForeignEnumExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedForeignEnumExtension {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(int32(entry))
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllExtensions_RepeatedForeignEnumExtension, listBytesSize)
			for _, entry := range s.RepeatedForeignEnumExtension {
				res.AppendInt32WithoutTag(int32(entry))
			}
		} else if len(s.RepeatedForeignEnumExtension) == 1 {
			res.AppendInt32(wireTestAllExtensions_RepeatedForeignEnumExtension, int32(s.RepeatedForeignEnumExtension[0]))
		}
	}
	if len(s.RepeatedImportEnumExtension) > 0 {
		if len(s.RepeatedImportEnumExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedImportEnumExtension {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(int32(entry))
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestAllExtensions_RepeatedImportEnumExtension, listBytesSize)
			for _, entry := range s.RepeatedImportEnumExtension {
				res.AppendInt32WithoutTag(int32(entry))
			}
		} else if len(s.RepeatedImportEnumExtension) == 1 {
			res.AppendInt32(wireTestAllExtensions_RepeatedImportEnumExtension, int32(s.RepeatedImportEnumExtension[0]))
		}
	}
	if len(s.RepeatedStringPieceExtension) > 0 {
		for _, entry := range s.RepeatedStringPieceExtension {
			res.AppendString(wireTestAllExtensions_RepeatedStringPieceExtension, entry)
		}
	}
	if len(s.RepeatedCordExtension) > 0 {
		for _, entry := range s.RepeatedCordExtension {
			res.AppendString(wireTestAllExtensions_RepeatedCordExtension, entry)
		}
	}
	if len(s.RepeatedLazyMessageExtension) > 0 {
		for _, entry := range s.RepeatedLazyMessageExtension {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireTestAllExtensions_RepeatedLazyMessageExtension, structSize)
			entry.MarshalTo(res)
		}
	}
	if s.DefaultInt32Extension != 41 {
		res.AppendInt32(wireTestAllExtensions_DefaultInt32Extension, s.DefaultInt32Extension)
	}
	if s.DefaultInt64Extension != 42 {
		res.AppendInt64(wireTestAllExtensions_DefaultInt64Extension, s.DefaultInt64Extension)
	}
	if s.DefaultUint32Extension != 43 {
		res.AppendUint32(wireTestAllExtensions_DefaultUint32Extension, s.DefaultUint32Extension)
	}
	if s.DefaultUint64Extension != 44 {
		res.AppendUint64(wireTestAllExtensions_DefaultUint64Extension, s.DefaultUint64Extension)
	}
	if s.DefaultSint32Extension != -45 {
		res.AppendSInt32(wireTestAllExtensions_DefaultSint32Extension, s.DefaultSint32Extension)
	}
	if s.DefaultSint64Extension != 46 {
		res.AppendSInt64(wireTestAllExtensions_DefaultSint64Extension, s.DefaultSint64Extension)
	}
	if s.DefaultFixed32Extension != 47 {
		res.AppendFixed32(wireTestAllExtensions_DefaultFixed32Extension, s.DefaultFixed32Extension)
	}
	if s.DefaultFixed64Extension != 48 {
		res.AppendFixed64(wireTestAllExtensions_DefaultFixed64Extension, s.DefaultFixed64Extension)
	}
	if s.DefaultSfixed32Extension != 49 {
		res.AppendSFixed32(wireTestAllExtensions_DefaultSfixed32Extension, s.DefaultSfixed32Extension)
	}
	if s.DefaultSfixed64Extension != -50 {
		res.AppendSFixed64(wireTestAllExtensions_DefaultSfixed64Extension, s.DefaultSfixed64Extension)
	}
	if s.DefaultFloatExtension != 51.5 {
		res.AppendFloat32(wireTestAllExtensions_DefaultFloatExtension, s.DefaultFloatExtension)
	}
	if s.DefaultDoubleExtension != 52e3 {
		res.AppendFloat64(wireTestAllExtensions_DefaultDoubleExtension, s.DefaultDoubleExtension)
	}
	if s.DefaultBoolExtension != true {
		res.AppendBool(wireTestAllExtensions_DefaultBoolExtension, s.DefaultBoolExtension)
	}
	if s.DefaultStringExtension != "hello" {
		res.AppendString(wireTestAllExtensions_DefaultStringExtension, s.DefaultStringExtension)
	}
	if !bytes.Equal(s.DefaultBytesExtension, []byte("world")) {
		res.AppendBytes(wireTestAllExtensions_DefaultBytesExtension, s.DefaultBytesExtension)
	}
	if s.DefaultNestedEnumExtension != 0 {
		res.AppendInt32(wireTestAllExtensions_DefaultNestedEnumExtension, int32(s.DefaultNestedEnumExtension))
	}
	if s.DefaultForeignEnumExtension != 0 {
		res.AppendInt32(wireTestAllExtensions_DefaultForeignEnumExtension, int32(s.DefaultForeignEnumExtension))
	}
	if s.DefaultImportEnumExtension != 0 {
		res.AppendInt32(wireTestAllExtensions_DefaultImportEnumExtension, int32(s.DefaultImportEnumExtension))
	}
	if s.DefaultStringPieceExtension != "abc" {
		res.AppendString(wireTestAllExtensions_DefaultStringPieceExtension, s.DefaultStringPieceExtension)
	}
	if s.DefaultCordExtension != "123" {
		res.AppendString(wireTestAllExtensions_DefaultCordExtension, s.DefaultCordExtension)
	}
	if s.OneofUint32Extension != 0 {
		res.AppendUint32(wireTestAllExtensions_OneofUint32Extension, s.OneofUint32Extension)
	}
	if s.OneofNestedMessageExtension != nil {
		structSize := s.OneofNestedMessageExtension.XXX_PbContentSize()
		res.AppendBytesTag(wireTestAllExtensions_OneofNestedMessageExtension, structSize)
		s.OneofNestedMessageExtension.MarshalTo(res)
	}
	if s.OneofStringExtension != "" {
		res.AppendString(wireTestAllExtensions_OneofStringExtension, s.OneofStringExtension)
	}
	if len(s.OneofBytesExtension) != 0 {
		res.AppendBytes(wireTestAllExtensions_OneofBytesExtension, s.OneofBytesExtension)
	}
}

func (s *TestAllExtensions) Copy() *TestAllExtensions {
	if s == nil {
		return nil
	}
	res := &TestAllExtensions{}
	res.OptionalInt32Extension = s.OptionalInt32Extension
	res.OptionalInt64Extension = s.OptionalInt64Extension
	res.OptionalUint32Extension = s.OptionalUint32Extension
	res.OptionalUint64Extension = s.OptionalUint64Extension
	res.OptionalSint32Extension = s.OptionalSint32Extension
	res.OptionalSint64Extension = s.OptionalSint64Extension
	res.OptionalFixed32Extension = s.OptionalFixed32Extension
	res.OptionalFixed64Extension = s.OptionalFixed64Extension
	res.OptionalSfixed32Extension = s.OptionalSfixed32Extension
	res.OptionalSfixed64Extension = s.OptionalSfixed64Extension
	res.OptionalFloatExtension = s.OptionalFloatExtension
	res.OptionalDoubleExtension = s.OptionalDoubleExtension
	res.OptionalBoolExtension = s.OptionalBoolExtension
	res.OptionalStringExtension = s.OptionalStringExtension
	res.OptionalBytesExtension = s.OptionalBytesExtension
	if s.OptionalNestedMessageExtension != nil {
		res.OptionalNestedMessageExtension = s.OptionalNestedMessageExtension.Copy()
	}
	if s.OptionalForeignMessageExtension != nil {
		res.OptionalForeignMessageExtension = s.OptionalForeignMessageExtension.Copy()
	}
	if s.OptionalImportMessageExtension != nil {
		res.OptionalImportMessageExtension = s.OptionalImportMessageExtension.Copy()
	}
	res.OptionalNestedEnumExtension = s.OptionalNestedEnumExtension
	res.OptionalForeignEnumExtension = s.OptionalForeignEnumExtension
	res.OptionalImportEnumExtension = s.OptionalImportEnumExtension
	res.OptionalStringPieceExtension = s.OptionalStringPieceExtension
	res.OptionalCordExtension = s.OptionalCordExtension
	if s.OptionalPublicImportMessageExtension != nil {
		res.OptionalPublicImportMessageExtension = s.OptionalPublicImportMessageExtension.Copy()
	}
	if s.OptionalLazyMessageExtension != nil {
		res.OptionalLazyMessageExtension = s.OptionalLazyMessageExtension.Copy()
	}
	if s.OptionalUnverifiedLazyMessageExtension != nil {
		res.OptionalUnverifiedLazyMessageExtension = s.OptionalUnverifiedLazyMessageExtension.Copy()
	}
	res.RepeatedInt32Extension = s.RepeatedInt32Extension
	res.RepeatedInt64Extension = s.RepeatedInt64Extension
	res.RepeatedUint32Extension = s.RepeatedUint32Extension
	res.RepeatedUint64Extension = s.RepeatedUint64Extension
	res.RepeatedSint32Extension = s.RepeatedSint32Extension
	res.RepeatedSint64Extension = s.RepeatedSint64Extension
	res.RepeatedFixed32Extension = s.RepeatedFixed32Extension
	res.RepeatedFixed64Extension = s.RepeatedFixed64Extension
	res.RepeatedSfixed32Extension = s.RepeatedSfixed32Extension
	res.RepeatedSfixed64Extension = s.RepeatedSfixed64Extension
	res.RepeatedFloatExtension = s.RepeatedFloatExtension
	res.RepeatedDoubleExtension = s.RepeatedDoubleExtension
	res.RepeatedBoolExtension = s.RepeatedBoolExtension
	res.RepeatedStringExtension = s.RepeatedStringExtension
	res.RepeatedBytesExtension = s.RepeatedBytesExtension
	res.RepeatedNestedMessageExtension = make([]*TestAllTypes_NestedMessage, len(s.RepeatedNestedMessageExtension))
	for i := range s.RepeatedNestedMessageExtension {
		if s.RepeatedNestedMessageExtension[i] != nil {
			res.RepeatedNestedMessageExtension[i] = s.RepeatedNestedMessageExtension[i].Copy()
		}
	}
	res.RepeatedForeignMessageExtension = make([]*ForeignMessage, len(s.RepeatedForeignMessageExtension))
	for i := range s.RepeatedForeignMessageExtension {
		if s.RepeatedForeignMessageExtension[i] != nil {
			res.RepeatedForeignMessageExtension[i] = s.RepeatedForeignMessageExtension[i].Copy()
		}
	}
	res.RepeatedImportMessageExtension = make([]*protobuf_unittest_import.ImportMessage, len(s.RepeatedImportMessageExtension))
	for i := range s.RepeatedImportMessageExtension {
		if s.RepeatedImportMessageExtension[i] != nil {
			res.RepeatedImportMessageExtension[i] = s.RepeatedImportMessageExtension[i].Copy()
		}
	}
	res.RepeatedNestedEnumExtension = s.RepeatedNestedEnumExtension
	res.RepeatedForeignEnumExtension = s.RepeatedForeignEnumExtension
	res.RepeatedImportEnumExtension = s.RepeatedImportEnumExtension
	res.RepeatedStringPieceExtension = s.RepeatedStringPieceExtension
	res.RepeatedCordExtension = s.RepeatedCordExtension
	res.RepeatedLazyMessageExtension = make([]*TestAllTypes_NestedMessage, len(s.RepeatedLazyMessageExtension))
	for i := range s.RepeatedLazyMessageExtension {
		if s.RepeatedLazyMessageExtension[i] != nil {
			res.RepeatedLazyMessageExtension[i] = s.RepeatedLazyMessageExtension[i].Copy()
		}
	}
	res.DefaultInt32Extension = s.DefaultInt32Extension
	res.DefaultInt64Extension = s.DefaultInt64Extension
	res.DefaultUint32Extension = s.DefaultUint32Extension
	res.DefaultUint64Extension = s.DefaultUint64Extension
	res.DefaultSint32Extension = s.DefaultSint32Extension
	res.DefaultSint64Extension = s.DefaultSint64Extension
	res.DefaultFixed32Extension = s.DefaultFixed32Extension
	res.DefaultFixed64Extension = s.DefaultFixed64Extension
	res.DefaultSfixed32Extension = s.DefaultSfixed32Extension
	res.DefaultSfixed64Extension = s.DefaultSfixed64Extension
	res.DefaultFloatExtension = s.DefaultFloatExtension
	res.DefaultDoubleExtension = s.DefaultDoubleExtension
	res.DefaultBoolExtension = s.DefaultBoolExtension
	res.DefaultStringExtension = s.DefaultStringExtension
	res.DefaultBytesExtension = s.DefaultBytesExtension
	res.DefaultNestedEnumExtension = s.DefaultNestedEnumExtension
	res.DefaultForeignEnumExtension = s.DefaultForeignEnumExtension
	res.DefaultImportEnumExtension = s.DefaultImportEnumExtension
	res.DefaultStringPieceExtension = s.DefaultStringPieceExtension
	res.DefaultCordExtension = s.DefaultCordExtension
	res.OneofUint32Extension = s.OneofUint32Extension
	if s.OneofNestedMessageExtension != nil {
		res.OneofNestedMessageExtension = s.OneofNestedMessageExtension.Copy()
	}
	res.OneofStringExtension = s.OneofStringExtension
	res.OneofBytesExtension = s.OneofBytesExtension

	return res
}

func (s *TestAllExtensions) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.OptionalInt32Extension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_OptionalInt32Extension) + gremlin.SizeInt32(s.OptionalInt32Extension)
		size += entrySize
	}

	if s.OptionalInt64Extension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_OptionalInt64Extension) + gremlin.SizeInt64(s.OptionalInt64Extension)
		size += entrySize
	}

	if s.OptionalUint32Extension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_OptionalUint32Extension) + gremlin.SizeUint32(s.OptionalUint32Extension)
		size += entrySize
	}

	if s.OptionalUint64Extension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_OptionalUint64Extension) + gremlin.SizeUint64(s.OptionalUint64Extension)
		size += entrySize
	}

	if s.OptionalSint32Extension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_OptionalSint32Extension) + gremlin.SizeSInt32(s.OptionalSint32Extension)
		size += entrySize
	}

	if s.OptionalSint64Extension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_OptionalSint64Extension) + gremlin.SizeSInt64(s.OptionalSint64Extension)
		size += entrySize
	}

	if s.OptionalFixed32Extension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_OptionalFixed32Extension) + gremlin.SizeFixed32(s.OptionalFixed32Extension)
		size += entrySize
	}

	if s.OptionalFixed64Extension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_OptionalFixed64Extension) + gremlin.SizeFixed64(s.OptionalFixed64Extension)
		size += entrySize
	}

	if s.OptionalSfixed32Extension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_OptionalSfixed32Extension) + gremlin.SizeSFixed32(s.OptionalSfixed32Extension)
		size += entrySize
	}

	if s.OptionalSfixed64Extension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_OptionalSfixed64Extension) + gremlin.SizeSFixed64(s.OptionalSfixed64Extension)
		size += entrySize
	}

	if s.OptionalFloatExtension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_OptionalFloatExtension) + gremlin.SizeFloat32(s.OptionalFloatExtension)
		size += entrySize
	}

	if s.OptionalDoubleExtension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_OptionalDoubleExtension) + gremlin.SizeFloat64(s.OptionalDoubleExtension)
		size += entrySize
	}

	if s.OptionalBoolExtension {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_OptionalBoolExtension) + gremlin.SizeBool(s.OptionalBoolExtension)
		size += entrySize
	}

	if s.OptionalStringExtension != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.OptionalStringExtension)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllExtensions_OptionalStringExtension)
		size += entrySize
	}

	if len(s.OptionalBytesExtension) != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeBytes(s.OptionalBytesExtension)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllExtensions_OptionalBytesExtension)
		size += entrySize
	}

	if s.OptionalNestedMessageExtension != nil {
		var entrySize = 0
		entrySize = s.OptionalNestedMessageExtension.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllExtensions_OptionalNestedMessageExtension)
		
		size += entrySize
	}

	if s.OptionalForeignMessageExtension != nil {
		var entrySize = 0
		entrySize = s.OptionalForeignMessageExtension.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllExtensions_OptionalForeignMessageExtension)
		
		size += entrySize
	}

	if s.OptionalImportMessageExtension != nil {
		var entrySize = 0
		entrySize = s.OptionalImportMessageExtension.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllExtensions_OptionalImportMessageExtension)
		
		size += entrySize
	}

	if s.OptionalNestedEnumExtension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_OptionalNestedEnumExtension) + gremlin.SizeInt32(int32(s.OptionalNestedEnumExtension))
		size += entrySize
	}

	if s.OptionalForeignEnumExtension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_OptionalForeignEnumExtension) + gremlin.SizeInt32(int32(s.OptionalForeignEnumExtension))
		size += entrySize
	}

	if s.OptionalImportEnumExtension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_OptionalImportEnumExtension) + gremlin.SizeInt32(int32(s.OptionalImportEnumExtension))
		size += entrySize
	}

	if s.OptionalStringPieceExtension != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.OptionalStringPieceExtension)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllExtensions_OptionalStringPieceExtension)
		size += entrySize
	}

	if s.OptionalCordExtension != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.OptionalCordExtension)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllExtensions_OptionalCordExtension)
		size += entrySize
	}

	if s.OptionalPublicImportMessageExtension != nil {
		var entrySize = 0
		entrySize = s.OptionalPublicImportMessageExtension.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllExtensions_OptionalPublicImportMessageExtension)
		
		size += entrySize
	}

	if s.OptionalLazyMessageExtension != nil {
		var entrySize = 0
		entrySize = s.OptionalLazyMessageExtension.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllExtensions_OptionalLazyMessageExtension)
		
		size += entrySize
	}

	if s.OptionalUnverifiedLazyMessageExtension != nil {
		var entrySize = 0
		entrySize = s.OptionalUnverifiedLazyMessageExtension.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllExtensions_OptionalUnverifiedLazyMessageExtension)
		
		size += entrySize
	}

	if len(s.RepeatedInt32Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedInt32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedInt32Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedInt32Extension) + listBytesSize
		} else if len(s.RepeatedInt32Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllExtensions_RepeatedInt32Extension) + gremlin.SizeInt32(s.RepeatedInt32Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedInt64Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedInt64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedInt64Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedInt64Extension) + listBytesSize
		} else if len(s.RepeatedInt64Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllExtensions_RepeatedInt64Extension) + gremlin.SizeInt64(s.RepeatedInt64Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedUint32Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedUint32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedUint32Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeUint32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedUint32Extension) + listBytesSize
		} else if len(s.RepeatedUint32Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllExtensions_RepeatedUint32Extension) + gremlin.SizeUint32(s.RepeatedUint32Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedUint64Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedUint64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedUint64Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeUint64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedUint64Extension) + listBytesSize
		} else if len(s.RepeatedUint64Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllExtensions_RepeatedUint64Extension) + gremlin.SizeUint64(s.RepeatedUint64Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedSint32Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedSint32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedSint32Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSInt32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedSint32Extension) + listBytesSize
		} else if len(s.RepeatedSint32Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllExtensions_RepeatedSint32Extension) + gremlin.SizeSInt32(s.RepeatedSint32Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedSint64Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedSint64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedSint64Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSInt64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedSint64Extension) + listBytesSize
		} else if len(s.RepeatedSint64Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllExtensions_RepeatedSint64Extension) + gremlin.SizeSInt64(s.RepeatedSint64Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedFixed32Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedFixed32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedFixed32Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFixed32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedFixed32Extension) + listBytesSize
		} else if len(s.RepeatedFixed32Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllExtensions_RepeatedFixed32Extension) + gremlin.SizeFixed32(s.RepeatedFixed32Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedFixed64Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedFixed64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedFixed64Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFixed64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedFixed64Extension) + listBytesSize
		} else if len(s.RepeatedFixed64Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllExtensions_RepeatedFixed64Extension) + gremlin.SizeFixed64(s.RepeatedFixed64Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedSfixed32Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedSfixed32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedSfixed32Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSFixed32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedSfixed32Extension) + listBytesSize
		} else if len(s.RepeatedSfixed32Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllExtensions_RepeatedSfixed32Extension) + gremlin.SizeSFixed32(s.RepeatedSfixed32Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedSfixed64Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedSfixed64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedSfixed64Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSFixed64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedSfixed64Extension) + listBytesSize
		} else if len(s.RepeatedSfixed64Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllExtensions_RepeatedSfixed64Extension) + gremlin.SizeSFixed64(s.RepeatedSfixed64Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedFloatExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedFloatExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedFloatExtension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFloat32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedFloatExtension) + listBytesSize
		} else if len(s.RepeatedFloatExtension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllExtensions_RepeatedFloatExtension) + gremlin.SizeFloat32(s.RepeatedFloatExtension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedDoubleExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedDoubleExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedDoubleExtension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFloat64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedDoubleExtension) + listBytesSize
		} else if len(s.RepeatedDoubleExtension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllExtensions_RepeatedDoubleExtension) + gremlin.SizeFloat64(s.RepeatedDoubleExtension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedBoolExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedBoolExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedBoolExtension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeBool(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedBoolExtension) + listBytesSize
		} else if len(s.RepeatedBoolExtension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllExtensions_RepeatedBoolExtension) + gremlin.SizeBool(s.RepeatedBoolExtension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedStringExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedStringExtension {
			var listEntrySize int
			listEntrySize = gremlin.SizeString(val)
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedStringExtension)
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedBytesExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedBytesExtension {
			var listEntrySize int
			listEntrySize = gremlin.SizeBytes(val)
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedBytesExtension)
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedNestedMessageExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedNestedMessageExtension {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedNestedMessageExtension)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedForeignMessageExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedForeignMessageExtension {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedForeignMessageExtension)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedImportMessageExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedImportMessageExtension {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedImportMessageExtension)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedNestedEnumExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedNestedEnumExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedNestedEnumExtension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(int32(entry))
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedNestedEnumExtension) + listBytesSize
		} else if len(s.RepeatedNestedEnumExtension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllExtensions_RepeatedNestedEnumExtension) + gremlin.SizeInt32(int32(s.RepeatedNestedEnumExtension[0]))
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedForeignEnumExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedForeignEnumExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedForeignEnumExtension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(int32(entry))
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedForeignEnumExtension) + listBytesSize
		} else if len(s.RepeatedForeignEnumExtension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllExtensions_RepeatedForeignEnumExtension) + gremlin.SizeInt32(int32(s.RepeatedForeignEnumExtension[0]))
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedImportEnumExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedImportEnumExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedImportEnumExtension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(int32(entry))
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedImportEnumExtension) + listBytesSize
		} else if len(s.RepeatedImportEnumExtension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestAllExtensions_RepeatedImportEnumExtension) + gremlin.SizeInt32(int32(s.RepeatedImportEnumExtension[0]))
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedStringPieceExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedStringPieceExtension {
			var listEntrySize int
			listEntrySize = gremlin.SizeString(val)
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedStringPieceExtension)
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedCordExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedCordExtension {
			var listEntrySize int
			listEntrySize = gremlin.SizeString(val)
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedCordExtension)
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedLazyMessageExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedLazyMessageExtension {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestAllExtensions_RepeatedLazyMessageExtension)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if s.DefaultInt32Extension != 41 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_DefaultInt32Extension) + gremlin.SizeInt32(s.DefaultInt32Extension)
		size += entrySize
	}

	if s.DefaultInt64Extension != 42 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_DefaultInt64Extension) + gremlin.SizeInt64(s.DefaultInt64Extension)
		size += entrySize
	}

	if s.DefaultUint32Extension != 43 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_DefaultUint32Extension) + gremlin.SizeUint32(s.DefaultUint32Extension)
		size += entrySize
	}

	if s.DefaultUint64Extension != 44 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_DefaultUint64Extension) + gremlin.SizeUint64(s.DefaultUint64Extension)
		size += entrySize
	}

	if s.DefaultSint32Extension != -45 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_DefaultSint32Extension) + gremlin.SizeSInt32(s.DefaultSint32Extension)
		size += entrySize
	}

	if s.DefaultSint64Extension != 46 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_DefaultSint64Extension) + gremlin.SizeSInt64(s.DefaultSint64Extension)
		size += entrySize
	}

	if s.DefaultFixed32Extension != 47 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_DefaultFixed32Extension) + gremlin.SizeFixed32(s.DefaultFixed32Extension)
		size += entrySize
	}

	if s.DefaultFixed64Extension != 48 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_DefaultFixed64Extension) + gremlin.SizeFixed64(s.DefaultFixed64Extension)
		size += entrySize
	}

	if s.DefaultSfixed32Extension != 49 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_DefaultSfixed32Extension) + gremlin.SizeSFixed32(s.DefaultSfixed32Extension)
		size += entrySize
	}

	if s.DefaultSfixed64Extension != -50 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_DefaultSfixed64Extension) + gremlin.SizeSFixed64(s.DefaultSfixed64Extension)
		size += entrySize
	}

	if s.DefaultFloatExtension != 51.5 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_DefaultFloatExtension) + gremlin.SizeFloat32(s.DefaultFloatExtension)
		size += entrySize
	}

	if s.DefaultDoubleExtension != 52e3 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_DefaultDoubleExtension) + gremlin.SizeFloat64(s.DefaultDoubleExtension)
		size += entrySize
	}

	if s.DefaultBoolExtension != true {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_DefaultBoolExtension) + gremlin.SizeBool(s.DefaultBoolExtension)
		size += entrySize
	}

	if s.DefaultStringExtension != "hello" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.DefaultStringExtension)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllExtensions_DefaultStringExtension)
		size += entrySize
	}

	if !bytes.Equal(s.DefaultBytesExtension, []byte("world")) {
		var entrySize = 0
		entrySize = gremlin.SizeBytes(s.DefaultBytesExtension)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllExtensions_DefaultBytesExtension)
		size += entrySize
	}

	if s.DefaultNestedEnumExtension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_DefaultNestedEnumExtension) + gremlin.SizeInt32(int32(s.DefaultNestedEnumExtension))
		size += entrySize
	}

	if s.DefaultForeignEnumExtension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_DefaultForeignEnumExtension) + gremlin.SizeInt32(int32(s.DefaultForeignEnumExtension))
		size += entrySize
	}

	if s.DefaultImportEnumExtension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_DefaultImportEnumExtension) + gremlin.SizeInt32(int32(s.DefaultImportEnumExtension))
		size += entrySize
	}

	if s.DefaultStringPieceExtension != "abc" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.DefaultStringPieceExtension)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllExtensions_DefaultStringPieceExtension)
		size += entrySize
	}

	if s.DefaultCordExtension != "123" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.DefaultCordExtension)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllExtensions_DefaultCordExtension)
		size += entrySize
	}

	if s.OneofUint32Extension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestAllExtensions_OneofUint32Extension) + gremlin.SizeUint32(s.OneofUint32Extension)
		size += entrySize
	}

	if s.OneofNestedMessageExtension != nil {
		var entrySize = 0
		entrySize = s.OneofNestedMessageExtension.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllExtensions_OneofNestedMessageExtension)
		
		size += entrySize
	}

	if s.OneofStringExtension != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.OneofStringExtension)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllExtensions_OneofStringExtension)
		size += entrySize
	}

	if len(s.OneofBytesExtension) != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeBytes(s.OneofBytesExtension)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestAllExtensions_OneofBytesExtension)
		size += entrySize
	}

	return size
}

const (
)

type TestNestedExtensionReader struct {
	buf *gremlin.Reader



}

func NewTestNestedExtensionReader() *TestNestedExtensionReader {
	return &TestNestedExtensionReader{}
}

func (m *TestNestedExtensionReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestNestedExtensionReader) ToStruct() *TestNestedExtension {
	if m == nil {
		return nil
	}
	res := &TestNestedExtension{}

	return res
}

func (s *TestNestedExtensionReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestNestedExtension struct {
}

func (s *TestNestedExtension) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestNestedExtension) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

}

func (s *TestNestedExtension) Copy() *TestNestedExtension {
	if s == nil {
		return nil
	}
	res := &TestNestedExtension{}

	return res
}

func (s *TestNestedExtension) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	return size
}

const (
	wireTestNestedExtension_TestAllExtensions_Test gremlin.ProtoWireNumber = 1002
	wireTestNestedExtension_TestAllExtensions_NestedStringExtension gremlin.ProtoWireNumber = 1003
)

type TestNestedExtension_TestAllExtensionsReader struct {
	buf *gremlin.Reader

	dataTest     string
	dataNestedStringExtension     string

	offsetTest   int
	offsetNestedStringExtension   int

	parsedTest   bool
	parsedNestedStringExtension   bool
}

func NewTestNestedExtension_TestAllExtensionsReader() *TestNestedExtension_TestAllExtensionsReader {
	return &TestNestedExtension_TestAllExtensionsReader{}
}

func (m *TestNestedExtension_TestAllExtensionsReader) GetTest() string {
	if m == nil {
		return "test"
	}
	return m.readTest()
}

func (m *TestNestedExtension_TestAllExtensionsReader) readTest() string {
	if m.parsedTest {
		return m.dataTest
	}
	wOffset := m.offsetTest
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	} else {
		entry = "test"
	}
	
	m.dataTest = entry
	m.parsedTest = true
	return entry
}

func (m *TestNestedExtension_TestAllExtensionsReader) GetNestedStringExtension() string {
	if m == nil {
		return ""
	}
	return m.readNestedStringExtension()
}

func (m *TestNestedExtension_TestAllExtensionsReader) readNestedStringExtension() string {
	if m.parsedNestedStringExtension {
		return m.dataNestedStringExtension
	}
	wOffset := m.offsetNestedStringExtension
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataNestedStringExtension = entry
	m.parsedNestedStringExtension = true
	return entry
}

func (m *TestNestedExtension_TestAllExtensionsReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestNestedExtension_TestAllExtensions_Test:
			m.offsetTest = offset
		case wireTestNestedExtension_TestAllExtensions_NestedStringExtension:
			m.offsetNestedStringExtension = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestNestedExtension_TestAllExtensionsReader) ToStruct() *TestNestedExtension_TestAllExtensions {
	if m == nil {
		return nil
	}
	res := &TestNestedExtension_TestAllExtensions{}
	res.Test = m.GetTest()
	res.NestedStringExtension = m.GetNestedStringExtension()

	return res
}

func (s *TestNestedExtension_TestAllExtensionsReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestNestedExtension_TestAllExtensions struct {
	Test	string	`json:"test,omitempty"`
	NestedStringExtension	string	`json:"nested_string_extension,omitempty"`
}

func (s *TestNestedExtension_TestAllExtensions) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestNestedExtension_TestAllExtensions) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Test != "test" {
		res.AppendString(wireTestNestedExtension_TestAllExtensions_Test, s.Test)
	}
	if s.NestedStringExtension != "" {
		res.AppendString(wireTestNestedExtension_TestAllExtensions_NestedStringExtension, s.NestedStringExtension)
	}
}

func (s *TestNestedExtension_TestAllExtensions) Copy() *TestNestedExtension_TestAllExtensions {
	if s == nil {
		return nil
	}
	res := &TestNestedExtension_TestAllExtensions{}
	res.Test = s.Test
	res.NestedStringExtension = s.NestedStringExtension

	return res
}

func (s *TestNestedExtension_TestAllExtensions) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Test != "test" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Test)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestNestedExtension_TestAllExtensions_Test)
		size += entrySize
	}

	if s.NestedStringExtension != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.NestedStringExtension)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestNestedExtension_TestAllExtensions_NestedStringExtension)
		size += entrySize
	}

	return size
}

const (
	wireTestChildExtension_A gremlin.ProtoWireNumber = 1
	wireTestChildExtension_B gremlin.ProtoWireNumber = 2
	wireTestChildExtension_OptionalExtension gremlin.ProtoWireNumber = 3
)

type TestChildExtensionReader struct {
	buf *gremlin.Reader

	dataA     string
	dataB     string
	dataOptionalExtension     *TestAllExtensionsReader

	offsetA   int
	offsetB   int
	offsetOptionalExtension   int

	parsedA   bool
	parsedB   bool
	parsedOptionalExtension   bool
}

func NewTestChildExtensionReader() *TestChildExtensionReader {
	return &TestChildExtensionReader{}
}

func (m *TestChildExtensionReader) GetA() string {
	if m == nil {
		return ""
	}
	return m.readA()
}

func (m *TestChildExtensionReader) readA() string {
	if m.parsedA {
		return m.dataA
	}
	wOffset := m.offsetA
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataA = entry
	m.parsedA = true
	return entry
}

func (m *TestChildExtensionReader) GetB() string {
	if m == nil {
		return ""
	}
	return m.readB()
}

func (m *TestChildExtensionReader) readB() string {
	if m.parsedB {
		return m.dataB
	}
	wOffset := m.offsetB
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataB = entry
	m.parsedB = true
	return entry
}

func (m *TestChildExtensionReader) GetOptionalExtension() *TestAllExtensionsReader {
	if m == nil {
		return nil
	}
	return m.readOptionalExtension()
}

func (m *TestChildExtensionReader) readOptionalExtension() *TestAllExtensionsReader {
	if m.parsedOptionalExtension {
		return m.dataOptionalExtension
	}
	wOffset := m.offsetOptionalExtension
	
	var entry *TestAllExtensionsReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllExtensionsReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalExtension = entry
	m.parsedOptionalExtension = true
	return entry
}

func (m *TestChildExtensionReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestChildExtension_A:
			m.offsetA = offset
		case wireTestChildExtension_B:
			m.offsetB = offset
		case wireTestChildExtension_OptionalExtension:
			m.offsetOptionalExtension = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestChildExtensionReader) ToStruct() *TestChildExtension {
	if m == nil {
		return nil
	}
	res := &TestChildExtension{}
	res.A = m.GetA()
	res.B = m.GetB()

	{
		var data = m.GetOptionalExtension()
		var structData *TestAllExtensions
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalExtension = structData
	}

	return res
}

func (s *TestChildExtensionReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestChildExtension struct {
	A	string	`json:"a,omitempty"`
	B	string	`json:"b,omitempty"`
	OptionalExtension	*TestAllExtensions	`json:"optional_extension,omitempty"`
}

func (s *TestChildExtension) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestChildExtension) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.A != "" {
		res.AppendString(wireTestChildExtension_A, s.A)
	}
	if s.B != "" {
		res.AppendString(wireTestChildExtension_B, s.B)
	}
	if s.OptionalExtension != nil {
		structSize := s.OptionalExtension.XXX_PbContentSize()
		res.AppendBytesTag(wireTestChildExtension_OptionalExtension, structSize)
		s.OptionalExtension.MarshalTo(res)
	}
}

func (s *TestChildExtension) Copy() *TestChildExtension {
	if s == nil {
		return nil
	}
	res := &TestChildExtension{}
	res.A = s.A
	res.B = s.B
	if s.OptionalExtension != nil {
		res.OptionalExtension = s.OptionalExtension.Copy()
	}

	return res
}

func (s *TestChildExtension) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.A != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.A)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestChildExtension_A)
		size += entrySize
	}

	if s.B != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.B)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestChildExtension_B)
		size += entrySize
	}

	if s.OptionalExtension != nil {
		var entrySize = 0
		entrySize = s.OptionalExtension.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestChildExtension_OptionalExtension)
		
		size += entrySize
	}

	return size
}

const (
	wireTestChildExtensionData_A gremlin.ProtoWireNumber = 1
	wireTestChildExtensionData_B gremlin.ProtoWireNumber = 2
	wireTestChildExtensionData_OptionalExtension gremlin.ProtoWireNumber = 3
)

type TestChildExtensionDataReader struct {
	buf *gremlin.Reader

	dataA     string
	dataB     string
	dataOptionalExtension     *TestChildExtensionData_NestedTestAllExtensionsDataReader

	offsetA   int
	offsetB   int
	offsetOptionalExtension   int

	parsedA   bool
	parsedB   bool
	parsedOptionalExtension   bool
}

func NewTestChildExtensionDataReader() *TestChildExtensionDataReader {
	return &TestChildExtensionDataReader{}
}

func (m *TestChildExtensionDataReader) GetA() string {
	if m == nil {
		return ""
	}
	return m.readA()
}

func (m *TestChildExtensionDataReader) readA() string {
	if m.parsedA {
		return m.dataA
	}
	wOffset := m.offsetA
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataA = entry
	m.parsedA = true
	return entry
}

func (m *TestChildExtensionDataReader) GetB() string {
	if m == nil {
		return ""
	}
	return m.readB()
}

func (m *TestChildExtensionDataReader) readB() string {
	if m.parsedB {
		return m.dataB
	}
	wOffset := m.offsetB
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataB = entry
	m.parsedB = true
	return entry
}

func (m *TestChildExtensionDataReader) GetOptionalExtension() *TestChildExtensionData_NestedTestAllExtensionsDataReader {
	if m == nil {
		return nil
	}
	return m.readOptionalExtension()
}

func (m *TestChildExtensionDataReader) readOptionalExtension() *TestChildExtensionData_NestedTestAllExtensionsDataReader {
	if m.parsedOptionalExtension {
		return m.dataOptionalExtension
	}
	wOffset := m.offsetOptionalExtension
	
	var entry *TestChildExtensionData_NestedTestAllExtensionsDataReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestChildExtensionData_NestedTestAllExtensionsDataReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalExtension = entry
	m.parsedOptionalExtension = true
	return entry
}

func (m *TestChildExtensionDataReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestChildExtensionData_A:
			m.offsetA = offset
		case wireTestChildExtensionData_B:
			m.offsetB = offset
		case wireTestChildExtensionData_OptionalExtension:
			m.offsetOptionalExtension = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestChildExtensionDataReader) ToStruct() *TestChildExtensionData {
	if m == nil {
		return nil
	}
	res := &TestChildExtensionData{}
	res.A = m.GetA()
	res.B = m.GetB()

	{
		var data = m.GetOptionalExtension()
		var structData *TestChildExtensionData_NestedTestAllExtensionsData
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalExtension = structData
	}

	return res
}

func (s *TestChildExtensionDataReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestChildExtensionData struct {
	A	string	`json:"a,omitempty"`
	B	string	`json:"b,omitempty"`
	OptionalExtension	*TestChildExtensionData_NestedTestAllExtensionsData	`json:"optional_extension,omitempty"`
}

func (s *TestChildExtensionData) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestChildExtensionData) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.A != "" {
		res.AppendString(wireTestChildExtensionData_A, s.A)
	}
	if s.B != "" {
		res.AppendString(wireTestChildExtensionData_B, s.B)
	}
	if s.OptionalExtension != nil {
		structSize := s.OptionalExtension.XXX_PbContentSize()
		res.AppendBytesTag(wireTestChildExtensionData_OptionalExtension, structSize)
		s.OptionalExtension.MarshalTo(res)
	}
}

func (s *TestChildExtensionData) Copy() *TestChildExtensionData {
	if s == nil {
		return nil
	}
	res := &TestChildExtensionData{}
	res.A = s.A
	res.B = s.B
	if s.OptionalExtension != nil {
		res.OptionalExtension = s.OptionalExtension.Copy()
	}

	return res
}

func (s *TestChildExtensionData) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.A != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.A)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestChildExtensionData_A)
		size += entrySize
	}

	if s.B != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.B)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestChildExtensionData_B)
		size += entrySize
	}

	if s.OptionalExtension != nil {
		var entrySize = 0
		entrySize = s.OptionalExtension.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestChildExtensionData_OptionalExtension)
		
		size += entrySize
	}

	return size
}

const (
	wireTestChildExtensionData_NestedTestAllExtensionsData_Dynamic gremlin.ProtoWireNumber = 409707008
)

type TestChildExtensionData_NestedTestAllExtensionsDataReader struct {
	buf *gremlin.Reader

	dataDynamic     *TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensionsReader

	offsetDynamic   int

	parsedDynamic   bool
}

func NewTestChildExtensionData_NestedTestAllExtensionsDataReader() *TestChildExtensionData_NestedTestAllExtensionsDataReader {
	return &TestChildExtensionData_NestedTestAllExtensionsDataReader{}
}

func (m *TestChildExtensionData_NestedTestAllExtensionsDataReader) GetDynamic() *TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensionsReader {
	if m == nil {
		return nil
	}
	return m.readDynamic()
}

func (m *TestChildExtensionData_NestedTestAllExtensionsDataReader) readDynamic() *TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensionsReader {
	if m.parsedDynamic {
		return m.dataDynamic
	}
	wOffset := m.offsetDynamic
	
	var entry *TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensionsReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensionsReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataDynamic = entry
	m.parsedDynamic = true
	return entry
}

func (m *TestChildExtensionData_NestedTestAllExtensionsDataReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestChildExtensionData_NestedTestAllExtensionsData_Dynamic:
			m.offsetDynamic = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestChildExtensionData_NestedTestAllExtensionsDataReader) ToStruct() *TestChildExtensionData_NestedTestAllExtensionsData {
	if m == nil {
		return nil
	}
	res := &TestChildExtensionData_NestedTestAllExtensionsData{}

	{
		var data = m.GetDynamic()
		var structData *TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions
		if data != nil {
			structData = data.ToStruct()
		}
		res.Dynamic = structData
	}

	return res
}

func (s *TestChildExtensionData_NestedTestAllExtensionsDataReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestChildExtensionData_NestedTestAllExtensionsData struct {
	Dynamic	*TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions	`json:"dynamic,omitempty"`
}

func (s *TestChildExtensionData_NestedTestAllExtensionsData) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestChildExtensionData_NestedTestAllExtensionsData) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Dynamic != nil {
		structSize := s.Dynamic.XXX_PbContentSize()
		res.AppendBytesTag(wireTestChildExtensionData_NestedTestAllExtensionsData_Dynamic, structSize)
		s.Dynamic.MarshalTo(res)
	}
}

func (s *TestChildExtensionData_NestedTestAllExtensionsData) Copy() *TestChildExtensionData_NestedTestAllExtensionsData {
	if s == nil {
		return nil
	}
	res := &TestChildExtensionData_NestedTestAllExtensionsData{}
	if s.Dynamic != nil {
		res.Dynamic = s.Dynamic.Copy()
	}

	return res
}

func (s *TestChildExtensionData_NestedTestAllExtensionsData) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Dynamic != nil {
		var entrySize = 0
		entrySize = s.Dynamic.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestChildExtensionData_NestedTestAllExtensionsData_Dynamic)
		
		size += entrySize
	}

	return size
}

const (
	wireTestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions_A gremlin.ProtoWireNumber = 1
	wireTestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions_B gremlin.ProtoWireNumber = 2
)

type TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensionsReader struct {
	buf *gremlin.Reader

	dataA     int32
	dataB     int32

	offsetA   int
	offsetB   int

	parsedA   bool
	parsedB   bool
}

func NewTestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensionsReader() *TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensionsReader {
	return &TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensionsReader{}
}

func (m *TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensionsReader) GetA() int32 {
	if m == nil {
		return 0
	}
	return m.readA()
}

func (m *TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensionsReader) readA() int32 {
	if m.parsedA {
		return m.dataA
	}
	wOffset := m.offsetA
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataA = entry
	m.parsedA = true
	return entry
}

func (m *TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensionsReader) GetB() int32 {
	if m == nil {
		return 0
	}
	return m.readB()
}

func (m *TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensionsReader) readB() int32 {
	if m.parsedB {
		return m.dataB
	}
	wOffset := m.offsetB
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataB = entry
	m.parsedB = true
	return entry
}

func (m *TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensionsReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions_A:
			m.offsetA = offset
		case wireTestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions_B:
			m.offsetB = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensionsReader) ToStruct() *TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions {
	if m == nil {
		return nil
	}
	res := &TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions{}
	res.A = m.GetA()
	res.B = m.GetB()

	return res
}

func (s *TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensionsReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions struct {
	A	int32	`json:"a,omitempty"`
	B	int32	`json:"b,omitempty"`
}

func (s *TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.A != 0 {
		res.AppendInt32(wireTestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions_A, s.A)
	}
	if s.B != 0 {
		res.AppendInt32(wireTestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions_B, s.B)
	}
}

func (s *TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions) Copy() *TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions {
	if s == nil {
		return nil
	}
	res := &TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions{}
	res.A = s.A
	res.B = s.B

	return res
}

func (s *TestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.A != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions_A) + gremlin.SizeInt32(s.A)
		size += entrySize
	}

	if s.B != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestChildExtensionData_NestedTestAllExtensionsData_NestedDynamicExtensions_B) + gremlin.SizeInt32(s.B)
		size += entrySize
	}

	return size
}

const (
	wireTestNestedChildExtension_A gremlin.ProtoWireNumber = 1
	wireTestNestedChildExtension_Child gremlin.ProtoWireNumber = 2
)

type TestNestedChildExtensionReader struct {
	buf *gremlin.Reader

	dataA     int32
	dataChild     *TestChildExtensionReader

	offsetA   int
	offsetChild   int

	parsedA   bool
	parsedChild   bool
}

func NewTestNestedChildExtensionReader() *TestNestedChildExtensionReader {
	return &TestNestedChildExtensionReader{}
}

func (m *TestNestedChildExtensionReader) GetA() int32 {
	if m == nil {
		return 0
	}
	return m.readA()
}

func (m *TestNestedChildExtensionReader) readA() int32 {
	if m.parsedA {
		return m.dataA
	}
	wOffset := m.offsetA
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataA = entry
	m.parsedA = true
	return entry
}

func (m *TestNestedChildExtensionReader) GetChild() *TestChildExtensionReader {
	if m == nil {
		return nil
	}
	return m.readChild()
}

func (m *TestNestedChildExtensionReader) readChild() *TestChildExtensionReader {
	if m.parsedChild {
		return m.dataChild
	}
	wOffset := m.offsetChild
	
	var entry *TestChildExtensionReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestChildExtensionReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataChild = entry
	m.parsedChild = true
	return entry
}

func (m *TestNestedChildExtensionReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestNestedChildExtension_A:
			m.offsetA = offset
		case wireTestNestedChildExtension_Child:
			m.offsetChild = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestNestedChildExtensionReader) ToStruct() *TestNestedChildExtension {
	if m == nil {
		return nil
	}
	res := &TestNestedChildExtension{}
	res.A = m.GetA()

	{
		var data = m.GetChild()
		var structData *TestChildExtension
		if data != nil {
			structData = data.ToStruct()
		}
		res.Child = structData
	}

	return res
}

func (s *TestNestedChildExtensionReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestNestedChildExtension struct {
	A	int32	`json:"a,omitempty"`
	Child	*TestChildExtension	`json:"child,omitempty"`
}

func (s *TestNestedChildExtension) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestNestedChildExtension) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.A != 0 {
		res.AppendInt32(wireTestNestedChildExtension_A, s.A)
	}
	if s.Child != nil {
		structSize := s.Child.XXX_PbContentSize()
		res.AppendBytesTag(wireTestNestedChildExtension_Child, structSize)
		s.Child.MarshalTo(res)
	}
}

func (s *TestNestedChildExtension) Copy() *TestNestedChildExtension {
	if s == nil {
		return nil
	}
	res := &TestNestedChildExtension{}
	res.A = s.A
	if s.Child != nil {
		res.Child = s.Child.Copy()
	}

	return res
}

func (s *TestNestedChildExtension) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.A != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestNestedChildExtension_A) + gremlin.SizeInt32(s.A)
		size += entrySize
	}

	if s.Child != nil {
		var entrySize = 0
		entrySize = s.Child.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestNestedChildExtension_Child)
		
		size += entrySize
	}

	return size
}

const (
	wireTestNestedChildExtensionData_A gremlin.ProtoWireNumber = 1
	wireTestNestedChildExtensionData_Child gremlin.ProtoWireNumber = 2
)

type TestNestedChildExtensionDataReader struct {
	buf *gremlin.Reader

	dataA     int32
	dataChild     *TestChildExtensionDataReader

	offsetA   int
	offsetChild   int

	parsedA   bool
	parsedChild   bool
}

func NewTestNestedChildExtensionDataReader() *TestNestedChildExtensionDataReader {
	return &TestNestedChildExtensionDataReader{}
}

func (m *TestNestedChildExtensionDataReader) GetA() int32 {
	if m == nil {
		return 0
	}
	return m.readA()
}

func (m *TestNestedChildExtensionDataReader) readA() int32 {
	if m.parsedA {
		return m.dataA
	}
	wOffset := m.offsetA
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataA = entry
	m.parsedA = true
	return entry
}

func (m *TestNestedChildExtensionDataReader) GetChild() *TestChildExtensionDataReader {
	if m == nil {
		return nil
	}
	return m.readChild()
}

func (m *TestNestedChildExtensionDataReader) readChild() *TestChildExtensionDataReader {
	if m.parsedChild {
		return m.dataChild
	}
	wOffset := m.offsetChild
	
	var entry *TestChildExtensionDataReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestChildExtensionDataReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataChild = entry
	m.parsedChild = true
	return entry
}

func (m *TestNestedChildExtensionDataReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestNestedChildExtensionData_A:
			m.offsetA = offset
		case wireTestNestedChildExtensionData_Child:
			m.offsetChild = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestNestedChildExtensionDataReader) ToStruct() *TestNestedChildExtensionData {
	if m == nil {
		return nil
	}
	res := &TestNestedChildExtensionData{}
	res.A = m.GetA()

	{
		var data = m.GetChild()
		var structData *TestChildExtensionData
		if data != nil {
			structData = data.ToStruct()
		}
		res.Child = structData
	}

	return res
}

func (s *TestNestedChildExtensionDataReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestNestedChildExtensionData struct {
	A	int32	`json:"a,omitempty"`
	Child	*TestChildExtensionData	`json:"child,omitempty"`
}

func (s *TestNestedChildExtensionData) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestNestedChildExtensionData) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.A != 0 {
		res.AppendInt32(wireTestNestedChildExtensionData_A, s.A)
	}
	if s.Child != nil {
		structSize := s.Child.XXX_PbContentSize()
		res.AppendBytesTag(wireTestNestedChildExtensionData_Child, structSize)
		s.Child.MarshalTo(res)
	}
}

func (s *TestNestedChildExtensionData) Copy() *TestNestedChildExtensionData {
	if s == nil {
		return nil
	}
	res := &TestNestedChildExtensionData{}
	res.A = s.A
	if s.Child != nil {
		res.Child = s.Child.Copy()
	}

	return res
}

func (s *TestNestedChildExtensionData) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.A != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestNestedChildExtensionData_A) + gremlin.SizeInt32(s.A)
		size += entrySize
	}

	if s.Child != nil {
		var entrySize = 0
		entrySize = s.Child.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestNestedChildExtensionData_Child)
		
		size += entrySize
	}

	return size
}

const (
	wireTestRequired_A gremlin.ProtoWireNumber = 1
	wireTestRequired_Dummy2 gremlin.ProtoWireNumber = 2
	wireTestRequired_B gremlin.ProtoWireNumber = 3
	wireTestRequired_Dummy4 gremlin.ProtoWireNumber = 4
	wireTestRequired_Dummy5 gremlin.ProtoWireNumber = 5
	wireTestRequired_Dummy6 gremlin.ProtoWireNumber = 6
	wireTestRequired_Dummy7 gremlin.ProtoWireNumber = 7
	wireTestRequired_Dummy8 gremlin.ProtoWireNumber = 8
	wireTestRequired_Dummy9 gremlin.ProtoWireNumber = 9
	wireTestRequired_Dummy10 gremlin.ProtoWireNumber = 10
	wireTestRequired_Dummy11 gremlin.ProtoWireNumber = 11
	wireTestRequired_Dummy12 gremlin.ProtoWireNumber = 12
	wireTestRequired_Dummy13 gremlin.ProtoWireNumber = 13
	wireTestRequired_Dummy14 gremlin.ProtoWireNumber = 14
	wireTestRequired_Dummy15 gremlin.ProtoWireNumber = 15
	wireTestRequired_Dummy16 gremlin.ProtoWireNumber = 16
	wireTestRequired_Dummy17 gremlin.ProtoWireNumber = 17
	wireTestRequired_Dummy18 gremlin.ProtoWireNumber = 18
	wireTestRequired_Dummy19 gremlin.ProtoWireNumber = 19
	wireTestRequired_Dummy20 gremlin.ProtoWireNumber = 20
	wireTestRequired_Dummy21 gremlin.ProtoWireNumber = 21
	wireTestRequired_Dummy22 gremlin.ProtoWireNumber = 22
	wireTestRequired_Dummy23 gremlin.ProtoWireNumber = 23
	wireTestRequired_Dummy24 gremlin.ProtoWireNumber = 24
	wireTestRequired_Dummy25 gremlin.ProtoWireNumber = 25
	wireTestRequired_Dummy26 gremlin.ProtoWireNumber = 26
	wireTestRequired_Dummy27 gremlin.ProtoWireNumber = 27
	wireTestRequired_Dummy28 gremlin.ProtoWireNumber = 28
	wireTestRequired_Dummy29 gremlin.ProtoWireNumber = 29
	wireTestRequired_Dummy30 gremlin.ProtoWireNumber = 30
	wireTestRequired_Dummy31 gremlin.ProtoWireNumber = 31
	wireTestRequired_Dummy32 gremlin.ProtoWireNumber = 32
	wireTestRequired_C gremlin.ProtoWireNumber = 33
	wireTestRequired_OptionalForeign gremlin.ProtoWireNumber = 34
)

type TestRequiredReader struct {
	buf *gremlin.Reader

	dataA     int32
	dataDummy2     int32
	dataB     int32
	dataDummy4     int32
	dataDummy5     int32
	dataDummy6     int32
	dataDummy7     int32
	dataDummy8     int32
	dataDummy9     int32
	dataDummy10     int32
	dataDummy11     int32
	dataDummy12     int32
	dataDummy13     int32
	dataDummy14     int32
	dataDummy15     int32
	dataDummy16     int32
	dataDummy17     int32
	dataDummy18     int32
	dataDummy19     int32
	dataDummy20     int32
	dataDummy21     int32
	dataDummy22     int32
	dataDummy23     int32
	dataDummy24     int32
	dataDummy25     int32
	dataDummy26     int32
	dataDummy27     int32
	dataDummy28     int32
	dataDummy29     int32
	dataDummy30     int32
	dataDummy31     int32
	dataDummy32     int32
	dataC     int32
	dataOptionalForeign     *ForeignMessageReader

	offsetA   int
	offsetDummy2   int
	offsetB   int
	offsetDummy4   int
	offsetDummy5   int
	offsetDummy6   int
	offsetDummy7   int
	offsetDummy8   int
	offsetDummy9   int
	offsetDummy10   int
	offsetDummy11   int
	offsetDummy12   int
	offsetDummy13   int
	offsetDummy14   int
	offsetDummy15   int
	offsetDummy16   int
	offsetDummy17   int
	offsetDummy18   int
	offsetDummy19   int
	offsetDummy20   int
	offsetDummy21   int
	offsetDummy22   int
	offsetDummy23   int
	offsetDummy24   int
	offsetDummy25   int
	offsetDummy26   int
	offsetDummy27   int
	offsetDummy28   int
	offsetDummy29   int
	offsetDummy30   int
	offsetDummy31   int
	offsetDummy32   int
	offsetC   int
	offsetOptionalForeign   int

	parsedA   bool
	parsedDummy2   bool
	parsedB   bool
	parsedDummy4   bool
	parsedDummy5   bool
	parsedDummy6   bool
	parsedDummy7   bool
	parsedDummy8   bool
	parsedDummy9   bool
	parsedDummy10   bool
	parsedDummy11   bool
	parsedDummy12   bool
	parsedDummy13   bool
	parsedDummy14   bool
	parsedDummy15   bool
	parsedDummy16   bool
	parsedDummy17   bool
	parsedDummy18   bool
	parsedDummy19   bool
	parsedDummy20   bool
	parsedDummy21   bool
	parsedDummy22   bool
	parsedDummy23   bool
	parsedDummy24   bool
	parsedDummy25   bool
	parsedDummy26   bool
	parsedDummy27   bool
	parsedDummy28   bool
	parsedDummy29   bool
	parsedDummy30   bool
	parsedDummy31   bool
	parsedDummy32   bool
	parsedC   bool
	parsedOptionalForeign   bool
}

func NewTestRequiredReader() *TestRequiredReader {
	return &TestRequiredReader{}
}

func (m *TestRequiredReader) GetA() int32 {
	if m == nil {
		return 0
	}
	return m.readA()
}

func (m *TestRequiredReader) readA() int32 {
	if m.parsedA {
		return m.dataA
	}
	wOffset := m.offsetA
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataA = entry
	m.parsedA = true
	return entry
}

func (m *TestRequiredReader) GetDummy2() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy2()
}

func (m *TestRequiredReader) readDummy2() int32 {
	if m.parsedDummy2 {
		return m.dataDummy2
	}
	wOffset := m.offsetDummy2
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy2 = entry
	m.parsedDummy2 = true
	return entry
}

func (m *TestRequiredReader) GetB() int32 {
	if m == nil {
		return 0
	}
	return m.readB()
}

func (m *TestRequiredReader) readB() int32 {
	if m.parsedB {
		return m.dataB
	}
	wOffset := m.offsetB
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataB = entry
	m.parsedB = true
	return entry
}

func (m *TestRequiredReader) GetDummy4() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy4()
}

func (m *TestRequiredReader) readDummy4() int32 {
	if m.parsedDummy4 {
		return m.dataDummy4
	}
	wOffset := m.offsetDummy4
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy4 = entry
	m.parsedDummy4 = true
	return entry
}

func (m *TestRequiredReader) GetDummy5() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy5()
}

func (m *TestRequiredReader) readDummy5() int32 {
	if m.parsedDummy5 {
		return m.dataDummy5
	}
	wOffset := m.offsetDummy5
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy5 = entry
	m.parsedDummy5 = true
	return entry
}

func (m *TestRequiredReader) GetDummy6() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy6()
}

func (m *TestRequiredReader) readDummy6() int32 {
	if m.parsedDummy6 {
		return m.dataDummy6
	}
	wOffset := m.offsetDummy6
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy6 = entry
	m.parsedDummy6 = true
	return entry
}

func (m *TestRequiredReader) GetDummy7() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy7()
}

func (m *TestRequiredReader) readDummy7() int32 {
	if m.parsedDummy7 {
		return m.dataDummy7
	}
	wOffset := m.offsetDummy7
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy7 = entry
	m.parsedDummy7 = true
	return entry
}

func (m *TestRequiredReader) GetDummy8() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy8()
}

func (m *TestRequiredReader) readDummy8() int32 {
	if m.parsedDummy8 {
		return m.dataDummy8
	}
	wOffset := m.offsetDummy8
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy8 = entry
	m.parsedDummy8 = true
	return entry
}

func (m *TestRequiredReader) GetDummy9() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy9()
}

func (m *TestRequiredReader) readDummy9() int32 {
	if m.parsedDummy9 {
		return m.dataDummy9
	}
	wOffset := m.offsetDummy9
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy9 = entry
	m.parsedDummy9 = true
	return entry
}

func (m *TestRequiredReader) GetDummy10() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy10()
}

func (m *TestRequiredReader) readDummy10() int32 {
	if m.parsedDummy10 {
		return m.dataDummy10
	}
	wOffset := m.offsetDummy10
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy10 = entry
	m.parsedDummy10 = true
	return entry
}

func (m *TestRequiredReader) GetDummy11() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy11()
}

func (m *TestRequiredReader) readDummy11() int32 {
	if m.parsedDummy11 {
		return m.dataDummy11
	}
	wOffset := m.offsetDummy11
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy11 = entry
	m.parsedDummy11 = true
	return entry
}

func (m *TestRequiredReader) GetDummy12() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy12()
}

func (m *TestRequiredReader) readDummy12() int32 {
	if m.parsedDummy12 {
		return m.dataDummy12
	}
	wOffset := m.offsetDummy12
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy12 = entry
	m.parsedDummy12 = true
	return entry
}

func (m *TestRequiredReader) GetDummy13() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy13()
}

func (m *TestRequiredReader) readDummy13() int32 {
	if m.parsedDummy13 {
		return m.dataDummy13
	}
	wOffset := m.offsetDummy13
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy13 = entry
	m.parsedDummy13 = true
	return entry
}

func (m *TestRequiredReader) GetDummy14() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy14()
}

func (m *TestRequiredReader) readDummy14() int32 {
	if m.parsedDummy14 {
		return m.dataDummy14
	}
	wOffset := m.offsetDummy14
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy14 = entry
	m.parsedDummy14 = true
	return entry
}

func (m *TestRequiredReader) GetDummy15() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy15()
}

func (m *TestRequiredReader) readDummy15() int32 {
	if m.parsedDummy15 {
		return m.dataDummy15
	}
	wOffset := m.offsetDummy15
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy15 = entry
	m.parsedDummy15 = true
	return entry
}

func (m *TestRequiredReader) GetDummy16() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy16()
}

func (m *TestRequiredReader) readDummy16() int32 {
	if m.parsedDummy16 {
		return m.dataDummy16
	}
	wOffset := m.offsetDummy16
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy16 = entry
	m.parsedDummy16 = true
	return entry
}

func (m *TestRequiredReader) GetDummy17() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy17()
}

func (m *TestRequiredReader) readDummy17() int32 {
	if m.parsedDummy17 {
		return m.dataDummy17
	}
	wOffset := m.offsetDummy17
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy17 = entry
	m.parsedDummy17 = true
	return entry
}

func (m *TestRequiredReader) GetDummy18() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy18()
}

func (m *TestRequiredReader) readDummy18() int32 {
	if m.parsedDummy18 {
		return m.dataDummy18
	}
	wOffset := m.offsetDummy18
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy18 = entry
	m.parsedDummy18 = true
	return entry
}

func (m *TestRequiredReader) GetDummy19() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy19()
}

func (m *TestRequiredReader) readDummy19() int32 {
	if m.parsedDummy19 {
		return m.dataDummy19
	}
	wOffset := m.offsetDummy19
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy19 = entry
	m.parsedDummy19 = true
	return entry
}

func (m *TestRequiredReader) GetDummy20() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy20()
}

func (m *TestRequiredReader) readDummy20() int32 {
	if m.parsedDummy20 {
		return m.dataDummy20
	}
	wOffset := m.offsetDummy20
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy20 = entry
	m.parsedDummy20 = true
	return entry
}

func (m *TestRequiredReader) GetDummy21() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy21()
}

func (m *TestRequiredReader) readDummy21() int32 {
	if m.parsedDummy21 {
		return m.dataDummy21
	}
	wOffset := m.offsetDummy21
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy21 = entry
	m.parsedDummy21 = true
	return entry
}

func (m *TestRequiredReader) GetDummy22() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy22()
}

func (m *TestRequiredReader) readDummy22() int32 {
	if m.parsedDummy22 {
		return m.dataDummy22
	}
	wOffset := m.offsetDummy22
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy22 = entry
	m.parsedDummy22 = true
	return entry
}

func (m *TestRequiredReader) GetDummy23() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy23()
}

func (m *TestRequiredReader) readDummy23() int32 {
	if m.parsedDummy23 {
		return m.dataDummy23
	}
	wOffset := m.offsetDummy23
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy23 = entry
	m.parsedDummy23 = true
	return entry
}

func (m *TestRequiredReader) GetDummy24() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy24()
}

func (m *TestRequiredReader) readDummy24() int32 {
	if m.parsedDummy24 {
		return m.dataDummy24
	}
	wOffset := m.offsetDummy24
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy24 = entry
	m.parsedDummy24 = true
	return entry
}

func (m *TestRequiredReader) GetDummy25() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy25()
}

func (m *TestRequiredReader) readDummy25() int32 {
	if m.parsedDummy25 {
		return m.dataDummy25
	}
	wOffset := m.offsetDummy25
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy25 = entry
	m.parsedDummy25 = true
	return entry
}

func (m *TestRequiredReader) GetDummy26() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy26()
}

func (m *TestRequiredReader) readDummy26() int32 {
	if m.parsedDummy26 {
		return m.dataDummy26
	}
	wOffset := m.offsetDummy26
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy26 = entry
	m.parsedDummy26 = true
	return entry
}

func (m *TestRequiredReader) GetDummy27() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy27()
}

func (m *TestRequiredReader) readDummy27() int32 {
	if m.parsedDummy27 {
		return m.dataDummy27
	}
	wOffset := m.offsetDummy27
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy27 = entry
	m.parsedDummy27 = true
	return entry
}

func (m *TestRequiredReader) GetDummy28() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy28()
}

func (m *TestRequiredReader) readDummy28() int32 {
	if m.parsedDummy28 {
		return m.dataDummy28
	}
	wOffset := m.offsetDummy28
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy28 = entry
	m.parsedDummy28 = true
	return entry
}

func (m *TestRequiredReader) GetDummy29() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy29()
}

func (m *TestRequiredReader) readDummy29() int32 {
	if m.parsedDummy29 {
		return m.dataDummy29
	}
	wOffset := m.offsetDummy29
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy29 = entry
	m.parsedDummy29 = true
	return entry
}

func (m *TestRequiredReader) GetDummy30() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy30()
}

func (m *TestRequiredReader) readDummy30() int32 {
	if m.parsedDummy30 {
		return m.dataDummy30
	}
	wOffset := m.offsetDummy30
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy30 = entry
	m.parsedDummy30 = true
	return entry
}

func (m *TestRequiredReader) GetDummy31() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy31()
}

func (m *TestRequiredReader) readDummy31() int32 {
	if m.parsedDummy31 {
		return m.dataDummy31
	}
	wOffset := m.offsetDummy31
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy31 = entry
	m.parsedDummy31 = true
	return entry
}

func (m *TestRequiredReader) GetDummy32() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy32()
}

func (m *TestRequiredReader) readDummy32() int32 {
	if m.parsedDummy32 {
		return m.dataDummy32
	}
	wOffset := m.offsetDummy32
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy32 = entry
	m.parsedDummy32 = true
	return entry
}

func (m *TestRequiredReader) GetC() int32 {
	if m == nil {
		return 0
	}
	return m.readC()
}

func (m *TestRequiredReader) readC() int32 {
	if m.parsedC {
		return m.dataC
	}
	wOffset := m.offsetC
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataC = entry
	m.parsedC = true
	return entry
}

func (m *TestRequiredReader) GetOptionalForeign() *ForeignMessageReader {
	if m == nil {
		return nil
	}
	return m.readOptionalForeign()
}

func (m *TestRequiredReader) readOptionalForeign() *ForeignMessageReader {
	if m.parsedOptionalForeign {
		return m.dataOptionalForeign
	}
	wOffset := m.offsetOptionalForeign
	
	var entry *ForeignMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewForeignMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalForeign = entry
	m.parsedOptionalForeign = true
	return entry
}

func (m *TestRequiredReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestRequired_A:
			m.offsetA = offset
		case wireTestRequired_Dummy2:
			m.offsetDummy2 = offset
		case wireTestRequired_B:
			m.offsetB = offset
		case wireTestRequired_Dummy4:
			m.offsetDummy4 = offset
		case wireTestRequired_Dummy5:
			m.offsetDummy5 = offset
		case wireTestRequired_Dummy6:
			m.offsetDummy6 = offset
		case wireTestRequired_Dummy7:
			m.offsetDummy7 = offset
		case wireTestRequired_Dummy8:
			m.offsetDummy8 = offset
		case wireTestRequired_Dummy9:
			m.offsetDummy9 = offset
		case wireTestRequired_Dummy10:
			m.offsetDummy10 = offset
		case wireTestRequired_Dummy11:
			m.offsetDummy11 = offset
		case wireTestRequired_Dummy12:
			m.offsetDummy12 = offset
		case wireTestRequired_Dummy13:
			m.offsetDummy13 = offset
		case wireTestRequired_Dummy14:
			m.offsetDummy14 = offset
		case wireTestRequired_Dummy15:
			m.offsetDummy15 = offset
		case wireTestRequired_Dummy16:
			m.offsetDummy16 = offset
		case wireTestRequired_Dummy17:
			m.offsetDummy17 = offset
		case wireTestRequired_Dummy18:
			m.offsetDummy18 = offset
		case wireTestRequired_Dummy19:
			m.offsetDummy19 = offset
		case wireTestRequired_Dummy20:
			m.offsetDummy20 = offset
		case wireTestRequired_Dummy21:
			m.offsetDummy21 = offset
		case wireTestRequired_Dummy22:
			m.offsetDummy22 = offset
		case wireTestRequired_Dummy23:
			m.offsetDummy23 = offset
		case wireTestRequired_Dummy24:
			m.offsetDummy24 = offset
		case wireTestRequired_Dummy25:
			m.offsetDummy25 = offset
		case wireTestRequired_Dummy26:
			m.offsetDummy26 = offset
		case wireTestRequired_Dummy27:
			m.offsetDummy27 = offset
		case wireTestRequired_Dummy28:
			m.offsetDummy28 = offset
		case wireTestRequired_Dummy29:
			m.offsetDummy29 = offset
		case wireTestRequired_Dummy30:
			m.offsetDummy30 = offset
		case wireTestRequired_Dummy31:
			m.offsetDummy31 = offset
		case wireTestRequired_Dummy32:
			m.offsetDummy32 = offset
		case wireTestRequired_C:
			m.offsetC = offset
		case wireTestRequired_OptionalForeign:
			m.offsetOptionalForeign = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestRequiredReader) ToStruct() *TestRequired {
	if m == nil {
		return nil
	}
	res := &TestRequired{}
	res.A = m.GetA()
	res.Dummy2 = m.GetDummy2()
	res.B = m.GetB()
	res.Dummy4 = m.GetDummy4()
	res.Dummy5 = m.GetDummy5()
	res.Dummy6 = m.GetDummy6()
	res.Dummy7 = m.GetDummy7()
	res.Dummy8 = m.GetDummy8()
	res.Dummy9 = m.GetDummy9()
	res.Dummy10 = m.GetDummy10()
	res.Dummy11 = m.GetDummy11()
	res.Dummy12 = m.GetDummy12()
	res.Dummy13 = m.GetDummy13()
	res.Dummy14 = m.GetDummy14()
	res.Dummy15 = m.GetDummy15()
	res.Dummy16 = m.GetDummy16()
	res.Dummy17 = m.GetDummy17()
	res.Dummy18 = m.GetDummy18()
	res.Dummy19 = m.GetDummy19()
	res.Dummy20 = m.GetDummy20()
	res.Dummy21 = m.GetDummy21()
	res.Dummy22 = m.GetDummy22()
	res.Dummy23 = m.GetDummy23()
	res.Dummy24 = m.GetDummy24()
	res.Dummy25 = m.GetDummy25()
	res.Dummy26 = m.GetDummy26()
	res.Dummy27 = m.GetDummy27()
	res.Dummy28 = m.GetDummy28()
	res.Dummy29 = m.GetDummy29()
	res.Dummy30 = m.GetDummy30()
	res.Dummy31 = m.GetDummy31()
	res.Dummy32 = m.GetDummy32()
	res.C = m.GetC()

	{
		var data = m.GetOptionalForeign()
		var structData *ForeignMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalForeign = structData
	}

	return res
}

func (s *TestRequiredReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestRequired struct {
	A	int32	`json:"a,omitempty"`
	Dummy2	int32	`json:"dummy2,omitempty"`
	B	int32	`json:"b,omitempty"`
	Dummy4	int32	`json:"dummy4,omitempty"`
	Dummy5	int32	`json:"dummy5,omitempty"`
	Dummy6	int32	`json:"dummy6,omitempty"`
	Dummy7	int32	`json:"dummy7,omitempty"`
	Dummy8	int32	`json:"dummy8,omitempty"`
	Dummy9	int32	`json:"dummy9,omitempty"`
	Dummy10	int32	`json:"dummy10,omitempty"`
	Dummy11	int32	`json:"dummy11,omitempty"`
	Dummy12	int32	`json:"dummy12,omitempty"`
	Dummy13	int32	`json:"dummy13,omitempty"`
	Dummy14	int32	`json:"dummy14,omitempty"`
	Dummy15	int32	`json:"dummy15,omitempty"`
	Dummy16	int32	`json:"dummy16,omitempty"`
	Dummy17	int32	`json:"dummy17,omitempty"`
	Dummy18	int32	`json:"dummy18,omitempty"`
	Dummy19	int32	`json:"dummy19,omitempty"`
	Dummy20	int32	`json:"dummy20,omitempty"`
	Dummy21	int32	`json:"dummy21,omitempty"`
	Dummy22	int32	`json:"dummy22,omitempty"`
	Dummy23	int32	`json:"dummy23,omitempty"`
	Dummy24	int32	`json:"dummy24,omitempty"`
	Dummy25	int32	`json:"dummy25,omitempty"`
	Dummy26	int32	`json:"dummy26,omitempty"`
	Dummy27	int32	`json:"dummy27,omitempty"`
	Dummy28	int32	`json:"dummy28,omitempty"`
	Dummy29	int32	`json:"dummy29,omitempty"`
	Dummy30	int32	`json:"dummy30,omitempty"`
	Dummy31	int32	`json:"dummy31,omitempty"`
	Dummy32	int32	`json:"dummy32,omitempty"`
	C	int32	`json:"c,omitempty"`
	OptionalForeign	*ForeignMessage	`json:"optional_foreign,omitempty"`
}

func (s *TestRequired) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestRequired) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if true {
		res.AppendInt32(wireTestRequired_A, s.A)
	}
	if s.Dummy2 != 0 {
		res.AppendInt32(wireTestRequired_Dummy2, s.Dummy2)
	}
	if true {
		res.AppendInt32(wireTestRequired_B, s.B)
	}
	if s.Dummy4 != 0 {
		res.AppendInt32(wireTestRequired_Dummy4, s.Dummy4)
	}
	if s.Dummy5 != 0 {
		res.AppendInt32(wireTestRequired_Dummy5, s.Dummy5)
	}
	if s.Dummy6 != 0 {
		res.AppendInt32(wireTestRequired_Dummy6, s.Dummy6)
	}
	if s.Dummy7 != 0 {
		res.AppendInt32(wireTestRequired_Dummy7, s.Dummy7)
	}
	if s.Dummy8 != 0 {
		res.AppendInt32(wireTestRequired_Dummy8, s.Dummy8)
	}
	if s.Dummy9 != 0 {
		res.AppendInt32(wireTestRequired_Dummy9, s.Dummy9)
	}
	if s.Dummy10 != 0 {
		res.AppendInt32(wireTestRequired_Dummy10, s.Dummy10)
	}
	if s.Dummy11 != 0 {
		res.AppendInt32(wireTestRequired_Dummy11, s.Dummy11)
	}
	if s.Dummy12 != 0 {
		res.AppendInt32(wireTestRequired_Dummy12, s.Dummy12)
	}
	if s.Dummy13 != 0 {
		res.AppendInt32(wireTestRequired_Dummy13, s.Dummy13)
	}
	if s.Dummy14 != 0 {
		res.AppendInt32(wireTestRequired_Dummy14, s.Dummy14)
	}
	if s.Dummy15 != 0 {
		res.AppendInt32(wireTestRequired_Dummy15, s.Dummy15)
	}
	if s.Dummy16 != 0 {
		res.AppendInt32(wireTestRequired_Dummy16, s.Dummy16)
	}
	if s.Dummy17 != 0 {
		res.AppendInt32(wireTestRequired_Dummy17, s.Dummy17)
	}
	if s.Dummy18 != 0 {
		res.AppendInt32(wireTestRequired_Dummy18, s.Dummy18)
	}
	if s.Dummy19 != 0 {
		res.AppendInt32(wireTestRequired_Dummy19, s.Dummy19)
	}
	if s.Dummy20 != 0 {
		res.AppendInt32(wireTestRequired_Dummy20, s.Dummy20)
	}
	if s.Dummy21 != 0 {
		res.AppendInt32(wireTestRequired_Dummy21, s.Dummy21)
	}
	if s.Dummy22 != 0 {
		res.AppendInt32(wireTestRequired_Dummy22, s.Dummy22)
	}
	if s.Dummy23 != 0 {
		res.AppendInt32(wireTestRequired_Dummy23, s.Dummy23)
	}
	if s.Dummy24 != 0 {
		res.AppendInt32(wireTestRequired_Dummy24, s.Dummy24)
	}
	if s.Dummy25 != 0 {
		res.AppendInt32(wireTestRequired_Dummy25, s.Dummy25)
	}
	if s.Dummy26 != 0 {
		res.AppendInt32(wireTestRequired_Dummy26, s.Dummy26)
	}
	if s.Dummy27 != 0 {
		res.AppendInt32(wireTestRequired_Dummy27, s.Dummy27)
	}
	if s.Dummy28 != 0 {
		res.AppendInt32(wireTestRequired_Dummy28, s.Dummy28)
	}
	if s.Dummy29 != 0 {
		res.AppendInt32(wireTestRequired_Dummy29, s.Dummy29)
	}
	if s.Dummy30 != 0 {
		res.AppendInt32(wireTestRequired_Dummy30, s.Dummy30)
	}
	if s.Dummy31 != 0 {
		res.AppendInt32(wireTestRequired_Dummy31, s.Dummy31)
	}
	if s.Dummy32 != 0 {
		res.AppendInt32(wireTestRequired_Dummy32, s.Dummy32)
	}
	if true {
		res.AppendInt32(wireTestRequired_C, s.C)
	}
	if s.OptionalForeign != nil {
		structSize := s.OptionalForeign.XXX_PbContentSize()
		res.AppendBytesTag(wireTestRequired_OptionalForeign, structSize)
		s.OptionalForeign.MarshalTo(res)
	}
}

func (s *TestRequired) Copy() *TestRequired {
	if s == nil {
		return nil
	}
	res := &TestRequired{}
	res.A = s.A
	res.Dummy2 = s.Dummy2
	res.B = s.B
	res.Dummy4 = s.Dummy4
	res.Dummy5 = s.Dummy5
	res.Dummy6 = s.Dummy6
	res.Dummy7 = s.Dummy7
	res.Dummy8 = s.Dummy8
	res.Dummy9 = s.Dummy9
	res.Dummy10 = s.Dummy10
	res.Dummy11 = s.Dummy11
	res.Dummy12 = s.Dummy12
	res.Dummy13 = s.Dummy13
	res.Dummy14 = s.Dummy14
	res.Dummy15 = s.Dummy15
	res.Dummy16 = s.Dummy16
	res.Dummy17 = s.Dummy17
	res.Dummy18 = s.Dummy18
	res.Dummy19 = s.Dummy19
	res.Dummy20 = s.Dummy20
	res.Dummy21 = s.Dummy21
	res.Dummy22 = s.Dummy22
	res.Dummy23 = s.Dummy23
	res.Dummy24 = s.Dummy24
	res.Dummy25 = s.Dummy25
	res.Dummy26 = s.Dummy26
	res.Dummy27 = s.Dummy27
	res.Dummy28 = s.Dummy28
	res.Dummy29 = s.Dummy29
	res.Dummy30 = s.Dummy30
	res.Dummy31 = s.Dummy31
	res.Dummy32 = s.Dummy32
	res.C = s.C
	if s.OptionalForeign != nil {
		res.OptionalForeign = s.OptionalForeign.Copy()
	}

	return res
}

func (s *TestRequired) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if true {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_A) + gremlin.SizeInt32(s.A)
		size += entrySize
	}

	if s.Dummy2 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy2) + gremlin.SizeInt32(s.Dummy2)
		size += entrySize
	}

	if true {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_B) + gremlin.SizeInt32(s.B)
		size += entrySize
	}

	if s.Dummy4 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy4) + gremlin.SizeInt32(s.Dummy4)
		size += entrySize
	}

	if s.Dummy5 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy5) + gremlin.SizeInt32(s.Dummy5)
		size += entrySize
	}

	if s.Dummy6 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy6) + gremlin.SizeInt32(s.Dummy6)
		size += entrySize
	}

	if s.Dummy7 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy7) + gremlin.SizeInt32(s.Dummy7)
		size += entrySize
	}

	if s.Dummy8 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy8) + gremlin.SizeInt32(s.Dummy8)
		size += entrySize
	}

	if s.Dummy9 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy9) + gremlin.SizeInt32(s.Dummy9)
		size += entrySize
	}

	if s.Dummy10 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy10) + gremlin.SizeInt32(s.Dummy10)
		size += entrySize
	}

	if s.Dummy11 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy11) + gremlin.SizeInt32(s.Dummy11)
		size += entrySize
	}

	if s.Dummy12 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy12) + gremlin.SizeInt32(s.Dummy12)
		size += entrySize
	}

	if s.Dummy13 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy13) + gremlin.SizeInt32(s.Dummy13)
		size += entrySize
	}

	if s.Dummy14 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy14) + gremlin.SizeInt32(s.Dummy14)
		size += entrySize
	}

	if s.Dummy15 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy15) + gremlin.SizeInt32(s.Dummy15)
		size += entrySize
	}

	if s.Dummy16 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy16) + gremlin.SizeInt32(s.Dummy16)
		size += entrySize
	}

	if s.Dummy17 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy17) + gremlin.SizeInt32(s.Dummy17)
		size += entrySize
	}

	if s.Dummy18 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy18) + gremlin.SizeInt32(s.Dummy18)
		size += entrySize
	}

	if s.Dummy19 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy19) + gremlin.SizeInt32(s.Dummy19)
		size += entrySize
	}

	if s.Dummy20 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy20) + gremlin.SizeInt32(s.Dummy20)
		size += entrySize
	}

	if s.Dummy21 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy21) + gremlin.SizeInt32(s.Dummy21)
		size += entrySize
	}

	if s.Dummy22 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy22) + gremlin.SizeInt32(s.Dummy22)
		size += entrySize
	}

	if s.Dummy23 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy23) + gremlin.SizeInt32(s.Dummy23)
		size += entrySize
	}

	if s.Dummy24 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy24) + gremlin.SizeInt32(s.Dummy24)
		size += entrySize
	}

	if s.Dummy25 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy25) + gremlin.SizeInt32(s.Dummy25)
		size += entrySize
	}

	if s.Dummy26 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy26) + gremlin.SizeInt32(s.Dummy26)
		size += entrySize
	}

	if s.Dummy27 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy27) + gremlin.SizeInt32(s.Dummy27)
		size += entrySize
	}

	if s.Dummy28 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy28) + gremlin.SizeInt32(s.Dummy28)
		size += entrySize
	}

	if s.Dummy29 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy29) + gremlin.SizeInt32(s.Dummy29)
		size += entrySize
	}

	if s.Dummy30 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy30) + gremlin.SizeInt32(s.Dummy30)
		size += entrySize
	}

	if s.Dummy31 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy31) + gremlin.SizeInt32(s.Dummy31)
		size += entrySize
	}

	if s.Dummy32 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_Dummy32) + gremlin.SizeInt32(s.Dummy32)
		size += entrySize
	}

	if true {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequired_C) + gremlin.SizeInt32(s.C)
		size += entrySize
	}

	if s.OptionalForeign != nil {
		var entrySize = 0
		entrySize = s.OptionalForeign.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestRequired_OptionalForeign)
		
		size += entrySize
	}

	return size
}

const (
	wireTestRequired_TestAllExtensions_Single gremlin.ProtoWireNumber = 1000
	wireTestRequired_TestAllExtensions_Multi gremlin.ProtoWireNumber = 1001
)

type TestRequired_TestAllExtensionsReader struct {
	buf *gremlin.Reader

	dataSingle     *TestRequiredReader
	dataMulti     []*TestRequiredReader

	offsetSingle   int
	offsetMulti   []int

	parsedSingle   bool
	parsedMulti   bool
}

func NewTestRequired_TestAllExtensionsReader() *TestRequired_TestAllExtensionsReader {
	return &TestRequired_TestAllExtensionsReader{}
}

func (m *TestRequired_TestAllExtensionsReader) GetSingle() *TestRequiredReader {
	if m == nil {
		return nil
	}
	return m.readSingle()
}

func (m *TestRequired_TestAllExtensionsReader) readSingle() *TestRequiredReader {
	if m.parsedSingle {
		return m.dataSingle
	}
	wOffset := m.offsetSingle
	
	var entry *TestRequiredReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestRequiredReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataSingle = entry
	m.parsedSingle = true
	return entry
}

func (m *TestRequired_TestAllExtensionsReader) GetMulti() []*TestRequiredReader {
	if m == nil {
		return nil
	}
	return m.readMulti()
}

func (m *TestRequired_TestAllExtensionsReader) readMulti() []*TestRequiredReader {
	if m.parsedMulti {
		return m.dataMulti
	}
	wOffset := m.offsetMulti
	
	var entry []*TestRequiredReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *TestRequiredReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewTestRequiredReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataMulti = entry
	m.parsedMulti = true
	return entry
}

func (m *TestRequired_TestAllExtensionsReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestRequired_TestAllExtensions_Single:
			m.offsetSingle = offset
		case wireTestRequired_TestAllExtensions_Multi:
			m.offsetMulti = append(m.offsetMulti, offset)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestRequired_TestAllExtensionsReader) ToStruct() *TestRequired_TestAllExtensions {
	if m == nil {
		return nil
	}
	res := &TestRequired_TestAllExtensions{}

	{
		var data = m.GetSingle()
		var structData *TestRequired
		if data != nil {
			structData = data.ToStruct()
		}
		res.Single = structData
	}

	{
		var data = m.GetMulti()
		var structData []*TestRequired
		if len(data) > 0 {
			structData = make([]*TestRequired, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.Multi = structData
	}

	return res
}

func (s *TestRequired_TestAllExtensionsReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestRequired_TestAllExtensions struct {
	Single	*TestRequired	`json:"single,omitempty"`
	Multi	[]*TestRequired	`json:"multi,omitempty"`
}

func (s *TestRequired_TestAllExtensions) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestRequired_TestAllExtensions) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Single != nil {
		structSize := s.Single.XXX_PbContentSize()
		res.AppendBytesTag(wireTestRequired_TestAllExtensions_Single, structSize)
		s.Single.MarshalTo(res)
	}
	if len(s.Multi) > 0 {
		for _, entry := range s.Multi {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireTestRequired_TestAllExtensions_Multi, structSize)
			entry.MarshalTo(res)
		}
	}
}

func (s *TestRequired_TestAllExtensions) Copy() *TestRequired_TestAllExtensions {
	if s == nil {
		return nil
	}
	res := &TestRequired_TestAllExtensions{}
	if s.Single != nil {
		res.Single = s.Single.Copy()
	}
	res.Multi = make([]*TestRequired, len(s.Multi))
	for i := range s.Multi {
		if s.Multi[i] != nil {
			res.Multi[i] = s.Multi[i].Copy()
		}
	}

	return res
}

func (s *TestRequired_TestAllExtensions) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Single != nil {
		var entrySize = 0
		entrySize = s.Single.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestRequired_TestAllExtensions_Single)
		
		size += entrySize
	}

	if len(s.Multi) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.Multi {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestRequired_TestAllExtensions_Multi)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	return size
}

const (
	wireTestRequiredForeign_OptionalMessage gremlin.ProtoWireNumber = 1
	wireTestRequiredForeign_RepeatedMessage gremlin.ProtoWireNumber = 2
	wireTestRequiredForeign_Dummy gremlin.ProtoWireNumber = 3
)

type TestRequiredForeignReader struct {
	buf *gremlin.Reader

	dataOptionalMessage     *TestRequiredReader
	dataRepeatedMessage     []*TestRequiredReader
	dataDummy     int32

	offsetOptionalMessage   int
	offsetRepeatedMessage   []int
	offsetDummy   int

	parsedOptionalMessage   bool
	parsedRepeatedMessage   bool
	parsedDummy   bool
}

func NewTestRequiredForeignReader() *TestRequiredForeignReader {
	return &TestRequiredForeignReader{}
}

func (m *TestRequiredForeignReader) GetOptionalMessage() *TestRequiredReader {
	if m == nil {
		return nil
	}
	return m.readOptionalMessage()
}

func (m *TestRequiredForeignReader) readOptionalMessage() *TestRequiredReader {
	if m.parsedOptionalMessage {
		return m.dataOptionalMessage
	}
	wOffset := m.offsetOptionalMessage
	
	var entry *TestRequiredReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestRequiredReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalMessage = entry
	m.parsedOptionalMessage = true
	return entry
}

func (m *TestRequiredForeignReader) GetRepeatedMessage() []*TestRequiredReader {
	if m == nil {
		return nil
	}
	return m.readRepeatedMessage()
}

func (m *TestRequiredForeignReader) readRepeatedMessage() []*TestRequiredReader {
	if m.parsedRepeatedMessage {
		return m.dataRepeatedMessage
	}
	wOffset := m.offsetRepeatedMessage
	
	var entry []*TestRequiredReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *TestRequiredReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewTestRequiredReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedMessage = entry
	m.parsedRepeatedMessage = true
	return entry
}

func (m *TestRequiredForeignReader) GetDummy() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy()
}

func (m *TestRequiredForeignReader) readDummy() int32 {
	if m.parsedDummy {
		return m.dataDummy
	}
	wOffset := m.offsetDummy
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy = entry
	m.parsedDummy = true
	return entry
}

func (m *TestRequiredForeignReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestRequiredForeign_OptionalMessage:
			m.offsetOptionalMessage = offset
		case wireTestRequiredForeign_RepeatedMessage:
			m.offsetRepeatedMessage = append(m.offsetRepeatedMessage, offset)
		case wireTestRequiredForeign_Dummy:
			m.offsetDummy = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestRequiredForeignReader) ToStruct() *TestRequiredForeign {
	if m == nil {
		return nil
	}
	res := &TestRequiredForeign{}

	{
		var data = m.GetOptionalMessage()
		var structData *TestRequired
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalMessage = structData
	}

	{
		var data = m.GetRepeatedMessage()
		var structData []*TestRequired
		if len(data) > 0 {
			structData = make([]*TestRequired, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.RepeatedMessage = structData
	}
	res.Dummy = m.GetDummy()

	return res
}

func (s *TestRequiredForeignReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestRequiredForeign struct {
	OptionalMessage	*TestRequired	`json:"optional_message,omitempty"`
	RepeatedMessage	[]*TestRequired	`json:"repeated_message,omitempty"`
	Dummy	int32	`json:"dummy,omitempty"`
}

func (s *TestRequiredForeign) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestRequiredForeign) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.OptionalMessage != nil {
		structSize := s.OptionalMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestRequiredForeign_OptionalMessage, structSize)
		s.OptionalMessage.MarshalTo(res)
	}
	if len(s.RepeatedMessage) > 0 {
		for _, entry := range s.RepeatedMessage {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireTestRequiredForeign_RepeatedMessage, structSize)
			entry.MarshalTo(res)
		}
	}
	if s.Dummy != 0 {
		res.AppendInt32(wireTestRequiredForeign_Dummy, s.Dummy)
	}
}

func (s *TestRequiredForeign) Copy() *TestRequiredForeign {
	if s == nil {
		return nil
	}
	res := &TestRequiredForeign{}
	if s.OptionalMessage != nil {
		res.OptionalMessage = s.OptionalMessage.Copy()
	}
	res.RepeatedMessage = make([]*TestRequired, len(s.RepeatedMessage))
	for i := range s.RepeatedMessage {
		if s.RepeatedMessage[i] != nil {
			res.RepeatedMessage[i] = s.RepeatedMessage[i].Copy()
		}
	}
	res.Dummy = s.Dummy

	return res
}

func (s *TestRequiredForeign) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.OptionalMessage != nil {
		var entrySize = 0
		entrySize = s.OptionalMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestRequiredForeign_OptionalMessage)
		
		size += entrySize
	}

	if len(s.RepeatedMessage) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedMessage {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestRequiredForeign_RepeatedMessage)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if s.Dummy != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequiredForeign_Dummy) + gremlin.SizeInt32(s.Dummy)
		size += entrySize
	}

	return size
}

const (
	wireTestRequiredMessage_OptionalMessage gremlin.ProtoWireNumber = 1
	wireTestRequiredMessage_RepeatedMessage gremlin.ProtoWireNumber = 2
	wireTestRequiredMessage_RequiredMessage gremlin.ProtoWireNumber = 3
)

type TestRequiredMessageReader struct {
	buf *gremlin.Reader

	dataOptionalMessage     *TestRequiredReader
	dataRepeatedMessage     []*TestRequiredReader
	dataRequiredMessage     *TestRequiredReader

	offsetOptionalMessage   int
	offsetRepeatedMessage   []int
	offsetRequiredMessage   int

	parsedOptionalMessage   bool
	parsedRepeatedMessage   bool
	parsedRequiredMessage   bool
}

func NewTestRequiredMessageReader() *TestRequiredMessageReader {
	return &TestRequiredMessageReader{}
}

func (m *TestRequiredMessageReader) GetOptionalMessage() *TestRequiredReader {
	if m == nil {
		return nil
	}
	return m.readOptionalMessage()
}

func (m *TestRequiredMessageReader) readOptionalMessage() *TestRequiredReader {
	if m.parsedOptionalMessage {
		return m.dataOptionalMessage
	}
	wOffset := m.offsetOptionalMessage
	
	var entry *TestRequiredReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestRequiredReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalMessage = entry
	m.parsedOptionalMessage = true
	return entry
}

func (m *TestRequiredMessageReader) GetRepeatedMessage() []*TestRequiredReader {
	if m == nil {
		return nil
	}
	return m.readRepeatedMessage()
}

func (m *TestRequiredMessageReader) readRepeatedMessage() []*TestRequiredReader {
	if m.parsedRepeatedMessage {
		return m.dataRepeatedMessage
	}
	wOffset := m.offsetRepeatedMessage
	
	var entry []*TestRequiredReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *TestRequiredReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewTestRequiredReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedMessage = entry
	m.parsedRepeatedMessage = true
	return entry
}

func (m *TestRequiredMessageReader) GetRequiredMessage() *TestRequiredReader {
	if m == nil {
		return nil
	}
	return m.readRequiredMessage()
}

func (m *TestRequiredMessageReader) readRequiredMessage() *TestRequiredReader {
	if m.parsedRequiredMessage {
		return m.dataRequiredMessage
	}
	wOffset := m.offsetRequiredMessage
	
	var entry *TestRequiredReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestRequiredReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataRequiredMessage = entry
	m.parsedRequiredMessage = true
	return entry
}

func (m *TestRequiredMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestRequiredMessage_OptionalMessage:
			m.offsetOptionalMessage = offset
		case wireTestRequiredMessage_RepeatedMessage:
			m.offsetRepeatedMessage = append(m.offsetRepeatedMessage, offset)
		case wireTestRequiredMessage_RequiredMessage:
			m.offsetRequiredMessage = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestRequiredMessageReader) ToStruct() *TestRequiredMessage {
	if m == nil {
		return nil
	}
	res := &TestRequiredMessage{}

	{
		var data = m.GetOptionalMessage()
		var structData *TestRequired
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalMessage = structData
	}

	{
		var data = m.GetRepeatedMessage()
		var structData []*TestRequired
		if len(data) > 0 {
			structData = make([]*TestRequired, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.RepeatedMessage = structData
	}

	{
		var data = m.GetRequiredMessage()
		var structData *TestRequired
		if data != nil {
			structData = data.ToStruct()
		}
		res.RequiredMessage = structData
	}

	return res
}

func (s *TestRequiredMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestRequiredMessage struct {
	OptionalMessage	*TestRequired	`json:"optional_message,omitempty"`
	RepeatedMessage	[]*TestRequired	`json:"repeated_message,omitempty"`
	RequiredMessage	*TestRequired	`json:"required_message,omitempty"`
}

func (s *TestRequiredMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestRequiredMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.OptionalMessage != nil {
		structSize := s.OptionalMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestRequiredMessage_OptionalMessage, structSize)
		s.OptionalMessage.MarshalTo(res)
	}
	if len(s.RepeatedMessage) > 0 {
		for _, entry := range s.RepeatedMessage {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireTestRequiredMessage_RepeatedMessage, structSize)
			entry.MarshalTo(res)
		}
	}
	if true {
		structSize := s.RequiredMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestRequiredMessage_RequiredMessage, structSize)
		s.RequiredMessage.MarshalTo(res)
	}
}

func (s *TestRequiredMessage) Copy() *TestRequiredMessage {
	if s == nil {
		return nil
	}
	res := &TestRequiredMessage{}
	if s.OptionalMessage != nil {
		res.OptionalMessage = s.OptionalMessage.Copy()
	}
	res.RepeatedMessage = make([]*TestRequired, len(s.RepeatedMessage))
	for i := range s.RepeatedMessage {
		if s.RepeatedMessage[i] != nil {
			res.RepeatedMessage[i] = s.RepeatedMessage[i].Copy()
		}
	}
	if s.RequiredMessage != nil {
		res.RequiredMessage = s.RequiredMessage.Copy()
	}

	return res
}

func (s *TestRequiredMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.OptionalMessage != nil {
		var entrySize = 0
		entrySize = s.OptionalMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestRequiredMessage_OptionalMessage)
		
		size += entrySize
	}

	if len(s.RepeatedMessage) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedMessage {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestRequiredMessage_RepeatedMessage)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if true {
		var entrySize = 0
		entrySize = s.RequiredMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestRequiredMessage_RequiredMessage)
		
		size += entrySize
	}

	return size
}

const (
	wireTestNestedRequiredForeign_Child gremlin.ProtoWireNumber = 1
	wireTestNestedRequiredForeign_Payload gremlin.ProtoWireNumber = 2
	wireTestNestedRequiredForeign_Dummy gremlin.ProtoWireNumber = 3
)

type TestNestedRequiredForeignReader struct {
	buf *gremlin.Reader

	dataChild     *TestNestedRequiredForeignReader
	dataPayload     *TestRequiredForeignReader
	dataDummy     int32

	offsetChild   int
	offsetPayload   int
	offsetDummy   int

	parsedChild   bool
	parsedPayload   bool
	parsedDummy   bool
}

func NewTestNestedRequiredForeignReader() *TestNestedRequiredForeignReader {
	return &TestNestedRequiredForeignReader{}
}

func (m *TestNestedRequiredForeignReader) GetChild() *TestNestedRequiredForeignReader {
	if m == nil {
		return nil
	}
	return m.readChild()
}

func (m *TestNestedRequiredForeignReader) readChild() *TestNestedRequiredForeignReader {
	if m.parsedChild {
		return m.dataChild
	}
	wOffset := m.offsetChild
	
	var entry *TestNestedRequiredForeignReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestNestedRequiredForeignReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataChild = entry
	m.parsedChild = true
	return entry
}

func (m *TestNestedRequiredForeignReader) GetPayload() *TestRequiredForeignReader {
	if m == nil {
		return nil
	}
	return m.readPayload()
}

func (m *TestNestedRequiredForeignReader) readPayload() *TestRequiredForeignReader {
	if m.parsedPayload {
		return m.dataPayload
	}
	wOffset := m.offsetPayload
	
	var entry *TestRequiredForeignReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestRequiredForeignReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataPayload = entry
	m.parsedPayload = true
	return entry
}

func (m *TestNestedRequiredForeignReader) GetDummy() int32 {
	if m == nil {
		return 0
	}
	return m.readDummy()
}

func (m *TestNestedRequiredForeignReader) readDummy() int32 {
	if m.parsedDummy {
		return m.dataDummy
	}
	wOffset := m.offsetDummy
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDummy = entry
	m.parsedDummy = true
	return entry
}

func (m *TestNestedRequiredForeignReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestNestedRequiredForeign_Child:
			m.offsetChild = offset
		case wireTestNestedRequiredForeign_Payload:
			m.offsetPayload = offset
		case wireTestNestedRequiredForeign_Dummy:
			m.offsetDummy = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestNestedRequiredForeignReader) ToStruct() *TestNestedRequiredForeign {
	if m == nil {
		return nil
	}
	res := &TestNestedRequiredForeign{}

	{
		var data = m.GetChild()
		var structData *TestNestedRequiredForeign
		if data != nil {
			structData = data.ToStruct()
		}
		res.Child = structData
	}

	{
		var data = m.GetPayload()
		var structData *TestRequiredForeign
		if data != nil {
			structData = data.ToStruct()
		}
		res.Payload = structData
	}
	res.Dummy = m.GetDummy()

	return res
}

func (s *TestNestedRequiredForeignReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestNestedRequiredForeign struct {
	Child	*TestNestedRequiredForeign	`json:"child,omitempty"`
	Payload	*TestRequiredForeign	`json:"payload,omitempty"`
	Dummy	int32	`json:"dummy,omitempty"`
}

func (s *TestNestedRequiredForeign) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestNestedRequiredForeign) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Child != nil {
		structSize := s.Child.XXX_PbContentSize()
		res.AppendBytesTag(wireTestNestedRequiredForeign_Child, structSize)
		s.Child.MarshalTo(res)
	}
	if s.Payload != nil {
		structSize := s.Payload.XXX_PbContentSize()
		res.AppendBytesTag(wireTestNestedRequiredForeign_Payload, structSize)
		s.Payload.MarshalTo(res)
	}
	if s.Dummy != 0 {
		res.AppendInt32(wireTestNestedRequiredForeign_Dummy, s.Dummy)
	}
}

func (s *TestNestedRequiredForeign) Copy() *TestNestedRequiredForeign {
	if s == nil {
		return nil
	}
	res := &TestNestedRequiredForeign{}
	if s.Child != nil {
		res.Child = s.Child.Copy()
	}
	if s.Payload != nil {
		res.Payload = s.Payload.Copy()
	}
	res.Dummy = s.Dummy

	return res
}

func (s *TestNestedRequiredForeign) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Child != nil {
		var entrySize = 0
		entrySize = s.Child.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestNestedRequiredForeign_Child)
		
		size += entrySize
	}

	if s.Payload != nil {
		var entrySize = 0
		entrySize = s.Payload.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestNestedRequiredForeign_Payload)
		
		size += entrySize
	}

	if s.Dummy != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestNestedRequiredForeign_Dummy) + gremlin.SizeInt32(s.Dummy)
		size += entrySize
	}

	return size
}

const (
	wireTestForeignNested_ForeignNested gremlin.ProtoWireNumber = 1
)

type TestForeignNestedReader struct {
	buf *gremlin.Reader

	dataForeignNested     *TestAllTypes_NestedMessageReader

	offsetForeignNested   int

	parsedForeignNested   bool
}

func NewTestForeignNestedReader() *TestForeignNestedReader {
	return &TestForeignNestedReader{}
}

func (m *TestForeignNestedReader) GetForeignNested() *TestAllTypes_NestedMessageReader {
	if m == nil {
		return nil
	}
	return m.readForeignNested()
}

func (m *TestForeignNestedReader) readForeignNested() *TestAllTypes_NestedMessageReader {
	if m.parsedForeignNested {
		return m.dataForeignNested
	}
	wOffset := m.offsetForeignNested
	
	var entry *TestAllTypes_NestedMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypes_NestedMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataForeignNested = entry
	m.parsedForeignNested = true
	return entry
}

func (m *TestForeignNestedReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestForeignNested_ForeignNested:
			m.offsetForeignNested = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestForeignNestedReader) ToStruct() *TestForeignNested {
	if m == nil {
		return nil
	}
	res := &TestForeignNested{}

	{
		var data = m.GetForeignNested()
		var structData *TestAllTypes_NestedMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.ForeignNested = structData
	}

	return res
}

func (s *TestForeignNestedReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestForeignNested struct {
	ForeignNested	*TestAllTypes_NestedMessage	`json:"foreign_nested,omitempty"`
}

func (s *TestForeignNested) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestForeignNested) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.ForeignNested != nil {
		structSize := s.ForeignNested.XXX_PbContentSize()
		res.AppendBytesTag(wireTestForeignNested_ForeignNested, structSize)
		s.ForeignNested.MarshalTo(res)
	}
}

func (s *TestForeignNested) Copy() *TestForeignNested {
	if s == nil {
		return nil
	}
	res := &TestForeignNested{}
	if s.ForeignNested != nil {
		res.ForeignNested = s.ForeignNested.Copy()
	}

	return res
}

func (s *TestForeignNested) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.ForeignNested != nil {
		var entrySize = 0
		entrySize = s.ForeignNested.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestForeignNested_ForeignNested)
		
		size += entrySize
	}

	return size
}

const (
)

type TestEmptyMessageReader struct {
	buf *gremlin.Reader



}

func NewTestEmptyMessageReader() *TestEmptyMessageReader {
	return &TestEmptyMessageReader{}
}

func (m *TestEmptyMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestEmptyMessageReader) ToStruct() *TestEmptyMessage {
	if m == nil {
		return nil
	}
	res := &TestEmptyMessage{}

	return res
}

func (s *TestEmptyMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestEmptyMessage struct {
}

func (s *TestEmptyMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestEmptyMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

}

func (s *TestEmptyMessage) Copy() *TestEmptyMessage {
	if s == nil {
		return nil
	}
	res := &TestEmptyMessage{}

	return res
}

func (s *TestEmptyMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	return size
}

const (
)

type TestEmptyMessageWithExtensionsReader struct {
	buf *gremlin.Reader



}

func NewTestEmptyMessageWithExtensionsReader() *TestEmptyMessageWithExtensionsReader {
	return &TestEmptyMessageWithExtensionsReader{}
}

func (m *TestEmptyMessageWithExtensionsReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestEmptyMessageWithExtensionsReader) ToStruct() *TestEmptyMessageWithExtensions {
	if m == nil {
		return nil
	}
	res := &TestEmptyMessageWithExtensions{}

	return res
}

func (s *TestEmptyMessageWithExtensionsReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestEmptyMessageWithExtensions struct {
}

func (s *TestEmptyMessageWithExtensions) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestEmptyMessageWithExtensions) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

}

func (s *TestEmptyMessageWithExtensions) Copy() *TestEmptyMessageWithExtensions {
	if s == nil {
		return nil
	}
	res := &TestEmptyMessageWithExtensions{}

	return res
}

func (s *TestEmptyMessageWithExtensions) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	return size
}

const (
)

type TestPickleNestedMessageReader struct {
	buf *gremlin.Reader



}

func NewTestPickleNestedMessageReader() *TestPickleNestedMessageReader {
	return &TestPickleNestedMessageReader{}
}

func (m *TestPickleNestedMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestPickleNestedMessageReader) ToStruct() *TestPickleNestedMessage {
	if m == nil {
		return nil
	}
	res := &TestPickleNestedMessage{}

	return res
}

func (s *TestPickleNestedMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestPickleNestedMessage struct {
}

func (s *TestPickleNestedMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestPickleNestedMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

}

func (s *TestPickleNestedMessage) Copy() *TestPickleNestedMessage {
	if s == nil {
		return nil
	}
	res := &TestPickleNestedMessage{}

	return res
}

func (s *TestPickleNestedMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	return size
}

const (
	wireTestPickleNestedMessage_NestedMessage_Bb gremlin.ProtoWireNumber = 1
)

type TestPickleNestedMessage_NestedMessageReader struct {
	buf *gremlin.Reader

	dataBb     int32

	offsetBb   int

	parsedBb   bool
}

func NewTestPickleNestedMessage_NestedMessageReader() *TestPickleNestedMessage_NestedMessageReader {
	return &TestPickleNestedMessage_NestedMessageReader{}
}

func (m *TestPickleNestedMessage_NestedMessageReader) GetBb() int32 {
	if m == nil {
		return 0
	}
	return m.readBb()
}

func (m *TestPickleNestedMessage_NestedMessageReader) readBb() int32 {
	if m.parsedBb {
		return m.dataBb
	}
	wOffset := m.offsetBb
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataBb = entry
	m.parsedBb = true
	return entry
}

func (m *TestPickleNestedMessage_NestedMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestPickleNestedMessage_NestedMessage_Bb:
			m.offsetBb = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestPickleNestedMessage_NestedMessageReader) ToStruct() *TestPickleNestedMessage_NestedMessage {
	if m == nil {
		return nil
	}
	res := &TestPickleNestedMessage_NestedMessage{}
	res.Bb = m.GetBb()

	return res
}

func (s *TestPickleNestedMessage_NestedMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestPickleNestedMessage_NestedMessage struct {
	Bb	int32	`json:"bb,omitempty"`
}

func (s *TestPickleNestedMessage_NestedMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestPickleNestedMessage_NestedMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Bb != 0 {
		res.AppendInt32(wireTestPickleNestedMessage_NestedMessage_Bb, s.Bb)
	}
}

func (s *TestPickleNestedMessage_NestedMessage) Copy() *TestPickleNestedMessage_NestedMessage {
	if s == nil {
		return nil
	}
	res := &TestPickleNestedMessage_NestedMessage{}
	res.Bb = s.Bb

	return res
}

func (s *TestPickleNestedMessage_NestedMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Bb != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestPickleNestedMessage_NestedMessage_Bb) + gremlin.SizeInt32(s.Bb)
		size += entrySize
	}

	return size
}

const (
	wireTestPickleNestedMessage_NestedMessage_NestedNestedMessage_Cc gremlin.ProtoWireNumber = 1
)

type TestPickleNestedMessage_NestedMessage_NestedNestedMessageReader struct {
	buf *gremlin.Reader

	dataCc     int32

	offsetCc   int

	parsedCc   bool
}

func NewTestPickleNestedMessage_NestedMessage_NestedNestedMessageReader() *TestPickleNestedMessage_NestedMessage_NestedNestedMessageReader {
	return &TestPickleNestedMessage_NestedMessage_NestedNestedMessageReader{}
}

func (m *TestPickleNestedMessage_NestedMessage_NestedNestedMessageReader) GetCc() int32 {
	if m == nil {
		return 0
	}
	return m.readCc()
}

func (m *TestPickleNestedMessage_NestedMessage_NestedNestedMessageReader) readCc() int32 {
	if m.parsedCc {
		return m.dataCc
	}
	wOffset := m.offsetCc
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataCc = entry
	m.parsedCc = true
	return entry
}

func (m *TestPickleNestedMessage_NestedMessage_NestedNestedMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestPickleNestedMessage_NestedMessage_NestedNestedMessage_Cc:
			m.offsetCc = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestPickleNestedMessage_NestedMessage_NestedNestedMessageReader) ToStruct() *TestPickleNestedMessage_NestedMessage_NestedNestedMessage {
	if m == nil {
		return nil
	}
	res := &TestPickleNestedMessage_NestedMessage_NestedNestedMessage{}
	res.Cc = m.GetCc()

	return res
}

func (s *TestPickleNestedMessage_NestedMessage_NestedNestedMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestPickleNestedMessage_NestedMessage_NestedNestedMessage struct {
	Cc	int32	`json:"cc,omitempty"`
}

func (s *TestPickleNestedMessage_NestedMessage_NestedNestedMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestPickleNestedMessage_NestedMessage_NestedNestedMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Cc != 0 {
		res.AppendInt32(wireTestPickleNestedMessage_NestedMessage_NestedNestedMessage_Cc, s.Cc)
	}
}

func (s *TestPickleNestedMessage_NestedMessage_NestedNestedMessage) Copy() *TestPickleNestedMessage_NestedMessage_NestedNestedMessage {
	if s == nil {
		return nil
	}
	res := &TestPickleNestedMessage_NestedMessage_NestedNestedMessage{}
	res.Cc = s.Cc

	return res
}

func (s *TestPickleNestedMessage_NestedMessage_NestedNestedMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Cc != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestPickleNestedMessage_NestedMessage_NestedNestedMessage_Cc) + gremlin.SizeInt32(s.Cc)
		size += entrySize
	}

	return size
}

const (
)

type TestMultipleExtensionRangesReader struct {
	buf *gremlin.Reader



}

func NewTestMultipleExtensionRangesReader() *TestMultipleExtensionRangesReader {
	return &TestMultipleExtensionRangesReader{}
}

func (m *TestMultipleExtensionRangesReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestMultipleExtensionRangesReader) ToStruct() *TestMultipleExtensionRanges {
	if m == nil {
		return nil
	}
	res := &TestMultipleExtensionRanges{}

	return res
}

func (s *TestMultipleExtensionRangesReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestMultipleExtensionRanges struct {
}

func (s *TestMultipleExtensionRanges) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestMultipleExtensionRanges) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

}

func (s *TestMultipleExtensionRanges) Copy() *TestMultipleExtensionRanges {
	if s == nil {
		return nil
	}
	res := &TestMultipleExtensionRanges{}

	return res
}

func (s *TestMultipleExtensionRanges) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	return size
}

const (
	wireTestReallyLargeTagNumber_A gremlin.ProtoWireNumber = 1
	wireTestReallyLargeTagNumber_Bb gremlin.ProtoWireNumber = 268435455
)

type TestReallyLargeTagNumberReader struct {
	buf *gremlin.Reader

	dataA     int32
	dataBb     int32

	offsetA   int
	offsetBb   int

	parsedA   bool
	parsedBb   bool
}

func NewTestReallyLargeTagNumberReader() *TestReallyLargeTagNumberReader {
	return &TestReallyLargeTagNumberReader{}
}

func (m *TestReallyLargeTagNumberReader) GetA() int32 {
	if m == nil {
		return 0
	}
	return m.readA()
}

func (m *TestReallyLargeTagNumberReader) readA() int32 {
	if m.parsedA {
		return m.dataA
	}
	wOffset := m.offsetA
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataA = entry
	m.parsedA = true
	return entry
}

func (m *TestReallyLargeTagNumberReader) GetBb() int32 {
	if m == nil {
		return 0
	}
	return m.readBb()
}

func (m *TestReallyLargeTagNumberReader) readBb() int32 {
	if m.parsedBb {
		return m.dataBb
	}
	wOffset := m.offsetBb
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataBb = entry
	m.parsedBb = true
	return entry
}

func (m *TestReallyLargeTagNumberReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestReallyLargeTagNumber_A:
			m.offsetA = offset
		case wireTestReallyLargeTagNumber_Bb:
			m.offsetBb = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestReallyLargeTagNumberReader) ToStruct() *TestReallyLargeTagNumber {
	if m == nil {
		return nil
	}
	res := &TestReallyLargeTagNumber{}
	res.A = m.GetA()
	res.Bb = m.GetBb()

	return res
}

func (s *TestReallyLargeTagNumberReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestReallyLargeTagNumber struct {
	A	int32	`json:"a,omitempty"`
	Bb	int32	`json:"bb,omitempty"`
}

func (s *TestReallyLargeTagNumber) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestReallyLargeTagNumber) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.A != 0 {
		res.AppendInt32(wireTestReallyLargeTagNumber_A, s.A)
	}
	if s.Bb != 0 {
		res.AppendInt32(wireTestReallyLargeTagNumber_Bb, s.Bb)
	}
}

func (s *TestReallyLargeTagNumber) Copy() *TestReallyLargeTagNumber {
	if s == nil {
		return nil
	}
	res := &TestReallyLargeTagNumber{}
	res.A = s.A
	res.Bb = s.Bb

	return res
}

func (s *TestReallyLargeTagNumber) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.A != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestReallyLargeTagNumber_A) + gremlin.SizeInt32(s.A)
		size += entrySize
	}

	if s.Bb != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestReallyLargeTagNumber_Bb) + gremlin.SizeInt32(s.Bb)
		size += entrySize
	}

	return size
}

const (
	wireTestRecursiveMessage_A gremlin.ProtoWireNumber = 1
	wireTestRecursiveMessage_I gremlin.ProtoWireNumber = 2
)

type TestRecursiveMessageReader struct {
	buf *gremlin.Reader

	dataA     *TestRecursiveMessageReader
	dataI     int32

	offsetA   int
	offsetI   int

	parsedA   bool
	parsedI   bool
}

func NewTestRecursiveMessageReader() *TestRecursiveMessageReader {
	return &TestRecursiveMessageReader{}
}

func (m *TestRecursiveMessageReader) GetA() *TestRecursiveMessageReader {
	if m == nil {
		return nil
	}
	return m.readA()
}

func (m *TestRecursiveMessageReader) readA() *TestRecursiveMessageReader {
	if m.parsedA {
		return m.dataA
	}
	wOffset := m.offsetA
	
	var entry *TestRecursiveMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestRecursiveMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataA = entry
	m.parsedA = true
	return entry
}

func (m *TestRecursiveMessageReader) GetI() int32 {
	if m == nil {
		return 0
	}
	return m.readI()
}

func (m *TestRecursiveMessageReader) readI() int32 {
	if m.parsedI {
		return m.dataI
	}
	wOffset := m.offsetI
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataI = entry
	m.parsedI = true
	return entry
}

func (m *TestRecursiveMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestRecursiveMessage_A:
			m.offsetA = offset
		case wireTestRecursiveMessage_I:
			m.offsetI = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestRecursiveMessageReader) ToStruct() *TestRecursiveMessage {
	if m == nil {
		return nil
	}
	res := &TestRecursiveMessage{}

	{
		var data = m.GetA()
		var structData *TestRecursiveMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.A = structData
	}
	res.I = m.GetI()

	return res
}

func (s *TestRecursiveMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestRecursiveMessage struct {
	A	*TestRecursiveMessage	`json:"a,omitempty"`
	I	int32	`json:"i,omitempty"`
}

func (s *TestRecursiveMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestRecursiveMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.A != nil {
		structSize := s.A.XXX_PbContentSize()
		res.AppendBytesTag(wireTestRecursiveMessage_A, structSize)
		s.A.MarshalTo(res)
	}
	if s.I != 0 {
		res.AppendInt32(wireTestRecursiveMessage_I, s.I)
	}
}

func (s *TestRecursiveMessage) Copy() *TestRecursiveMessage {
	if s == nil {
		return nil
	}
	res := &TestRecursiveMessage{}
	if s.A != nil {
		res.A = s.A.Copy()
	}
	res.I = s.I

	return res
}

func (s *TestRecursiveMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.A != nil {
		var entrySize = 0
		entrySize = s.A.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestRecursiveMessage_A)
		
		size += entrySize
	}

	if s.I != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRecursiveMessage_I) + gremlin.SizeInt32(s.I)
		size += entrySize
	}

	return size
}

const (
	wireTestMutualRecursionA_Bb gremlin.ProtoWireNumber = 1
)

type TestMutualRecursionAReader struct {
	buf *gremlin.Reader

	dataBb     *TestMutualRecursionBReader

	offsetBb   int

	parsedBb   bool
}

func NewTestMutualRecursionAReader() *TestMutualRecursionAReader {
	return &TestMutualRecursionAReader{}
}

func (m *TestMutualRecursionAReader) GetBb() *TestMutualRecursionBReader {
	if m == nil {
		return nil
	}
	return m.readBb()
}

func (m *TestMutualRecursionAReader) readBb() *TestMutualRecursionBReader {
	if m.parsedBb {
		return m.dataBb
	}
	wOffset := m.offsetBb
	
	var entry *TestMutualRecursionBReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestMutualRecursionBReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataBb = entry
	m.parsedBb = true
	return entry
}

func (m *TestMutualRecursionAReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestMutualRecursionA_Bb:
			m.offsetBb = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestMutualRecursionAReader) ToStruct() *TestMutualRecursionA {
	if m == nil {
		return nil
	}
	res := &TestMutualRecursionA{}

	{
		var data = m.GetBb()
		var structData *TestMutualRecursionB
		if data != nil {
			structData = data.ToStruct()
		}
		res.Bb = structData
	}

	return res
}

func (s *TestMutualRecursionAReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestMutualRecursionA struct {
	Bb	*TestMutualRecursionB	`json:"bb,omitempty"`
}

func (s *TestMutualRecursionA) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestMutualRecursionA) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Bb != nil {
		structSize := s.Bb.XXX_PbContentSize()
		res.AppendBytesTag(wireTestMutualRecursionA_Bb, structSize)
		s.Bb.MarshalTo(res)
	}
}

func (s *TestMutualRecursionA) Copy() *TestMutualRecursionA {
	if s == nil {
		return nil
	}
	res := &TestMutualRecursionA{}
	if s.Bb != nil {
		res.Bb = s.Bb.Copy()
	}

	return res
}

func (s *TestMutualRecursionA) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Bb != nil {
		var entrySize = 0
		entrySize = s.Bb.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestMutualRecursionA_Bb)
		
		size += entrySize
	}

	return size
}

const (
	wireTestMutualRecursionA_SubMessage_B gremlin.ProtoWireNumber = 1
)

type TestMutualRecursionA_SubMessageReader struct {
	buf *gremlin.Reader

	dataB     *TestMutualRecursionBReader

	offsetB   int

	parsedB   bool
}

func NewTestMutualRecursionA_SubMessageReader() *TestMutualRecursionA_SubMessageReader {
	return &TestMutualRecursionA_SubMessageReader{}
}

func (m *TestMutualRecursionA_SubMessageReader) GetB() *TestMutualRecursionBReader {
	if m == nil {
		return nil
	}
	return m.readB()
}

func (m *TestMutualRecursionA_SubMessageReader) readB() *TestMutualRecursionBReader {
	if m.parsedB {
		return m.dataB
	}
	wOffset := m.offsetB
	
	var entry *TestMutualRecursionBReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestMutualRecursionBReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataB = entry
	m.parsedB = true
	return entry
}

func (m *TestMutualRecursionA_SubMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestMutualRecursionA_SubMessage_B:
			m.offsetB = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestMutualRecursionA_SubMessageReader) ToStruct() *TestMutualRecursionA_SubMessage {
	if m == nil {
		return nil
	}
	res := &TestMutualRecursionA_SubMessage{}

	{
		var data = m.GetB()
		var structData *TestMutualRecursionB
		if data != nil {
			structData = data.ToStruct()
		}
		res.B = structData
	}

	return res
}

func (s *TestMutualRecursionA_SubMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestMutualRecursionA_SubMessage struct {
	B	*TestMutualRecursionB	`json:"b,omitempty"`
}

func (s *TestMutualRecursionA_SubMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestMutualRecursionA_SubMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.B != nil {
		structSize := s.B.XXX_PbContentSize()
		res.AppendBytesTag(wireTestMutualRecursionA_SubMessage_B, structSize)
		s.B.MarshalTo(res)
	}
}

func (s *TestMutualRecursionA_SubMessage) Copy() *TestMutualRecursionA_SubMessage {
	if s == nil {
		return nil
	}
	res := &TestMutualRecursionA_SubMessage{}
	if s.B != nil {
		res.B = s.B.Copy()
	}

	return res
}

func (s *TestMutualRecursionA_SubMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.B != nil {
		var entrySize = 0
		entrySize = s.B.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestMutualRecursionA_SubMessage_B)
		
		size += entrySize
	}

	return size
}

const (
	wireTestMutualRecursionB_A gremlin.ProtoWireNumber = 1
	wireTestMutualRecursionB_OptionalInt32 gremlin.ProtoWireNumber = 2
)

type TestMutualRecursionBReader struct {
	buf *gremlin.Reader

	dataA     *TestMutualRecursionAReader
	dataOptionalInt32     int32

	offsetA   int
	offsetOptionalInt32   int

	parsedA   bool
	parsedOptionalInt32   bool
}

func NewTestMutualRecursionBReader() *TestMutualRecursionBReader {
	return &TestMutualRecursionBReader{}
}

func (m *TestMutualRecursionBReader) GetA() *TestMutualRecursionAReader {
	if m == nil {
		return nil
	}
	return m.readA()
}

func (m *TestMutualRecursionBReader) readA() *TestMutualRecursionAReader {
	if m.parsedA {
		return m.dataA
	}
	wOffset := m.offsetA
	
	var entry *TestMutualRecursionAReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestMutualRecursionAReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataA = entry
	m.parsedA = true
	return entry
}

func (m *TestMutualRecursionBReader) GetOptionalInt32() int32 {
	if m == nil {
		return 0
	}
	return m.readOptionalInt32()
}

func (m *TestMutualRecursionBReader) readOptionalInt32() int32 {
	if m.parsedOptionalInt32 {
		return m.dataOptionalInt32
	}
	wOffset := m.offsetOptionalInt32
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataOptionalInt32 = entry
	m.parsedOptionalInt32 = true
	return entry
}

func (m *TestMutualRecursionBReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestMutualRecursionB_A:
			m.offsetA = offset
		case wireTestMutualRecursionB_OptionalInt32:
			m.offsetOptionalInt32 = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestMutualRecursionBReader) ToStruct() *TestMutualRecursionB {
	if m == nil {
		return nil
	}
	res := &TestMutualRecursionB{}

	{
		var data = m.GetA()
		var structData *TestMutualRecursionA
		if data != nil {
			structData = data.ToStruct()
		}
		res.A = structData
	}
	res.OptionalInt32 = m.GetOptionalInt32()

	return res
}

func (s *TestMutualRecursionBReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestMutualRecursionB struct {
	A	*TestMutualRecursionA	`json:"a,omitempty"`
	OptionalInt32	int32	`json:"optional_int32,omitempty"`
}

func (s *TestMutualRecursionB) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestMutualRecursionB) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.A != nil {
		structSize := s.A.XXX_PbContentSize()
		res.AppendBytesTag(wireTestMutualRecursionB_A, structSize)
		s.A.MarshalTo(res)
	}
	if s.OptionalInt32 != 0 {
		res.AppendInt32(wireTestMutualRecursionB_OptionalInt32, s.OptionalInt32)
	}
}

func (s *TestMutualRecursionB) Copy() *TestMutualRecursionB {
	if s == nil {
		return nil
	}
	res := &TestMutualRecursionB{}
	if s.A != nil {
		res.A = s.A.Copy()
	}
	res.OptionalInt32 = s.OptionalInt32

	return res
}

func (s *TestMutualRecursionB) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.A != nil {
		var entrySize = 0
		entrySize = s.A.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestMutualRecursionB_A)
		
		size += entrySize
	}

	if s.OptionalInt32 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestMutualRecursionB_OptionalInt32) + gremlin.SizeInt32(s.OptionalInt32)
		size += entrySize
	}

	return size
}

const (
	wireTestIsInitialized_SubMessage gremlin.ProtoWireNumber = 1
)

type TestIsInitializedReader struct {
	buf *gremlin.Reader

	dataSubMessage     *TestIsInitialized_SubMessageReader

	offsetSubMessage   int

	parsedSubMessage   bool
}

func NewTestIsInitializedReader() *TestIsInitializedReader {
	return &TestIsInitializedReader{}
}

func (m *TestIsInitializedReader) GetSubMessage() *TestIsInitialized_SubMessageReader {
	if m == nil {
		return nil
	}
	return m.readSubMessage()
}

func (m *TestIsInitializedReader) readSubMessage() *TestIsInitialized_SubMessageReader {
	if m.parsedSubMessage {
		return m.dataSubMessage
	}
	wOffset := m.offsetSubMessage
	
	var entry *TestIsInitialized_SubMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestIsInitialized_SubMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataSubMessage = entry
	m.parsedSubMessage = true
	return entry
}

func (m *TestIsInitializedReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestIsInitialized_SubMessage:
			m.offsetSubMessage = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestIsInitializedReader) ToStruct() *TestIsInitialized {
	if m == nil {
		return nil
	}
	res := &TestIsInitialized{}

	{
		var data = m.GetSubMessage()
		var structData *TestIsInitialized_SubMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.SubMessage = structData
	}

	return res
}

func (s *TestIsInitializedReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestIsInitialized struct {
	SubMessage	*TestIsInitialized_SubMessage	`json:"sub_message,omitempty"`
}

func (s *TestIsInitialized) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestIsInitialized) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.SubMessage != nil {
		structSize := s.SubMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestIsInitialized_SubMessage, structSize)
		s.SubMessage.MarshalTo(res)
	}
}

func (s *TestIsInitialized) Copy() *TestIsInitialized {
	if s == nil {
		return nil
	}
	res := &TestIsInitialized{}
	if s.SubMessage != nil {
		res.SubMessage = s.SubMessage.Copy()
	}

	return res
}

func (s *TestIsInitialized) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.SubMessage != nil {
		var entrySize = 0
		entrySize = s.SubMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestIsInitialized_SubMessage)
		
		size += entrySize
	}

	return size
}

const (
)

type TestIsInitialized_SubMessageReader struct {
	buf *gremlin.Reader



}

func NewTestIsInitialized_SubMessageReader() *TestIsInitialized_SubMessageReader {
	return &TestIsInitialized_SubMessageReader{}
}

func (m *TestIsInitialized_SubMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestIsInitialized_SubMessageReader) ToStruct() *TestIsInitialized_SubMessage {
	if m == nil {
		return nil
	}
	res := &TestIsInitialized_SubMessage{}

	return res
}

func (s *TestIsInitialized_SubMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestIsInitialized_SubMessage struct {
}

func (s *TestIsInitialized_SubMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestIsInitialized_SubMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

}

func (s *TestIsInitialized_SubMessage) Copy() *TestIsInitialized_SubMessage {
	if s == nil {
		return nil
	}
	res := &TestIsInitialized_SubMessage{}

	return res
}

func (s *TestIsInitialized_SubMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	return size
}

const (
	wireTestEagerMessage_SubMessage gremlin.ProtoWireNumber = 1
)

type TestEagerMessageReader struct {
	buf *gremlin.Reader

	dataSubMessage     *TestAllTypesReader

	offsetSubMessage   int

	parsedSubMessage   bool
}

func NewTestEagerMessageReader() *TestEagerMessageReader {
	return &TestEagerMessageReader{}
}

func (m *TestEagerMessageReader) GetSubMessage() *TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readSubMessage()
}

func (m *TestEagerMessageReader) readSubMessage() *TestAllTypesReader {
	if m.parsedSubMessage {
		return m.dataSubMessage
	}
	wOffset := m.offsetSubMessage
	
	var entry *TestAllTypesReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypesReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataSubMessage = entry
	m.parsedSubMessage = true
	return entry
}

func (m *TestEagerMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestEagerMessage_SubMessage:
			m.offsetSubMessage = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestEagerMessageReader) ToStruct() *TestEagerMessage {
	if m == nil {
		return nil
	}
	res := &TestEagerMessage{}

	{
		var data = m.GetSubMessage()
		var structData *TestAllTypes
		if data != nil {
			structData = data.ToStruct()
		}
		res.SubMessage = structData
	}

	return res
}

func (s *TestEagerMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestEagerMessage struct {
	SubMessage	*TestAllTypes	`json:"sub_message,omitempty"`
}

func (s *TestEagerMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestEagerMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.SubMessage != nil {
		structSize := s.SubMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestEagerMessage_SubMessage, structSize)
		s.SubMessage.MarshalTo(res)
	}
}

func (s *TestEagerMessage) Copy() *TestEagerMessage {
	if s == nil {
		return nil
	}
	res := &TestEagerMessage{}
	if s.SubMessage != nil {
		res.SubMessage = s.SubMessage.Copy()
	}

	return res
}

func (s *TestEagerMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.SubMessage != nil {
		var entrySize = 0
		entrySize = s.SubMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestEagerMessage_SubMessage)
		
		size += entrySize
	}

	return size
}

const (
	wireTestLazyMessage_SubMessage gremlin.ProtoWireNumber = 1
)

type TestLazyMessageReader struct {
	buf *gremlin.Reader

	dataSubMessage     *TestAllTypesReader

	offsetSubMessage   int

	parsedSubMessage   bool
}

func NewTestLazyMessageReader() *TestLazyMessageReader {
	return &TestLazyMessageReader{}
}

func (m *TestLazyMessageReader) GetSubMessage() *TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readSubMessage()
}

func (m *TestLazyMessageReader) readSubMessage() *TestAllTypesReader {
	if m.parsedSubMessage {
		return m.dataSubMessage
	}
	wOffset := m.offsetSubMessage
	
	var entry *TestAllTypesReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypesReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataSubMessage = entry
	m.parsedSubMessage = true
	return entry
}

func (m *TestLazyMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestLazyMessage_SubMessage:
			m.offsetSubMessage = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestLazyMessageReader) ToStruct() *TestLazyMessage {
	if m == nil {
		return nil
	}
	res := &TestLazyMessage{}

	{
		var data = m.GetSubMessage()
		var structData *TestAllTypes
		if data != nil {
			structData = data.ToStruct()
		}
		res.SubMessage = structData
	}

	return res
}

func (s *TestLazyMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestLazyMessage struct {
	SubMessage	*TestAllTypes	`json:"sub_message,omitempty"`
}

func (s *TestLazyMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestLazyMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.SubMessage != nil {
		structSize := s.SubMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestLazyMessage_SubMessage, structSize)
		s.SubMessage.MarshalTo(res)
	}
}

func (s *TestLazyMessage) Copy() *TestLazyMessage {
	if s == nil {
		return nil
	}
	res := &TestLazyMessage{}
	if s.SubMessage != nil {
		res.SubMessage = s.SubMessage.Copy()
	}

	return res
}

func (s *TestLazyMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.SubMessage != nil {
		var entrySize = 0
		entrySize = s.SubMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestLazyMessage_SubMessage)
		
		size += entrySize
	}

	return size
}

const (
	wireTestEagerMaybeLazy_MessageFoo gremlin.ProtoWireNumber = 1
	wireTestEagerMaybeLazy_MessageBar gremlin.ProtoWireNumber = 2
	wireTestEagerMaybeLazy_MessageBaz gremlin.ProtoWireNumber = 3
)

type TestEagerMaybeLazyReader struct {
	buf *gremlin.Reader

	dataMessageFoo     *TestAllTypesReader
	dataMessageBar     *TestAllTypesReader
	dataMessageBaz     *TestEagerMaybeLazy_NestedMessageReader

	offsetMessageFoo   int
	offsetMessageBar   int
	offsetMessageBaz   int

	parsedMessageFoo   bool
	parsedMessageBar   bool
	parsedMessageBaz   bool
}

func NewTestEagerMaybeLazyReader() *TestEagerMaybeLazyReader {
	return &TestEagerMaybeLazyReader{}
}

func (m *TestEagerMaybeLazyReader) GetMessageFoo() *TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readMessageFoo()
}

func (m *TestEagerMaybeLazyReader) readMessageFoo() *TestAllTypesReader {
	if m.parsedMessageFoo {
		return m.dataMessageFoo
	}
	wOffset := m.offsetMessageFoo
	
	var entry *TestAllTypesReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypesReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataMessageFoo = entry
	m.parsedMessageFoo = true
	return entry
}

func (m *TestEagerMaybeLazyReader) GetMessageBar() *TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readMessageBar()
}

func (m *TestEagerMaybeLazyReader) readMessageBar() *TestAllTypesReader {
	if m.parsedMessageBar {
		return m.dataMessageBar
	}
	wOffset := m.offsetMessageBar
	
	var entry *TestAllTypesReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypesReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataMessageBar = entry
	m.parsedMessageBar = true
	return entry
}

func (m *TestEagerMaybeLazyReader) GetMessageBaz() *TestEagerMaybeLazy_NestedMessageReader {
	if m == nil {
		return nil
	}
	return m.readMessageBaz()
}

func (m *TestEagerMaybeLazyReader) readMessageBaz() *TestEagerMaybeLazy_NestedMessageReader {
	if m.parsedMessageBaz {
		return m.dataMessageBaz
	}
	wOffset := m.offsetMessageBaz
	
	var entry *TestEagerMaybeLazy_NestedMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestEagerMaybeLazy_NestedMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataMessageBaz = entry
	m.parsedMessageBaz = true
	return entry
}

func (m *TestEagerMaybeLazyReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestEagerMaybeLazy_MessageFoo:
			m.offsetMessageFoo = offset
		case wireTestEagerMaybeLazy_MessageBar:
			m.offsetMessageBar = offset
		case wireTestEagerMaybeLazy_MessageBaz:
			m.offsetMessageBaz = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestEagerMaybeLazyReader) ToStruct() *TestEagerMaybeLazy {
	if m == nil {
		return nil
	}
	res := &TestEagerMaybeLazy{}

	{
		var data = m.GetMessageFoo()
		var structData *TestAllTypes
		if data != nil {
			structData = data.ToStruct()
		}
		res.MessageFoo = structData
	}

	{
		var data = m.GetMessageBar()
		var structData *TestAllTypes
		if data != nil {
			structData = data.ToStruct()
		}
		res.MessageBar = structData
	}

	{
		var data = m.GetMessageBaz()
		var structData *TestEagerMaybeLazy_NestedMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.MessageBaz = structData
	}

	return res
}

func (s *TestEagerMaybeLazyReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestEagerMaybeLazy struct {
	MessageFoo	*TestAllTypes	`json:"message_foo,omitempty"`
	MessageBar	*TestAllTypes	`json:"message_bar,omitempty"`
	MessageBaz	*TestEagerMaybeLazy_NestedMessage	`json:"message_baz,omitempty"`
}

func (s *TestEagerMaybeLazy) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestEagerMaybeLazy) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.MessageFoo != nil {
		structSize := s.MessageFoo.XXX_PbContentSize()
		res.AppendBytesTag(wireTestEagerMaybeLazy_MessageFoo, structSize)
		s.MessageFoo.MarshalTo(res)
	}
	if s.MessageBar != nil {
		structSize := s.MessageBar.XXX_PbContentSize()
		res.AppendBytesTag(wireTestEagerMaybeLazy_MessageBar, structSize)
		s.MessageBar.MarshalTo(res)
	}
	if s.MessageBaz != nil {
		structSize := s.MessageBaz.XXX_PbContentSize()
		res.AppendBytesTag(wireTestEagerMaybeLazy_MessageBaz, structSize)
		s.MessageBaz.MarshalTo(res)
	}
}

func (s *TestEagerMaybeLazy) Copy() *TestEagerMaybeLazy {
	if s == nil {
		return nil
	}
	res := &TestEagerMaybeLazy{}
	if s.MessageFoo != nil {
		res.MessageFoo = s.MessageFoo.Copy()
	}
	if s.MessageBar != nil {
		res.MessageBar = s.MessageBar.Copy()
	}
	if s.MessageBaz != nil {
		res.MessageBaz = s.MessageBaz.Copy()
	}

	return res
}

func (s *TestEagerMaybeLazy) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.MessageFoo != nil {
		var entrySize = 0
		entrySize = s.MessageFoo.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestEagerMaybeLazy_MessageFoo)
		
		size += entrySize
	}

	if s.MessageBar != nil {
		var entrySize = 0
		entrySize = s.MessageBar.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestEagerMaybeLazy_MessageBar)
		
		size += entrySize
	}

	if s.MessageBaz != nil {
		var entrySize = 0
		entrySize = s.MessageBaz.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestEagerMaybeLazy_MessageBaz)
		
		size += entrySize
	}

	return size
}

const (
	wireTestEagerMaybeLazy_NestedMessage_Packed gremlin.ProtoWireNumber = 1
)

type TestEagerMaybeLazy_NestedMessageReader struct {
	buf *gremlin.Reader

	dataPacked     *TestPackedTypesReader

	offsetPacked   int

	parsedPacked   bool
}

func NewTestEagerMaybeLazy_NestedMessageReader() *TestEagerMaybeLazy_NestedMessageReader {
	return &TestEagerMaybeLazy_NestedMessageReader{}
}

func (m *TestEagerMaybeLazy_NestedMessageReader) GetPacked() *TestPackedTypesReader {
	if m == nil {
		return nil
	}
	return m.readPacked()
}

func (m *TestEagerMaybeLazy_NestedMessageReader) readPacked() *TestPackedTypesReader {
	if m.parsedPacked {
		return m.dataPacked
	}
	wOffset := m.offsetPacked
	
	var entry *TestPackedTypesReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestPackedTypesReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataPacked = entry
	m.parsedPacked = true
	return entry
}

func (m *TestEagerMaybeLazy_NestedMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestEagerMaybeLazy_NestedMessage_Packed:
			m.offsetPacked = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestEagerMaybeLazy_NestedMessageReader) ToStruct() *TestEagerMaybeLazy_NestedMessage {
	if m == nil {
		return nil
	}
	res := &TestEagerMaybeLazy_NestedMessage{}

	{
		var data = m.GetPacked()
		var structData *TestPackedTypes
		if data != nil {
			structData = data.ToStruct()
		}
		res.Packed = structData
	}

	return res
}

func (s *TestEagerMaybeLazy_NestedMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestEagerMaybeLazy_NestedMessage struct {
	Packed	*TestPackedTypes	`json:"packed,omitempty"`
}

func (s *TestEagerMaybeLazy_NestedMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestEagerMaybeLazy_NestedMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Packed != nil {
		structSize := s.Packed.XXX_PbContentSize()
		res.AppendBytesTag(wireTestEagerMaybeLazy_NestedMessage_Packed, structSize)
		s.Packed.MarshalTo(res)
	}
}

func (s *TestEagerMaybeLazy_NestedMessage) Copy() *TestEagerMaybeLazy_NestedMessage {
	if s == nil {
		return nil
	}
	res := &TestEagerMaybeLazy_NestedMessage{}
	if s.Packed != nil {
		res.Packed = s.Packed.Copy()
	}

	return res
}

func (s *TestEagerMaybeLazy_NestedMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Packed != nil {
		var entrySize = 0
		entrySize = s.Packed.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestEagerMaybeLazy_NestedMessage_Packed)
		
		size += entrySize
	}

	return size
}

const (
	wireTestNestedMessageHasBits_OptionalNestedMessage gremlin.ProtoWireNumber = 1
)

type TestNestedMessageHasBitsReader struct {
	buf *gremlin.Reader

	dataOptionalNestedMessage     *TestNestedMessageHasBits_NestedMessageReader

	offsetOptionalNestedMessage   int

	parsedOptionalNestedMessage   bool
}

func NewTestNestedMessageHasBitsReader() *TestNestedMessageHasBitsReader {
	return &TestNestedMessageHasBitsReader{}
}

func (m *TestNestedMessageHasBitsReader) GetOptionalNestedMessage() *TestNestedMessageHasBits_NestedMessageReader {
	if m == nil {
		return nil
	}
	return m.readOptionalNestedMessage()
}

func (m *TestNestedMessageHasBitsReader) readOptionalNestedMessage() *TestNestedMessageHasBits_NestedMessageReader {
	if m.parsedOptionalNestedMessage {
		return m.dataOptionalNestedMessage
	}
	wOffset := m.offsetOptionalNestedMessage
	
	var entry *TestNestedMessageHasBits_NestedMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestNestedMessageHasBits_NestedMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalNestedMessage = entry
	m.parsedOptionalNestedMessage = true
	return entry
}

func (m *TestNestedMessageHasBitsReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestNestedMessageHasBits_OptionalNestedMessage:
			m.offsetOptionalNestedMessage = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestNestedMessageHasBitsReader) ToStruct() *TestNestedMessageHasBits {
	if m == nil {
		return nil
	}
	res := &TestNestedMessageHasBits{}

	{
		var data = m.GetOptionalNestedMessage()
		var structData *TestNestedMessageHasBits_NestedMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalNestedMessage = structData
	}

	return res
}

func (s *TestNestedMessageHasBitsReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestNestedMessageHasBits struct {
	OptionalNestedMessage	*TestNestedMessageHasBits_NestedMessage	`json:"optional_nested_message,omitempty"`
}

func (s *TestNestedMessageHasBits) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestNestedMessageHasBits) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.OptionalNestedMessage != nil {
		structSize := s.OptionalNestedMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestNestedMessageHasBits_OptionalNestedMessage, structSize)
		s.OptionalNestedMessage.MarshalTo(res)
	}
}

func (s *TestNestedMessageHasBits) Copy() *TestNestedMessageHasBits {
	if s == nil {
		return nil
	}
	res := &TestNestedMessageHasBits{}
	if s.OptionalNestedMessage != nil {
		res.OptionalNestedMessage = s.OptionalNestedMessage.Copy()
	}

	return res
}

func (s *TestNestedMessageHasBits) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.OptionalNestedMessage != nil {
		var entrySize = 0
		entrySize = s.OptionalNestedMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestNestedMessageHasBits_OptionalNestedMessage)
		
		size += entrySize
	}

	return size
}

const (
	wireTestNestedMessageHasBits_NestedMessage_NestedmessageRepeatedInt32 gremlin.ProtoWireNumber = 1
	wireTestNestedMessageHasBits_NestedMessage_NestedmessageRepeatedForeignmessage gremlin.ProtoWireNumber = 2
)

type TestNestedMessageHasBits_NestedMessageReader struct {
	buf *gremlin.Reader

	dataNestedmessageRepeatedInt32     []int32
	dataNestedmessageRepeatedForeignmessage     []*ForeignMessageReader

	offsetNestedmessageRepeatedInt32   []int
	wireTypeNestedmessageRepeatedInt32 []gremlin.ProtoWireType
	offsetNestedmessageRepeatedForeignmessage   []int

	parsedNestedmessageRepeatedInt32   bool
	parsedNestedmessageRepeatedForeignmessage   bool
}

func NewTestNestedMessageHasBits_NestedMessageReader() *TestNestedMessageHasBits_NestedMessageReader {
	return &TestNestedMessageHasBits_NestedMessageReader{}
}

func (m *TestNestedMessageHasBits_NestedMessageReader) GetNestedmessageRepeatedInt32() []int32 {
	if m == nil {
		return nil
	}
	return m.readNestedmessageRepeatedInt32()
}

func (m *TestNestedMessageHasBits_NestedMessageReader) readNestedmessageRepeatedInt32() []int32 {
	if m.parsedNestedmessageRepeatedInt32 {
		return m.dataNestedmessageRepeatedInt32
	}
	wOffset := m.offsetNestedmessageRepeatedInt32
	var wType = m.wireTypeNestedmessageRepeatedInt32
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadInt32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataNestedmessageRepeatedInt32 = entry
	m.parsedNestedmessageRepeatedInt32 = true
	return entry
}

func (m *TestNestedMessageHasBits_NestedMessageReader) GetNestedmessageRepeatedForeignmessage() []*ForeignMessageReader {
	if m == nil {
		return nil
	}
	return m.readNestedmessageRepeatedForeignmessage()
}

func (m *TestNestedMessageHasBits_NestedMessageReader) readNestedmessageRepeatedForeignmessage() []*ForeignMessageReader {
	if m.parsedNestedmessageRepeatedForeignmessage {
		return m.dataNestedmessageRepeatedForeignmessage
	}
	wOffset := m.offsetNestedmessageRepeatedForeignmessage
	
	var entry []*ForeignMessageReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *ForeignMessageReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewForeignMessageReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataNestedmessageRepeatedForeignmessage = entry
	m.parsedNestedmessageRepeatedForeignmessage = true
	return entry
}

func (m *TestNestedMessageHasBits_NestedMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestNestedMessageHasBits_NestedMessage_NestedmessageRepeatedInt32:
			m.offsetNestedmessageRepeatedInt32 = append(m.offsetNestedmessageRepeatedInt32, offset)
			m.wireTypeNestedmessageRepeatedInt32 = append(m.wireTypeNestedmessageRepeatedInt32, wire)
		case wireTestNestedMessageHasBits_NestedMessage_NestedmessageRepeatedForeignmessage:
			m.offsetNestedmessageRepeatedForeignmessage = append(m.offsetNestedmessageRepeatedForeignmessage, offset)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestNestedMessageHasBits_NestedMessageReader) ToStruct() *TestNestedMessageHasBits_NestedMessage {
	if m == nil {
		return nil
	}
	res := &TestNestedMessageHasBits_NestedMessage{}
	res.NestedmessageRepeatedInt32 = m.GetNestedmessageRepeatedInt32()

	{
		var data = m.GetNestedmessageRepeatedForeignmessage()
		var structData []*ForeignMessage
		if len(data) > 0 {
			structData = make([]*ForeignMessage, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.NestedmessageRepeatedForeignmessage = structData
	}

	return res
}

func (s *TestNestedMessageHasBits_NestedMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestNestedMessageHasBits_NestedMessage struct {
	NestedmessageRepeatedInt32	[]int32	`json:"nestedmessage_repeated_int32,omitempty"`
	NestedmessageRepeatedForeignmessage	[]*ForeignMessage	`json:"nestedmessage_repeated_foreignmessage,omitempty"`
}

func (s *TestNestedMessageHasBits_NestedMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestNestedMessageHasBits_NestedMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if len(s.NestedmessageRepeatedInt32) > 0 {
		if len(s.NestedmessageRepeatedInt32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.NestedmessageRepeatedInt32 {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestNestedMessageHasBits_NestedMessage_NestedmessageRepeatedInt32, listBytesSize)
			for _, entry := range s.NestedmessageRepeatedInt32 {
				res.AppendInt32WithoutTag(entry)
			}
		} else if len(s.NestedmessageRepeatedInt32) == 1 {
			res.AppendInt32(wireTestNestedMessageHasBits_NestedMessage_NestedmessageRepeatedInt32, s.NestedmessageRepeatedInt32[0])
		}
	}
	if len(s.NestedmessageRepeatedForeignmessage) > 0 {
		for _, entry := range s.NestedmessageRepeatedForeignmessage {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireTestNestedMessageHasBits_NestedMessage_NestedmessageRepeatedForeignmessage, structSize)
			entry.MarshalTo(res)
		}
	}
}

func (s *TestNestedMessageHasBits_NestedMessage) Copy() *TestNestedMessageHasBits_NestedMessage {
	if s == nil {
		return nil
	}
	res := &TestNestedMessageHasBits_NestedMessage{}
	res.NestedmessageRepeatedInt32 = s.NestedmessageRepeatedInt32
	res.NestedmessageRepeatedForeignmessage = make([]*ForeignMessage, len(s.NestedmessageRepeatedForeignmessage))
	for i := range s.NestedmessageRepeatedForeignmessage {
		if s.NestedmessageRepeatedForeignmessage[i] != nil {
			res.NestedmessageRepeatedForeignmessage[i] = s.NestedmessageRepeatedForeignmessage[i].Copy()
		}
	}

	return res
}

func (s *TestNestedMessageHasBits_NestedMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if len(s.NestedmessageRepeatedInt32) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.NestedmessageRepeatedInt32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.NestedmessageRepeatedInt32 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestNestedMessageHasBits_NestedMessage_NestedmessageRepeatedInt32) + listBytesSize
		} else if len(s.NestedmessageRepeatedInt32) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestNestedMessageHasBits_NestedMessage_NestedmessageRepeatedInt32) + gremlin.SizeInt32(s.NestedmessageRepeatedInt32[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.NestedmessageRepeatedForeignmessage) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.NestedmessageRepeatedForeignmessage {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestNestedMessageHasBits_NestedMessage_NestedmessageRepeatedForeignmessage)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	return size
}

const (
	wireTestCamelCaseFieldNames_PrimitiveField gremlin.ProtoWireNumber = 1
	wireTestCamelCaseFieldNames_StringField gremlin.ProtoWireNumber = 2
	wireTestCamelCaseFieldNames_EnumField gremlin.ProtoWireNumber = 3
	wireTestCamelCaseFieldNames_MessageField gremlin.ProtoWireNumber = 4
	wireTestCamelCaseFieldNames_StringPieceField gremlin.ProtoWireNumber = 5
	wireTestCamelCaseFieldNames_CordField gremlin.ProtoWireNumber = 6
	wireTestCamelCaseFieldNames_RepeatedPrimitiveField gremlin.ProtoWireNumber = 7
	wireTestCamelCaseFieldNames_RepeatedStringField gremlin.ProtoWireNumber = 8
	wireTestCamelCaseFieldNames_RepeatedEnumField gremlin.ProtoWireNumber = 9
	wireTestCamelCaseFieldNames_RepeatedMessageField gremlin.ProtoWireNumber = 10
	wireTestCamelCaseFieldNames_RepeatedStringPieceField gremlin.ProtoWireNumber = 11
	wireTestCamelCaseFieldNames_RepeatedCordField gremlin.ProtoWireNumber = 12
)

type TestCamelCaseFieldNamesReader struct {
	buf *gremlin.Reader

	dataPrimitiveField     int32
	dataStringField     string
	dataEnumField     ForeignEnum
	dataMessageField     *ForeignMessageReader
	dataStringPieceField     string
	dataCordField     string
	dataRepeatedPrimitiveField     []int32
	dataRepeatedStringField     []string
	dataRepeatedEnumField     []ForeignEnum
	dataRepeatedMessageField     []*ForeignMessageReader
	dataRepeatedStringPieceField     []string
	dataRepeatedCordField     []string

	offsetPrimitiveField   int
	offsetStringField   int
	offsetEnumField   int
	offsetMessageField   int
	offsetStringPieceField   int
	offsetCordField   int
	offsetRepeatedPrimitiveField   []int
	wireTypeRepeatedPrimitiveField []gremlin.ProtoWireType
	offsetRepeatedStringField   []int
	offsetRepeatedEnumField   []int
	wireTypeRepeatedEnumField []gremlin.ProtoWireType
	offsetRepeatedMessageField   []int
	offsetRepeatedStringPieceField   []int
	offsetRepeatedCordField   []int

	parsedPrimitiveField   bool
	parsedStringField   bool
	parsedEnumField   bool
	parsedMessageField   bool
	parsedStringPieceField   bool
	parsedCordField   bool
	parsedRepeatedPrimitiveField   bool
	parsedRepeatedStringField   bool
	parsedRepeatedEnumField   bool
	parsedRepeatedMessageField   bool
	parsedRepeatedStringPieceField   bool
	parsedRepeatedCordField   bool
}

func NewTestCamelCaseFieldNamesReader() *TestCamelCaseFieldNamesReader {
	return &TestCamelCaseFieldNamesReader{}
}

func (m *TestCamelCaseFieldNamesReader) GetPrimitiveField() int32 {
	if m == nil {
		return 0
	}
	return m.readPrimitiveField()
}

func (m *TestCamelCaseFieldNamesReader) readPrimitiveField() int32 {
	if m.parsedPrimitiveField {
		return m.dataPrimitiveField
	}
	wOffset := m.offsetPrimitiveField
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataPrimitiveField = entry
	m.parsedPrimitiveField = true
	return entry
}

func (m *TestCamelCaseFieldNamesReader) GetStringField() string {
	if m == nil {
		return ""
	}
	return m.readStringField()
}

func (m *TestCamelCaseFieldNamesReader) readStringField() string {
	if m.parsedStringField {
		return m.dataStringField
	}
	wOffset := m.offsetStringField
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStringField = entry
	m.parsedStringField = true
	return entry
}

func (m *TestCamelCaseFieldNamesReader) GetEnumField() ForeignEnum {
	if m == nil {
		return 0
	}
	return m.readEnumField()
}

func (m *TestCamelCaseFieldNamesReader) readEnumField() ForeignEnum {
	if m.parsedEnumField {
		return m.dataEnumField
	}
	wOffset := m.offsetEnumField
	
	var entry ForeignEnum
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = ForeignEnum(rawEntry)
	} else {
		entry = 0
	}
	
	m.dataEnumField = entry
	m.parsedEnumField = true
	return entry
}

func (m *TestCamelCaseFieldNamesReader) GetMessageField() *ForeignMessageReader {
	if m == nil {
		return nil
	}
	return m.readMessageField()
}

func (m *TestCamelCaseFieldNamesReader) readMessageField() *ForeignMessageReader {
	if m.parsedMessageField {
		return m.dataMessageField
	}
	wOffset := m.offsetMessageField
	
	var entry *ForeignMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewForeignMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataMessageField = entry
	m.parsedMessageField = true
	return entry
}

func (m *TestCamelCaseFieldNamesReader) GetStringPieceField() string {
	if m == nil {
		return ""
	}
	return m.readStringPieceField()
}

func (m *TestCamelCaseFieldNamesReader) readStringPieceField() string {
	if m.parsedStringPieceField {
		return m.dataStringPieceField
	}
	wOffset := m.offsetStringPieceField
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStringPieceField = entry
	m.parsedStringPieceField = true
	return entry
}

func (m *TestCamelCaseFieldNamesReader) GetCordField() string {
	if m == nil {
		return ""
	}
	return m.readCordField()
}

func (m *TestCamelCaseFieldNamesReader) readCordField() string {
	if m.parsedCordField {
		return m.dataCordField
	}
	wOffset := m.offsetCordField
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataCordField = entry
	m.parsedCordField = true
	return entry
}

func (m *TestCamelCaseFieldNamesReader) GetRepeatedPrimitiveField() []int32 {
	if m == nil {
		return nil
	}
	return m.readRepeatedPrimitiveField()
}

func (m *TestCamelCaseFieldNamesReader) readRepeatedPrimitiveField() []int32 {
	if m.parsedRepeatedPrimitiveField {
		return m.dataRepeatedPrimitiveField
	}
	wOffset := m.offsetRepeatedPrimitiveField
	var wType = m.wireTypeRepeatedPrimitiveField
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadInt32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedPrimitiveField = entry
	m.parsedRepeatedPrimitiveField = true
	return entry
}

func (m *TestCamelCaseFieldNamesReader) GetRepeatedStringField() []string {
	if m == nil {
		return nil
	}
	return m.readRepeatedStringField()
}

func (m *TestCamelCaseFieldNamesReader) readRepeatedStringField() []string {
	if m.parsedRepeatedStringField {
		return m.dataRepeatedStringField
	}
	wOffset := m.offsetRepeatedStringField
	
	var entry []string
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry string
		if wOffset > 0 {
			listEntry = m.buf.ReadString(wOffset)
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedStringField = entry
	m.parsedRepeatedStringField = true
	return entry
}

func (m *TestCamelCaseFieldNamesReader) GetRepeatedEnumField() []ForeignEnum {
	if m == nil {
		return nil
	}
	return m.readRepeatedEnumField()
}

func (m *TestCamelCaseFieldNamesReader) readRepeatedEnumField() []ForeignEnum {
	if m.parsedRepeatedEnumField {
		return m.dataRepeatedEnumField
	}
	wOffset := m.offsetRepeatedEnumField
	var wType = m.wireTypeRepeatedEnumField
	
	var entry []ForeignEnum
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry ForeignEnum
				var listEntrySize int
				if wOffset > 0 {
					rawEntry, size := m.buf.SizedReadInt32(wOffset)
					listEntry = ForeignEnum(rawEntry)
					listEntrySize = size
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry ForeignEnum
			if wOffset > 0 {
				rawEntry := m.buf.ReadInt32(wOffset)
				listEntry = ForeignEnum(rawEntry)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedEnumField = entry
	m.parsedRepeatedEnumField = true
	return entry
}

func (m *TestCamelCaseFieldNamesReader) GetRepeatedMessageField() []*ForeignMessageReader {
	if m == nil {
		return nil
	}
	return m.readRepeatedMessageField()
}

func (m *TestCamelCaseFieldNamesReader) readRepeatedMessageField() []*ForeignMessageReader {
	if m.parsedRepeatedMessageField {
		return m.dataRepeatedMessageField
	}
	wOffset := m.offsetRepeatedMessageField
	
	var entry []*ForeignMessageReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *ForeignMessageReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewForeignMessageReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedMessageField = entry
	m.parsedRepeatedMessageField = true
	return entry
}

func (m *TestCamelCaseFieldNamesReader) GetRepeatedStringPieceField() []string {
	if m == nil {
		return nil
	}
	return m.readRepeatedStringPieceField()
}

func (m *TestCamelCaseFieldNamesReader) readRepeatedStringPieceField() []string {
	if m.parsedRepeatedStringPieceField {
		return m.dataRepeatedStringPieceField
	}
	wOffset := m.offsetRepeatedStringPieceField
	
	var entry []string
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry string
		if wOffset > 0 {
			listEntry = m.buf.ReadString(wOffset)
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedStringPieceField = entry
	m.parsedRepeatedStringPieceField = true
	return entry
}

func (m *TestCamelCaseFieldNamesReader) GetRepeatedCordField() []string {
	if m == nil {
		return nil
	}
	return m.readRepeatedCordField()
}

func (m *TestCamelCaseFieldNamesReader) readRepeatedCordField() []string {
	if m.parsedRepeatedCordField {
		return m.dataRepeatedCordField
	}
	wOffset := m.offsetRepeatedCordField
	
	var entry []string
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry string
		if wOffset > 0 {
			listEntry = m.buf.ReadString(wOffset)
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedCordField = entry
	m.parsedRepeatedCordField = true
	return entry
}

func (m *TestCamelCaseFieldNamesReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestCamelCaseFieldNames_PrimitiveField:
			m.offsetPrimitiveField = offset
		case wireTestCamelCaseFieldNames_StringField:
			m.offsetStringField = offset
		case wireTestCamelCaseFieldNames_EnumField:
			m.offsetEnumField = offset
		case wireTestCamelCaseFieldNames_MessageField:
			m.offsetMessageField = offset
		case wireTestCamelCaseFieldNames_StringPieceField:
			m.offsetStringPieceField = offset
		case wireTestCamelCaseFieldNames_CordField:
			m.offsetCordField = offset
		case wireTestCamelCaseFieldNames_RepeatedPrimitiveField:
			m.offsetRepeatedPrimitiveField = append(m.offsetRepeatedPrimitiveField, offset)
			m.wireTypeRepeatedPrimitiveField = append(m.wireTypeRepeatedPrimitiveField, wire)
		case wireTestCamelCaseFieldNames_RepeatedStringField:
			m.offsetRepeatedStringField = append(m.offsetRepeatedStringField, offset)
		case wireTestCamelCaseFieldNames_RepeatedEnumField:
			m.offsetRepeatedEnumField = append(m.offsetRepeatedEnumField, offset)
			m.wireTypeRepeatedEnumField = append(m.wireTypeRepeatedEnumField, wire)
		case wireTestCamelCaseFieldNames_RepeatedMessageField:
			m.offsetRepeatedMessageField = append(m.offsetRepeatedMessageField, offset)
		case wireTestCamelCaseFieldNames_RepeatedStringPieceField:
			m.offsetRepeatedStringPieceField = append(m.offsetRepeatedStringPieceField, offset)
		case wireTestCamelCaseFieldNames_RepeatedCordField:
			m.offsetRepeatedCordField = append(m.offsetRepeatedCordField, offset)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestCamelCaseFieldNamesReader) ToStruct() *TestCamelCaseFieldNames {
	if m == nil {
		return nil
	}
	res := &TestCamelCaseFieldNames{}
	res.PrimitiveField = m.GetPrimitiveField()
	res.StringField = m.GetStringField()
	res.EnumField = m.GetEnumField()

	{
		var data = m.GetMessageField()
		var structData *ForeignMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.MessageField = structData
	}
	res.StringPieceField = m.GetStringPieceField()
	res.CordField = m.GetCordField()
	res.RepeatedPrimitiveField = m.GetRepeatedPrimitiveField()
	res.RepeatedStringField = m.GetRepeatedStringField()
	res.RepeatedEnumField = m.GetRepeatedEnumField()

	{
		var data = m.GetRepeatedMessageField()
		var structData []*ForeignMessage
		if len(data) > 0 {
			structData = make([]*ForeignMessage, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.RepeatedMessageField = structData
	}
	res.RepeatedStringPieceField = m.GetRepeatedStringPieceField()
	res.RepeatedCordField = m.GetRepeatedCordField()

	return res
}

func (s *TestCamelCaseFieldNamesReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestCamelCaseFieldNames struct {
	PrimitiveField	int32	`json:"PrimitiveField,omitempty"`
	StringField	string	`json:"StringField,omitempty"`
	EnumField	ForeignEnum	`json:"EnumField,omitempty"`
	MessageField	*ForeignMessage	`json:"MessageField,omitempty"`
	StringPieceField	string	`json:"StringPieceField,omitempty"`
	CordField	string	`json:"CordField,omitempty"`
	RepeatedPrimitiveField	[]int32	`json:"RepeatedPrimitiveField,omitempty"`
	RepeatedStringField	[]string	`json:"RepeatedStringField,omitempty"`
	RepeatedEnumField	[]ForeignEnum	`json:"RepeatedEnumField,omitempty"`
	RepeatedMessageField	[]*ForeignMessage	`json:"RepeatedMessageField,omitempty"`
	RepeatedStringPieceField	[]string	`json:"RepeatedStringPieceField,omitempty"`
	RepeatedCordField	[]string	`json:"RepeatedCordField,omitempty"`
}

func (s *TestCamelCaseFieldNames) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestCamelCaseFieldNames) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.PrimitiveField != 0 {
		res.AppendInt32(wireTestCamelCaseFieldNames_PrimitiveField, s.PrimitiveField)
	}
	if s.StringField != "" {
		res.AppendString(wireTestCamelCaseFieldNames_StringField, s.StringField)
	}
	if s.EnumField != 0 {
		res.AppendInt32(wireTestCamelCaseFieldNames_EnumField, int32(s.EnumField))
	}
	if s.MessageField != nil {
		structSize := s.MessageField.XXX_PbContentSize()
		res.AppendBytesTag(wireTestCamelCaseFieldNames_MessageField, structSize)
		s.MessageField.MarshalTo(res)
	}
	if s.StringPieceField != "" {
		res.AppendString(wireTestCamelCaseFieldNames_StringPieceField, s.StringPieceField)
	}
	if s.CordField != "" {
		res.AppendString(wireTestCamelCaseFieldNames_CordField, s.CordField)
	}
	if len(s.RepeatedPrimitiveField) > 0 {
		if len(s.RepeatedPrimitiveField) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedPrimitiveField {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestCamelCaseFieldNames_RepeatedPrimitiveField, listBytesSize)
			for _, entry := range s.RepeatedPrimitiveField {
				res.AppendInt32WithoutTag(entry)
			}
		} else if len(s.RepeatedPrimitiveField) == 1 {
			res.AppendInt32(wireTestCamelCaseFieldNames_RepeatedPrimitiveField, s.RepeatedPrimitiveField[0])
		}
	}
	if len(s.RepeatedStringField) > 0 {
		for _, entry := range s.RepeatedStringField {
			res.AppendString(wireTestCamelCaseFieldNames_RepeatedStringField, entry)
		}
	}
	if len(s.RepeatedEnumField) > 0 {
		if len(s.RepeatedEnumField) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedEnumField {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(int32(entry))
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestCamelCaseFieldNames_RepeatedEnumField, listBytesSize)
			for _, entry := range s.RepeatedEnumField {
				res.AppendInt32WithoutTag(int32(entry))
			}
		} else if len(s.RepeatedEnumField) == 1 {
			res.AppendInt32(wireTestCamelCaseFieldNames_RepeatedEnumField, int32(s.RepeatedEnumField[0]))
		}
	}
	if len(s.RepeatedMessageField) > 0 {
		for _, entry := range s.RepeatedMessageField {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireTestCamelCaseFieldNames_RepeatedMessageField, structSize)
			entry.MarshalTo(res)
		}
	}
	if len(s.RepeatedStringPieceField) > 0 {
		for _, entry := range s.RepeatedStringPieceField {
			res.AppendString(wireTestCamelCaseFieldNames_RepeatedStringPieceField, entry)
		}
	}
	if len(s.RepeatedCordField) > 0 {
		for _, entry := range s.RepeatedCordField {
			res.AppendString(wireTestCamelCaseFieldNames_RepeatedCordField, entry)
		}
	}
}

func (s *TestCamelCaseFieldNames) Copy() *TestCamelCaseFieldNames {
	if s == nil {
		return nil
	}
	res := &TestCamelCaseFieldNames{}
	res.PrimitiveField = s.PrimitiveField
	res.StringField = s.StringField
	res.EnumField = s.EnumField
	if s.MessageField != nil {
		res.MessageField = s.MessageField.Copy()
	}
	res.StringPieceField = s.StringPieceField
	res.CordField = s.CordField
	res.RepeatedPrimitiveField = s.RepeatedPrimitiveField
	res.RepeatedStringField = s.RepeatedStringField
	res.RepeatedEnumField = s.RepeatedEnumField
	res.RepeatedMessageField = make([]*ForeignMessage, len(s.RepeatedMessageField))
	for i := range s.RepeatedMessageField {
		if s.RepeatedMessageField[i] != nil {
			res.RepeatedMessageField[i] = s.RepeatedMessageField[i].Copy()
		}
	}
	res.RepeatedStringPieceField = s.RepeatedStringPieceField
	res.RepeatedCordField = s.RepeatedCordField

	return res
}

func (s *TestCamelCaseFieldNames) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.PrimitiveField != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestCamelCaseFieldNames_PrimitiveField) + gremlin.SizeInt32(s.PrimitiveField)
		size += entrySize
	}

	if s.StringField != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.StringField)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestCamelCaseFieldNames_StringField)
		size += entrySize
	}

	if s.EnumField != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestCamelCaseFieldNames_EnumField) + gremlin.SizeInt32(int32(s.EnumField))
		size += entrySize
	}

	if s.MessageField != nil {
		var entrySize = 0
		entrySize = s.MessageField.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestCamelCaseFieldNames_MessageField)
		
		size += entrySize
	}

	if s.StringPieceField != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.StringPieceField)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestCamelCaseFieldNames_StringPieceField)
		size += entrySize
	}

	if s.CordField != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.CordField)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestCamelCaseFieldNames_CordField)
		size += entrySize
	}

	if len(s.RepeatedPrimitiveField) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedPrimitiveField) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedPrimitiveField {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestCamelCaseFieldNames_RepeatedPrimitiveField) + listBytesSize
		} else if len(s.RepeatedPrimitiveField) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestCamelCaseFieldNames_RepeatedPrimitiveField) + gremlin.SizeInt32(s.RepeatedPrimitiveField[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedStringField) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedStringField {
			var listEntrySize int
			listEntrySize = gremlin.SizeString(val)
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestCamelCaseFieldNames_RepeatedStringField)
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedEnumField) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedEnumField) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedEnumField {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(int32(entry))
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestCamelCaseFieldNames_RepeatedEnumField) + listBytesSize
		} else if len(s.RepeatedEnumField) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestCamelCaseFieldNames_RepeatedEnumField) + gremlin.SizeInt32(int32(s.RepeatedEnumField[0]))
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedMessageField) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedMessageField {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestCamelCaseFieldNames_RepeatedMessageField)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedStringPieceField) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedStringPieceField {
			var listEntrySize int
			listEntrySize = gremlin.SizeString(val)
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestCamelCaseFieldNames_RepeatedStringPieceField)
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedCordField) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedCordField {
			var listEntrySize int
			listEntrySize = gremlin.SizeString(val)
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestCamelCaseFieldNames_RepeatedCordField)
			entrySize += listEntrySize
		}
		size += entrySize
	}

	return size
}

const (
	wireTestFieldOrderings_NestedMessage_Oo gremlin.ProtoWireNumber = 2
	wireTestFieldOrderings_NestedMessage_Bb gremlin.ProtoWireNumber = 1
)

type TestFieldOrderings_NestedMessageReader struct {
	buf *gremlin.Reader

	dataOo     int64
	dataBb     int32

	offsetOo   int
	offsetBb   int

	parsedOo   bool
	parsedBb   bool
}

func NewTestFieldOrderings_NestedMessageReader() *TestFieldOrderings_NestedMessageReader {
	return &TestFieldOrderings_NestedMessageReader{}
}

func (m *TestFieldOrderings_NestedMessageReader) GetOo() int64 {
	if m == nil {
		return 0
	}
	return m.readOo()
}

func (m *TestFieldOrderings_NestedMessageReader) readOo() int64 {
	if m.parsedOo {
		return m.dataOo
	}
	wOffset := m.offsetOo
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadInt64(wOffset)
	}
	
	m.dataOo = entry
	m.parsedOo = true
	return entry
}

func (m *TestFieldOrderings_NestedMessageReader) GetBb() int32 {
	if m == nil {
		return 0
	}
	return m.readBb()
}

func (m *TestFieldOrderings_NestedMessageReader) readBb() int32 {
	if m.parsedBb {
		return m.dataBb
	}
	wOffset := m.offsetBb
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataBb = entry
	m.parsedBb = true
	return entry
}

func (m *TestFieldOrderings_NestedMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestFieldOrderings_NestedMessage_Oo:
			m.offsetOo = offset
		case wireTestFieldOrderings_NestedMessage_Bb:
			m.offsetBb = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestFieldOrderings_NestedMessageReader) ToStruct() *TestFieldOrderings_NestedMessage {
	if m == nil {
		return nil
	}
	res := &TestFieldOrderings_NestedMessage{}
	res.Oo = m.GetOo()
	res.Bb = m.GetBb()

	return res
}

func (s *TestFieldOrderings_NestedMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestFieldOrderings_NestedMessage struct {
	Oo	int64	`json:"oo,omitempty"`
	Bb	int32	`json:"bb,omitempty"`
}

func (s *TestFieldOrderings_NestedMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestFieldOrderings_NestedMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Oo != 0 {
		res.AppendInt64(wireTestFieldOrderings_NestedMessage_Oo, s.Oo)
	}
	if s.Bb != 0 {
		res.AppendInt32(wireTestFieldOrderings_NestedMessage_Bb, s.Bb)
	}
}

func (s *TestFieldOrderings_NestedMessage) Copy() *TestFieldOrderings_NestedMessage {
	if s == nil {
		return nil
	}
	res := &TestFieldOrderings_NestedMessage{}
	res.Oo = s.Oo
	res.Bb = s.Bb

	return res
}

func (s *TestFieldOrderings_NestedMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Oo != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestFieldOrderings_NestedMessage_Oo) + gremlin.SizeInt64(s.Oo)
		size += entrySize
	}

	if s.Bb != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestFieldOrderings_NestedMessage_Bb) + gremlin.SizeInt32(s.Bb)
		size += entrySize
	}

	return size
}

const (
	wireTestFieldOrderings_MyExtensionString gremlin.ProtoWireNumber = 50
	wireTestFieldOrderings_MyExtensionInt gremlin.ProtoWireNumber = 5
	wireTestFieldOrderings_MyString gremlin.ProtoWireNumber = 11
	wireTestFieldOrderings_MyInt gremlin.ProtoWireNumber = 1
	wireTestFieldOrderings_MyFloat gremlin.ProtoWireNumber = 101
	wireTestFieldOrderings_OptionalNestedMessage gremlin.ProtoWireNumber = 200
)

type TestFieldOrderingsReader struct {
	buf *gremlin.Reader

	dataMyExtensionString     string
	dataMyExtensionInt     int32
	dataMyString     string
	dataMyInt     int64
	dataMyFloat     float32
	dataOptionalNestedMessage     *TestFieldOrderings_NestedMessageReader

	offsetMyExtensionString   int
	offsetMyExtensionInt   int
	offsetMyString   int
	offsetMyInt   int
	offsetMyFloat   int
	offsetOptionalNestedMessage   int

	parsedMyExtensionString   bool
	parsedMyExtensionInt   bool
	parsedMyString   bool
	parsedMyInt   bool
	parsedMyFloat   bool
	parsedOptionalNestedMessage   bool
}

func NewTestFieldOrderingsReader() *TestFieldOrderingsReader {
	return &TestFieldOrderingsReader{}
}

func (m *TestFieldOrderingsReader) GetMyExtensionString() string {
	if m == nil {
		return ""
	}
	return m.readMyExtensionString()
}

func (m *TestFieldOrderingsReader) readMyExtensionString() string {
	if m.parsedMyExtensionString {
		return m.dataMyExtensionString
	}
	wOffset := m.offsetMyExtensionString
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataMyExtensionString = entry
	m.parsedMyExtensionString = true
	return entry
}

func (m *TestFieldOrderingsReader) GetMyExtensionInt() int32 {
	if m == nil {
		return 0
	}
	return m.readMyExtensionInt()
}

func (m *TestFieldOrderingsReader) readMyExtensionInt() int32 {
	if m.parsedMyExtensionInt {
		return m.dataMyExtensionInt
	}
	wOffset := m.offsetMyExtensionInt
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataMyExtensionInt = entry
	m.parsedMyExtensionInt = true
	return entry
}

func (m *TestFieldOrderingsReader) GetMyString() string {
	if m == nil {
		return ""
	}
	return m.readMyString()
}

func (m *TestFieldOrderingsReader) readMyString() string {
	if m.parsedMyString {
		return m.dataMyString
	}
	wOffset := m.offsetMyString
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataMyString = entry
	m.parsedMyString = true
	return entry
}

func (m *TestFieldOrderingsReader) GetMyInt() int64 {
	if m == nil {
		return 0
	}
	return m.readMyInt()
}

func (m *TestFieldOrderingsReader) readMyInt() int64 {
	if m.parsedMyInt {
		return m.dataMyInt
	}
	wOffset := m.offsetMyInt
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadInt64(wOffset)
	}
	
	m.dataMyInt = entry
	m.parsedMyInt = true
	return entry
}

func (m *TestFieldOrderingsReader) GetMyFloat() float32 {
	if m == nil {
		return 0
	}
	return m.readMyFloat()
}

func (m *TestFieldOrderingsReader) readMyFloat() float32 {
	if m.parsedMyFloat {
		return m.dataMyFloat
	}
	wOffset := m.offsetMyFloat
	
	var entry float32
	if wOffset > 0 {
		entry = m.buf.ReadFloat32(wOffset)
	}
	
	m.dataMyFloat = entry
	m.parsedMyFloat = true
	return entry
}

func (m *TestFieldOrderingsReader) GetOptionalNestedMessage() *TestFieldOrderings_NestedMessageReader {
	if m == nil {
		return nil
	}
	return m.readOptionalNestedMessage()
}

func (m *TestFieldOrderingsReader) readOptionalNestedMessage() *TestFieldOrderings_NestedMessageReader {
	if m.parsedOptionalNestedMessage {
		return m.dataOptionalNestedMessage
	}
	wOffset := m.offsetOptionalNestedMessage
	
	var entry *TestFieldOrderings_NestedMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestFieldOrderings_NestedMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalNestedMessage = entry
	m.parsedOptionalNestedMessage = true
	return entry
}

func (m *TestFieldOrderingsReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestFieldOrderings_MyExtensionString:
			m.offsetMyExtensionString = offset
		case wireTestFieldOrderings_MyExtensionInt:
			m.offsetMyExtensionInt = offset
		case wireTestFieldOrderings_MyString:
			m.offsetMyString = offset
		case wireTestFieldOrderings_MyInt:
			m.offsetMyInt = offset
		case wireTestFieldOrderings_MyFloat:
			m.offsetMyFloat = offset
		case wireTestFieldOrderings_OptionalNestedMessage:
			m.offsetOptionalNestedMessage = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestFieldOrderingsReader) ToStruct() *TestFieldOrderings {
	if m == nil {
		return nil
	}
	res := &TestFieldOrderings{}
	res.MyExtensionString = m.GetMyExtensionString()
	res.MyExtensionInt = m.GetMyExtensionInt()
	res.MyString = m.GetMyString()
	res.MyInt = m.GetMyInt()
	res.MyFloat = m.GetMyFloat()

	{
		var data = m.GetOptionalNestedMessage()
		var structData *TestFieldOrderings_NestedMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalNestedMessage = structData
	}

	return res
}

func (s *TestFieldOrderingsReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestFieldOrderings struct {
	MyExtensionString	string	`json:"my_extension_string,omitempty"`
	MyExtensionInt	int32	`json:"my_extension_int,omitempty"`
	MyString	string	`json:"my_string,omitempty"`
	MyInt	int64	`json:"my_int,omitempty"`
	MyFloat	float32	`json:"my_float,omitempty"`
	OptionalNestedMessage	*TestFieldOrderings_NestedMessage	`json:"optional_nested_message,omitempty"`
}

func (s *TestFieldOrderings) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestFieldOrderings) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.MyExtensionString != "" {
		res.AppendString(wireTestFieldOrderings_MyExtensionString, s.MyExtensionString)
	}
	if s.MyExtensionInt != 0 {
		res.AppendInt32(wireTestFieldOrderings_MyExtensionInt, s.MyExtensionInt)
	}
	if s.MyString != "" {
		res.AppendString(wireTestFieldOrderings_MyString, s.MyString)
	}
	if s.MyInt != 0 {
		res.AppendInt64(wireTestFieldOrderings_MyInt, s.MyInt)
	}
	if s.MyFloat != 0 {
		res.AppendFloat32(wireTestFieldOrderings_MyFloat, s.MyFloat)
	}
	if s.OptionalNestedMessage != nil {
		structSize := s.OptionalNestedMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestFieldOrderings_OptionalNestedMessage, structSize)
		s.OptionalNestedMessage.MarshalTo(res)
	}
}

func (s *TestFieldOrderings) Copy() *TestFieldOrderings {
	if s == nil {
		return nil
	}
	res := &TestFieldOrderings{}
	res.MyExtensionString = s.MyExtensionString
	res.MyExtensionInt = s.MyExtensionInt
	res.MyString = s.MyString
	res.MyInt = s.MyInt
	res.MyFloat = s.MyFloat
	if s.OptionalNestedMessage != nil {
		res.OptionalNestedMessage = s.OptionalNestedMessage.Copy()
	}

	return res
}

func (s *TestFieldOrderings) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.MyExtensionString != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.MyExtensionString)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestFieldOrderings_MyExtensionString)
		size += entrySize
	}

	if s.MyExtensionInt != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestFieldOrderings_MyExtensionInt) + gremlin.SizeInt32(s.MyExtensionInt)
		size += entrySize
	}

	if s.MyString != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.MyString)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestFieldOrderings_MyString)
		size += entrySize
	}

	if s.MyInt != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestFieldOrderings_MyInt) + gremlin.SizeInt64(s.MyInt)
		size += entrySize
	}

	if s.MyFloat != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestFieldOrderings_MyFloat) + gremlin.SizeFloat32(s.MyFloat)
		size += entrySize
	}

	if s.OptionalNestedMessage != nil {
		var entrySize = 0
		entrySize = s.OptionalNestedMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestFieldOrderings_OptionalNestedMessage)
		
		size += entrySize
	}

	return size
}

const (
	wireTestExtensionOrderings1_MyString gremlin.ProtoWireNumber = 1
)

type TestExtensionOrderings1Reader struct {
	buf *gremlin.Reader

	dataMyString     string

	offsetMyString   int

	parsedMyString   bool
}

func NewTestExtensionOrderings1Reader() *TestExtensionOrderings1Reader {
	return &TestExtensionOrderings1Reader{}
}

func (m *TestExtensionOrderings1Reader) GetMyString() string {
	if m == nil {
		return ""
	}
	return m.readMyString()
}

func (m *TestExtensionOrderings1Reader) readMyString() string {
	if m.parsedMyString {
		return m.dataMyString
	}
	wOffset := m.offsetMyString
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataMyString = entry
	m.parsedMyString = true
	return entry
}

func (m *TestExtensionOrderings1Reader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestExtensionOrderings1_MyString:
			m.offsetMyString = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestExtensionOrderings1Reader) ToStruct() *TestExtensionOrderings1 {
	if m == nil {
		return nil
	}
	res := &TestExtensionOrderings1{}
	res.MyString = m.GetMyString()

	return res
}

func (s *TestExtensionOrderings1Reader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestExtensionOrderings1 struct {
	MyString	string	`json:"my_string,omitempty"`
}

func (s *TestExtensionOrderings1) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestExtensionOrderings1) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.MyString != "" {
		res.AppendString(wireTestExtensionOrderings1_MyString, s.MyString)
	}
}

func (s *TestExtensionOrderings1) Copy() *TestExtensionOrderings1 {
	if s == nil {
		return nil
	}
	res := &TestExtensionOrderings1{}
	res.MyString = s.MyString

	return res
}

func (s *TestExtensionOrderings1) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.MyString != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.MyString)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestExtensionOrderings1_MyString)
		size += entrySize
	}

	return size
}

const (
	wireTestExtensionOrderings1_TestFieldOrderings_TestExtOrderings1 gremlin.ProtoWireNumber = 13
	wireTestExtensionOrderings1_TestFieldOrderings_MyString gremlin.ProtoWireNumber = 11
	wireTestExtensionOrderings1_TestFieldOrderings_MyInt gremlin.ProtoWireNumber = 1
	wireTestExtensionOrderings1_TestFieldOrderings_MyFloat gremlin.ProtoWireNumber = 101
	wireTestExtensionOrderings1_TestFieldOrderings_OptionalNestedMessage gremlin.ProtoWireNumber = 200
)

type TestExtensionOrderings1_TestFieldOrderingsReader struct {
	buf *gremlin.Reader

	dataTestExtOrderings1     *TestExtensionOrderings1Reader
	dataMyString     string
	dataMyInt     int64
	dataMyFloat     float32
	dataOptionalNestedMessage     *TestFieldOrderingsReader

	offsetTestExtOrderings1   int
	offsetMyString   int
	offsetMyInt   int
	offsetMyFloat   int
	offsetOptionalNestedMessage   int

	parsedTestExtOrderings1   bool
	parsedMyString   bool
	parsedMyInt   bool
	parsedMyFloat   bool
	parsedOptionalNestedMessage   bool
}

func NewTestExtensionOrderings1_TestFieldOrderingsReader() *TestExtensionOrderings1_TestFieldOrderingsReader {
	return &TestExtensionOrderings1_TestFieldOrderingsReader{}
}

func (m *TestExtensionOrderings1_TestFieldOrderingsReader) GetTestExtOrderings1() *TestExtensionOrderings1Reader {
	if m == nil {
		return nil
	}
	return m.readTestExtOrderings1()
}

func (m *TestExtensionOrderings1_TestFieldOrderingsReader) readTestExtOrderings1() *TestExtensionOrderings1Reader {
	if m.parsedTestExtOrderings1 {
		return m.dataTestExtOrderings1
	}
	wOffset := m.offsetTestExtOrderings1
	
	var entry *TestExtensionOrderings1Reader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestExtensionOrderings1Reader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataTestExtOrderings1 = entry
	m.parsedTestExtOrderings1 = true
	return entry
}

func (m *TestExtensionOrderings1_TestFieldOrderingsReader) GetMyString() string {
	if m == nil {
		return ""
	}
	return m.readMyString()
}

func (m *TestExtensionOrderings1_TestFieldOrderingsReader) readMyString() string {
	if m.parsedMyString {
		return m.dataMyString
	}
	wOffset := m.offsetMyString
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataMyString = entry
	m.parsedMyString = true
	return entry
}

func (m *TestExtensionOrderings1_TestFieldOrderingsReader) GetMyInt() int64 {
	if m == nil {
		return 0
	}
	return m.readMyInt()
}

func (m *TestExtensionOrderings1_TestFieldOrderingsReader) readMyInt() int64 {
	if m.parsedMyInt {
		return m.dataMyInt
	}
	wOffset := m.offsetMyInt
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadInt64(wOffset)
	}
	
	m.dataMyInt = entry
	m.parsedMyInt = true
	return entry
}

func (m *TestExtensionOrderings1_TestFieldOrderingsReader) GetMyFloat() float32 {
	if m == nil {
		return 0
	}
	return m.readMyFloat()
}

func (m *TestExtensionOrderings1_TestFieldOrderingsReader) readMyFloat() float32 {
	if m.parsedMyFloat {
		return m.dataMyFloat
	}
	wOffset := m.offsetMyFloat
	
	var entry float32
	if wOffset > 0 {
		entry = m.buf.ReadFloat32(wOffset)
	}
	
	m.dataMyFloat = entry
	m.parsedMyFloat = true
	return entry
}

func (m *TestExtensionOrderings1_TestFieldOrderingsReader) GetOptionalNestedMessage() *TestFieldOrderingsReader {
	if m == nil {
		return nil
	}
	return m.readOptionalNestedMessage()
}

func (m *TestExtensionOrderings1_TestFieldOrderingsReader) readOptionalNestedMessage() *TestFieldOrderingsReader {
	if m.parsedOptionalNestedMessage {
		return m.dataOptionalNestedMessage
	}
	wOffset := m.offsetOptionalNestedMessage
	
	var entry *TestFieldOrderingsReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestFieldOrderingsReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalNestedMessage = entry
	m.parsedOptionalNestedMessage = true
	return entry
}

func (m *TestExtensionOrderings1_TestFieldOrderingsReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestExtensionOrderings1_TestFieldOrderings_TestExtOrderings1:
			m.offsetTestExtOrderings1 = offset
		case wireTestExtensionOrderings1_TestFieldOrderings_MyString:
			m.offsetMyString = offset
		case wireTestExtensionOrderings1_TestFieldOrderings_MyInt:
			m.offsetMyInt = offset
		case wireTestExtensionOrderings1_TestFieldOrderings_MyFloat:
			m.offsetMyFloat = offset
		case wireTestExtensionOrderings1_TestFieldOrderings_OptionalNestedMessage:
			m.offsetOptionalNestedMessage = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestExtensionOrderings1_TestFieldOrderingsReader) ToStruct() *TestExtensionOrderings1_TestFieldOrderings {
	if m == nil {
		return nil
	}
	res := &TestExtensionOrderings1_TestFieldOrderings{}

	{
		var data = m.GetTestExtOrderings1()
		var structData *TestExtensionOrderings1
		if data != nil {
			structData = data.ToStruct()
		}
		res.TestExtOrderings1 = structData
	}
	res.MyString = m.GetMyString()
	res.MyInt = m.GetMyInt()
	res.MyFloat = m.GetMyFloat()

	{
		var data = m.GetOptionalNestedMessage()
		var structData *TestFieldOrderings
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalNestedMessage = structData
	}

	return res
}

func (s *TestExtensionOrderings1_TestFieldOrderingsReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestExtensionOrderings1_TestFieldOrderings struct {
	TestExtOrderings1	*TestExtensionOrderings1	`json:"test_ext_orderings1,omitempty"`
	MyString	string	`json:"my_string,omitempty"`
	MyInt	int64	`json:"my_int,omitempty"`
	MyFloat	float32	`json:"my_float,omitempty"`
	OptionalNestedMessage	*TestFieldOrderings	`json:"optional_nested_message,omitempty"`
}

func (s *TestExtensionOrderings1_TestFieldOrderings) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestExtensionOrderings1_TestFieldOrderings) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.TestExtOrderings1 != nil {
		structSize := s.TestExtOrderings1.XXX_PbContentSize()
		res.AppendBytesTag(wireTestExtensionOrderings1_TestFieldOrderings_TestExtOrderings1, structSize)
		s.TestExtOrderings1.MarshalTo(res)
	}
	if s.MyString != "" {
		res.AppendString(wireTestExtensionOrderings1_TestFieldOrderings_MyString, s.MyString)
	}
	if s.MyInt != 0 {
		res.AppendInt64(wireTestExtensionOrderings1_TestFieldOrderings_MyInt, s.MyInt)
	}
	if s.MyFloat != 0 {
		res.AppendFloat32(wireTestExtensionOrderings1_TestFieldOrderings_MyFloat, s.MyFloat)
	}
	if s.OptionalNestedMessage != nil {
		structSize := s.OptionalNestedMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestExtensionOrderings1_TestFieldOrderings_OptionalNestedMessage, structSize)
		s.OptionalNestedMessage.MarshalTo(res)
	}
}

func (s *TestExtensionOrderings1_TestFieldOrderings) Copy() *TestExtensionOrderings1_TestFieldOrderings {
	if s == nil {
		return nil
	}
	res := &TestExtensionOrderings1_TestFieldOrderings{}
	if s.TestExtOrderings1 != nil {
		res.TestExtOrderings1 = s.TestExtOrderings1.Copy()
	}
	res.MyString = s.MyString
	res.MyInt = s.MyInt
	res.MyFloat = s.MyFloat
	if s.OptionalNestedMessage != nil {
		res.OptionalNestedMessage = s.OptionalNestedMessage.Copy()
	}

	return res
}

func (s *TestExtensionOrderings1_TestFieldOrderings) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.TestExtOrderings1 != nil {
		var entrySize = 0
		entrySize = s.TestExtOrderings1.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestExtensionOrderings1_TestFieldOrderings_TestExtOrderings1)
		
		size += entrySize
	}

	if s.MyString != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.MyString)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestExtensionOrderings1_TestFieldOrderings_MyString)
		size += entrySize
	}

	if s.MyInt != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionOrderings1_TestFieldOrderings_MyInt) + gremlin.SizeInt64(s.MyInt)
		size += entrySize
	}

	if s.MyFloat != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionOrderings1_TestFieldOrderings_MyFloat) + gremlin.SizeFloat32(s.MyFloat)
		size += entrySize
	}

	if s.OptionalNestedMessage != nil {
		var entrySize = 0
		entrySize = s.OptionalNestedMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestExtensionOrderings1_TestFieldOrderings_OptionalNestedMessage)
		
		size += entrySize
	}

	return size
}

const (
	wireTestExtensionOrderings2_MyString gremlin.ProtoWireNumber = 1
)

type TestExtensionOrderings2Reader struct {
	buf *gremlin.Reader

	dataMyString     string

	offsetMyString   int

	parsedMyString   bool
}

func NewTestExtensionOrderings2Reader() *TestExtensionOrderings2Reader {
	return &TestExtensionOrderings2Reader{}
}

func (m *TestExtensionOrderings2Reader) GetMyString() string {
	if m == nil {
		return ""
	}
	return m.readMyString()
}

func (m *TestExtensionOrderings2Reader) readMyString() string {
	if m.parsedMyString {
		return m.dataMyString
	}
	wOffset := m.offsetMyString
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataMyString = entry
	m.parsedMyString = true
	return entry
}

func (m *TestExtensionOrderings2Reader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestExtensionOrderings2_MyString:
			m.offsetMyString = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestExtensionOrderings2Reader) ToStruct() *TestExtensionOrderings2 {
	if m == nil {
		return nil
	}
	res := &TestExtensionOrderings2{}
	res.MyString = m.GetMyString()

	return res
}

func (s *TestExtensionOrderings2Reader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestExtensionOrderings2 struct {
	MyString	string	`json:"my_string,omitempty"`
}

func (s *TestExtensionOrderings2) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestExtensionOrderings2) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.MyString != "" {
		res.AppendString(wireTestExtensionOrderings2_MyString, s.MyString)
	}
}

func (s *TestExtensionOrderings2) Copy() *TestExtensionOrderings2 {
	if s == nil {
		return nil
	}
	res := &TestExtensionOrderings2{}
	res.MyString = s.MyString

	return res
}

func (s *TestExtensionOrderings2) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.MyString != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.MyString)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestExtensionOrderings2_MyString)
		size += entrySize
	}

	return size
}

const (
	wireTestExtensionOrderings2_TestFieldOrderings_TestExtOrderings2 gremlin.ProtoWireNumber = 12
	wireTestExtensionOrderings2_TestFieldOrderings_MyString gremlin.ProtoWireNumber = 11
	wireTestExtensionOrderings2_TestFieldOrderings_MyInt gremlin.ProtoWireNumber = 1
	wireTestExtensionOrderings2_TestFieldOrderings_MyFloat gremlin.ProtoWireNumber = 101
	wireTestExtensionOrderings2_TestFieldOrderings_OptionalNestedMessage gremlin.ProtoWireNumber = 200
)

type TestExtensionOrderings2_TestFieldOrderingsReader struct {
	buf *gremlin.Reader

	dataTestExtOrderings2     *TestExtensionOrderings2Reader
	dataMyString     string
	dataMyInt     int64
	dataMyFloat     float32
	dataOptionalNestedMessage     *TestFieldOrderingsReader

	offsetTestExtOrderings2   int
	offsetMyString   int
	offsetMyInt   int
	offsetMyFloat   int
	offsetOptionalNestedMessage   int

	parsedTestExtOrderings2   bool
	parsedMyString   bool
	parsedMyInt   bool
	parsedMyFloat   bool
	parsedOptionalNestedMessage   bool
}

func NewTestExtensionOrderings2_TestFieldOrderingsReader() *TestExtensionOrderings2_TestFieldOrderingsReader {
	return &TestExtensionOrderings2_TestFieldOrderingsReader{}
}

func (m *TestExtensionOrderings2_TestFieldOrderingsReader) GetTestExtOrderings2() *TestExtensionOrderings2Reader {
	if m == nil {
		return nil
	}
	return m.readTestExtOrderings2()
}

func (m *TestExtensionOrderings2_TestFieldOrderingsReader) readTestExtOrderings2() *TestExtensionOrderings2Reader {
	if m.parsedTestExtOrderings2 {
		return m.dataTestExtOrderings2
	}
	wOffset := m.offsetTestExtOrderings2
	
	var entry *TestExtensionOrderings2Reader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestExtensionOrderings2Reader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataTestExtOrderings2 = entry
	m.parsedTestExtOrderings2 = true
	return entry
}

func (m *TestExtensionOrderings2_TestFieldOrderingsReader) GetMyString() string {
	if m == nil {
		return ""
	}
	return m.readMyString()
}

func (m *TestExtensionOrderings2_TestFieldOrderingsReader) readMyString() string {
	if m.parsedMyString {
		return m.dataMyString
	}
	wOffset := m.offsetMyString
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataMyString = entry
	m.parsedMyString = true
	return entry
}

func (m *TestExtensionOrderings2_TestFieldOrderingsReader) GetMyInt() int64 {
	if m == nil {
		return 0
	}
	return m.readMyInt()
}

func (m *TestExtensionOrderings2_TestFieldOrderingsReader) readMyInt() int64 {
	if m.parsedMyInt {
		return m.dataMyInt
	}
	wOffset := m.offsetMyInt
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadInt64(wOffset)
	}
	
	m.dataMyInt = entry
	m.parsedMyInt = true
	return entry
}

func (m *TestExtensionOrderings2_TestFieldOrderingsReader) GetMyFloat() float32 {
	if m == nil {
		return 0
	}
	return m.readMyFloat()
}

func (m *TestExtensionOrderings2_TestFieldOrderingsReader) readMyFloat() float32 {
	if m.parsedMyFloat {
		return m.dataMyFloat
	}
	wOffset := m.offsetMyFloat
	
	var entry float32
	if wOffset > 0 {
		entry = m.buf.ReadFloat32(wOffset)
	}
	
	m.dataMyFloat = entry
	m.parsedMyFloat = true
	return entry
}

func (m *TestExtensionOrderings2_TestFieldOrderingsReader) GetOptionalNestedMessage() *TestFieldOrderingsReader {
	if m == nil {
		return nil
	}
	return m.readOptionalNestedMessage()
}

func (m *TestExtensionOrderings2_TestFieldOrderingsReader) readOptionalNestedMessage() *TestFieldOrderingsReader {
	if m.parsedOptionalNestedMessage {
		return m.dataOptionalNestedMessage
	}
	wOffset := m.offsetOptionalNestedMessage
	
	var entry *TestFieldOrderingsReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestFieldOrderingsReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalNestedMessage = entry
	m.parsedOptionalNestedMessage = true
	return entry
}

func (m *TestExtensionOrderings2_TestFieldOrderingsReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestExtensionOrderings2_TestFieldOrderings_TestExtOrderings2:
			m.offsetTestExtOrderings2 = offset
		case wireTestExtensionOrderings2_TestFieldOrderings_MyString:
			m.offsetMyString = offset
		case wireTestExtensionOrderings2_TestFieldOrderings_MyInt:
			m.offsetMyInt = offset
		case wireTestExtensionOrderings2_TestFieldOrderings_MyFloat:
			m.offsetMyFloat = offset
		case wireTestExtensionOrderings2_TestFieldOrderings_OptionalNestedMessage:
			m.offsetOptionalNestedMessage = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestExtensionOrderings2_TestFieldOrderingsReader) ToStruct() *TestExtensionOrderings2_TestFieldOrderings {
	if m == nil {
		return nil
	}
	res := &TestExtensionOrderings2_TestFieldOrderings{}

	{
		var data = m.GetTestExtOrderings2()
		var structData *TestExtensionOrderings2
		if data != nil {
			structData = data.ToStruct()
		}
		res.TestExtOrderings2 = structData
	}
	res.MyString = m.GetMyString()
	res.MyInt = m.GetMyInt()
	res.MyFloat = m.GetMyFloat()

	{
		var data = m.GetOptionalNestedMessage()
		var structData *TestFieldOrderings
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalNestedMessage = structData
	}

	return res
}

func (s *TestExtensionOrderings2_TestFieldOrderingsReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestExtensionOrderings2_TestFieldOrderings struct {
	TestExtOrderings2	*TestExtensionOrderings2	`json:"test_ext_orderings2,omitempty"`
	MyString	string	`json:"my_string,omitempty"`
	MyInt	int64	`json:"my_int,omitempty"`
	MyFloat	float32	`json:"my_float,omitempty"`
	OptionalNestedMessage	*TestFieldOrderings	`json:"optional_nested_message,omitempty"`
}

func (s *TestExtensionOrderings2_TestFieldOrderings) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestExtensionOrderings2_TestFieldOrderings) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.TestExtOrderings2 != nil {
		structSize := s.TestExtOrderings2.XXX_PbContentSize()
		res.AppendBytesTag(wireTestExtensionOrderings2_TestFieldOrderings_TestExtOrderings2, structSize)
		s.TestExtOrderings2.MarshalTo(res)
	}
	if s.MyString != "" {
		res.AppendString(wireTestExtensionOrderings2_TestFieldOrderings_MyString, s.MyString)
	}
	if s.MyInt != 0 {
		res.AppendInt64(wireTestExtensionOrderings2_TestFieldOrderings_MyInt, s.MyInt)
	}
	if s.MyFloat != 0 {
		res.AppendFloat32(wireTestExtensionOrderings2_TestFieldOrderings_MyFloat, s.MyFloat)
	}
	if s.OptionalNestedMessage != nil {
		structSize := s.OptionalNestedMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestExtensionOrderings2_TestFieldOrderings_OptionalNestedMessage, structSize)
		s.OptionalNestedMessage.MarshalTo(res)
	}
}

func (s *TestExtensionOrderings2_TestFieldOrderings) Copy() *TestExtensionOrderings2_TestFieldOrderings {
	if s == nil {
		return nil
	}
	res := &TestExtensionOrderings2_TestFieldOrderings{}
	if s.TestExtOrderings2 != nil {
		res.TestExtOrderings2 = s.TestExtOrderings2.Copy()
	}
	res.MyString = s.MyString
	res.MyInt = s.MyInt
	res.MyFloat = s.MyFloat
	if s.OptionalNestedMessage != nil {
		res.OptionalNestedMessage = s.OptionalNestedMessage.Copy()
	}

	return res
}

func (s *TestExtensionOrderings2_TestFieldOrderings) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.TestExtOrderings2 != nil {
		var entrySize = 0
		entrySize = s.TestExtOrderings2.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestExtensionOrderings2_TestFieldOrderings_TestExtOrderings2)
		
		size += entrySize
	}

	if s.MyString != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.MyString)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestExtensionOrderings2_TestFieldOrderings_MyString)
		size += entrySize
	}

	if s.MyInt != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionOrderings2_TestFieldOrderings_MyInt) + gremlin.SizeInt64(s.MyInt)
		size += entrySize
	}

	if s.MyFloat != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionOrderings2_TestFieldOrderings_MyFloat) + gremlin.SizeFloat32(s.MyFloat)
		size += entrySize
	}

	if s.OptionalNestedMessage != nil {
		var entrySize = 0
		entrySize = s.OptionalNestedMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestExtensionOrderings2_TestFieldOrderings_OptionalNestedMessage)
		
		size += entrySize
	}

	return size
}

const (
	wireTestExtensionOrderings2_TestExtensionOrderings3_MyString gremlin.ProtoWireNumber = 1
)

type TestExtensionOrderings2_TestExtensionOrderings3Reader struct {
	buf *gremlin.Reader

	dataMyString     string

	offsetMyString   int

	parsedMyString   bool
}

func NewTestExtensionOrderings2_TestExtensionOrderings3Reader() *TestExtensionOrderings2_TestExtensionOrderings3Reader {
	return &TestExtensionOrderings2_TestExtensionOrderings3Reader{}
}

func (m *TestExtensionOrderings2_TestExtensionOrderings3Reader) GetMyString() string {
	if m == nil {
		return ""
	}
	return m.readMyString()
}

func (m *TestExtensionOrderings2_TestExtensionOrderings3Reader) readMyString() string {
	if m.parsedMyString {
		return m.dataMyString
	}
	wOffset := m.offsetMyString
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataMyString = entry
	m.parsedMyString = true
	return entry
}

func (m *TestExtensionOrderings2_TestExtensionOrderings3Reader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestExtensionOrderings2_TestExtensionOrderings3_MyString:
			m.offsetMyString = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestExtensionOrderings2_TestExtensionOrderings3Reader) ToStruct() *TestExtensionOrderings2_TestExtensionOrderings3 {
	if m == nil {
		return nil
	}
	res := &TestExtensionOrderings2_TestExtensionOrderings3{}
	res.MyString = m.GetMyString()

	return res
}

func (s *TestExtensionOrderings2_TestExtensionOrderings3Reader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestExtensionOrderings2_TestExtensionOrderings3 struct {
	MyString	string	`json:"my_string,omitempty"`
}

func (s *TestExtensionOrderings2_TestExtensionOrderings3) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestExtensionOrderings2_TestExtensionOrderings3) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.MyString != "" {
		res.AppendString(wireTestExtensionOrderings2_TestExtensionOrderings3_MyString, s.MyString)
	}
}

func (s *TestExtensionOrderings2_TestExtensionOrderings3) Copy() *TestExtensionOrderings2_TestExtensionOrderings3 {
	if s == nil {
		return nil
	}
	res := &TestExtensionOrderings2_TestExtensionOrderings3{}
	res.MyString = s.MyString

	return res
}

func (s *TestExtensionOrderings2_TestExtensionOrderings3) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.MyString != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.MyString)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestExtensionOrderings2_TestExtensionOrderings3_MyString)
		size += entrySize
	}

	return size
}

const (
	wireTestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings_TestExtOrderings3 gremlin.ProtoWireNumber = 14
	wireTestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings_MyString gremlin.ProtoWireNumber = 11
	wireTestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings_MyInt gremlin.ProtoWireNumber = 1
	wireTestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings_MyFloat gremlin.ProtoWireNumber = 101
	wireTestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings_OptionalNestedMessage gremlin.ProtoWireNumber = 200
)

type TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderingsReader struct {
	buf *gremlin.Reader

	dataTestExtOrderings3     *TestExtensionOrderings2_TestExtensionOrderings3Reader
	dataMyString     string
	dataMyInt     int64
	dataMyFloat     float32
	dataOptionalNestedMessage     *TestFieldOrderingsReader

	offsetTestExtOrderings3   int
	offsetMyString   int
	offsetMyInt   int
	offsetMyFloat   int
	offsetOptionalNestedMessage   int

	parsedTestExtOrderings3   bool
	parsedMyString   bool
	parsedMyInt   bool
	parsedMyFloat   bool
	parsedOptionalNestedMessage   bool
}

func NewTestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderingsReader() *TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderingsReader {
	return &TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderingsReader{}
}

func (m *TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderingsReader) GetTestExtOrderings3() *TestExtensionOrderings2_TestExtensionOrderings3Reader {
	if m == nil {
		return nil
	}
	return m.readTestExtOrderings3()
}

func (m *TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderingsReader) readTestExtOrderings3() *TestExtensionOrderings2_TestExtensionOrderings3Reader {
	if m.parsedTestExtOrderings3 {
		return m.dataTestExtOrderings3
	}
	wOffset := m.offsetTestExtOrderings3
	
	var entry *TestExtensionOrderings2_TestExtensionOrderings3Reader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestExtensionOrderings2_TestExtensionOrderings3Reader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataTestExtOrderings3 = entry
	m.parsedTestExtOrderings3 = true
	return entry
}

func (m *TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderingsReader) GetMyString() string {
	if m == nil {
		return ""
	}
	return m.readMyString()
}

func (m *TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderingsReader) readMyString() string {
	if m.parsedMyString {
		return m.dataMyString
	}
	wOffset := m.offsetMyString
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataMyString = entry
	m.parsedMyString = true
	return entry
}

func (m *TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderingsReader) GetMyInt() int64 {
	if m == nil {
		return 0
	}
	return m.readMyInt()
}

func (m *TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderingsReader) readMyInt() int64 {
	if m.parsedMyInt {
		return m.dataMyInt
	}
	wOffset := m.offsetMyInt
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadInt64(wOffset)
	}
	
	m.dataMyInt = entry
	m.parsedMyInt = true
	return entry
}

func (m *TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderingsReader) GetMyFloat() float32 {
	if m == nil {
		return 0
	}
	return m.readMyFloat()
}

func (m *TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderingsReader) readMyFloat() float32 {
	if m.parsedMyFloat {
		return m.dataMyFloat
	}
	wOffset := m.offsetMyFloat
	
	var entry float32
	if wOffset > 0 {
		entry = m.buf.ReadFloat32(wOffset)
	}
	
	m.dataMyFloat = entry
	m.parsedMyFloat = true
	return entry
}

func (m *TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderingsReader) GetOptionalNestedMessage() *TestFieldOrderingsReader {
	if m == nil {
		return nil
	}
	return m.readOptionalNestedMessage()
}

func (m *TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderingsReader) readOptionalNestedMessage() *TestFieldOrderingsReader {
	if m.parsedOptionalNestedMessage {
		return m.dataOptionalNestedMessage
	}
	wOffset := m.offsetOptionalNestedMessage
	
	var entry *TestFieldOrderingsReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestFieldOrderingsReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalNestedMessage = entry
	m.parsedOptionalNestedMessage = true
	return entry
}

func (m *TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderingsReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings_TestExtOrderings3:
			m.offsetTestExtOrderings3 = offset
		case wireTestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings_MyString:
			m.offsetMyString = offset
		case wireTestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings_MyInt:
			m.offsetMyInt = offset
		case wireTestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings_MyFloat:
			m.offsetMyFloat = offset
		case wireTestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings_OptionalNestedMessage:
			m.offsetOptionalNestedMessage = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderingsReader) ToStruct() *TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings {
	if m == nil {
		return nil
	}
	res := &TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings{}

	{
		var data = m.GetTestExtOrderings3()
		var structData *TestExtensionOrderings2_TestExtensionOrderings3
		if data != nil {
			structData = data.ToStruct()
		}
		res.TestExtOrderings3 = structData
	}
	res.MyString = m.GetMyString()
	res.MyInt = m.GetMyInt()
	res.MyFloat = m.GetMyFloat()

	{
		var data = m.GetOptionalNestedMessage()
		var structData *TestFieldOrderings
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalNestedMessage = structData
	}

	return res
}

func (s *TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderingsReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings struct {
	TestExtOrderings3	*TestExtensionOrderings2_TestExtensionOrderings3	`json:"test_ext_orderings3,omitempty"`
	MyString	string	`json:"my_string,omitempty"`
	MyInt	int64	`json:"my_int,omitempty"`
	MyFloat	float32	`json:"my_float,omitempty"`
	OptionalNestedMessage	*TestFieldOrderings	`json:"optional_nested_message,omitempty"`
}

func (s *TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.TestExtOrderings3 != nil {
		structSize := s.TestExtOrderings3.XXX_PbContentSize()
		res.AppendBytesTag(wireTestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings_TestExtOrderings3, structSize)
		s.TestExtOrderings3.MarshalTo(res)
	}
	if s.MyString != "" {
		res.AppendString(wireTestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings_MyString, s.MyString)
	}
	if s.MyInt != 0 {
		res.AppendInt64(wireTestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings_MyInt, s.MyInt)
	}
	if s.MyFloat != 0 {
		res.AppendFloat32(wireTestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings_MyFloat, s.MyFloat)
	}
	if s.OptionalNestedMessage != nil {
		structSize := s.OptionalNestedMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings_OptionalNestedMessage, structSize)
		s.OptionalNestedMessage.MarshalTo(res)
	}
}

func (s *TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings) Copy() *TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings {
	if s == nil {
		return nil
	}
	res := &TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings{}
	if s.TestExtOrderings3 != nil {
		res.TestExtOrderings3 = s.TestExtOrderings3.Copy()
	}
	res.MyString = s.MyString
	res.MyInt = s.MyInt
	res.MyFloat = s.MyFloat
	if s.OptionalNestedMessage != nil {
		res.OptionalNestedMessage = s.OptionalNestedMessage.Copy()
	}

	return res
}

func (s *TestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.TestExtOrderings3 != nil {
		var entrySize = 0
		entrySize = s.TestExtOrderings3.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings_TestExtOrderings3)
		
		size += entrySize
	}

	if s.MyString != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.MyString)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings_MyString)
		size += entrySize
	}

	if s.MyInt != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings_MyInt) + gremlin.SizeInt64(s.MyInt)
		size += entrySize
	}

	if s.MyFloat != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings_MyFloat) + gremlin.SizeFloat32(s.MyFloat)
		size += entrySize
	}

	if s.OptionalNestedMessage != nil {
		var entrySize = 0
		entrySize = s.OptionalNestedMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestExtensionOrderings2_TestExtensionOrderings3_TestFieldOrderings_OptionalNestedMessage)
		
		size += entrySize
	}

	return size
}

const (
	wireTestExtremeDefaultValues_EscapedBytes gremlin.ProtoWireNumber = 1
	wireTestExtremeDefaultValues_LargeUint32 gremlin.ProtoWireNumber = 2
	wireTestExtremeDefaultValues_LargeUint64 gremlin.ProtoWireNumber = 3
	wireTestExtremeDefaultValues_SmallInt32 gremlin.ProtoWireNumber = 4
	wireTestExtremeDefaultValues_SmallInt64 gremlin.ProtoWireNumber = 5
	wireTestExtremeDefaultValues_ReallySmallInt32 gremlin.ProtoWireNumber = 21
	wireTestExtremeDefaultValues_ReallySmallInt64 gremlin.ProtoWireNumber = 22
	wireTestExtremeDefaultValues_Utf8String gremlin.ProtoWireNumber = 6
	wireTestExtremeDefaultValues_ZeroFloat gremlin.ProtoWireNumber = 7
	wireTestExtremeDefaultValues_OneFloat gremlin.ProtoWireNumber = 8
	wireTestExtremeDefaultValues_SmallFloat gremlin.ProtoWireNumber = 9
	wireTestExtremeDefaultValues_NegativeOneFloat gremlin.ProtoWireNumber = 10
	wireTestExtremeDefaultValues_NegativeFloat gremlin.ProtoWireNumber = 11
	wireTestExtremeDefaultValues_LargeFloat gremlin.ProtoWireNumber = 12
	wireTestExtremeDefaultValues_SmallNegativeFloat gremlin.ProtoWireNumber = 13
	wireTestExtremeDefaultValues_InfDouble gremlin.ProtoWireNumber = 14
	wireTestExtremeDefaultValues_NegInfDouble gremlin.ProtoWireNumber = 15
	wireTestExtremeDefaultValues_NanDouble gremlin.ProtoWireNumber = 16
	wireTestExtremeDefaultValues_InfFloat gremlin.ProtoWireNumber = 17
	wireTestExtremeDefaultValues_NegInfFloat gremlin.ProtoWireNumber = 18
	wireTestExtremeDefaultValues_NanFloat gremlin.ProtoWireNumber = 19
	wireTestExtremeDefaultValues_CppTrigraph gremlin.ProtoWireNumber = 20
	wireTestExtremeDefaultValues_StringWithZero gremlin.ProtoWireNumber = 23
	wireTestExtremeDefaultValues_BytesWithZero gremlin.ProtoWireNumber = 24
	wireTestExtremeDefaultValues_StringPieceWithZero gremlin.ProtoWireNumber = 25
	wireTestExtremeDefaultValues_CordWithZero gremlin.ProtoWireNumber = 26
	wireTestExtremeDefaultValues_ReplacementString gremlin.ProtoWireNumber = 27
)

type TestExtremeDefaultValuesReader struct {
	buf *gremlin.Reader

	dataEscapedBytes     []byte
	dataLargeUint32     uint32
	dataLargeUint64     uint64
	dataSmallInt32     int32
	dataSmallInt64     int64
	dataReallySmallInt32     int32
	dataReallySmallInt64     int64
	dataUtf8String     string
	dataZeroFloat     float32
	dataOneFloat     float32
	dataSmallFloat     float32
	dataNegativeOneFloat     float32
	dataNegativeFloat     float32
	dataLargeFloat     float32
	dataSmallNegativeFloat     float32
	dataInfDouble     float64
	dataNegInfDouble     float64
	dataNanDouble     float64
	dataInfFloat     float32
	dataNegInfFloat     float32
	dataNanFloat     float32
	dataCppTrigraph     string
	dataStringWithZero     string
	dataBytesWithZero     []byte
	dataStringPieceWithZero     string
	dataCordWithZero     string
	dataReplacementString     string

	offsetEscapedBytes   int
	offsetLargeUint32   int
	offsetLargeUint64   int
	offsetSmallInt32   int
	offsetSmallInt64   int
	offsetReallySmallInt32   int
	offsetReallySmallInt64   int
	offsetUtf8String   int
	offsetZeroFloat   int
	offsetOneFloat   int
	offsetSmallFloat   int
	offsetNegativeOneFloat   int
	offsetNegativeFloat   int
	offsetLargeFloat   int
	offsetSmallNegativeFloat   int
	offsetInfDouble   int
	offsetNegInfDouble   int
	offsetNanDouble   int
	offsetInfFloat   int
	offsetNegInfFloat   int
	offsetNanFloat   int
	offsetCppTrigraph   int
	offsetStringWithZero   int
	offsetBytesWithZero   int
	offsetStringPieceWithZero   int
	offsetCordWithZero   int
	offsetReplacementString   int

	parsedEscapedBytes   bool
	parsedLargeUint32   bool
	parsedLargeUint64   bool
	parsedSmallInt32   bool
	parsedSmallInt64   bool
	parsedReallySmallInt32   bool
	parsedReallySmallInt64   bool
	parsedUtf8String   bool
	parsedZeroFloat   bool
	parsedOneFloat   bool
	parsedSmallFloat   bool
	parsedNegativeOneFloat   bool
	parsedNegativeFloat   bool
	parsedLargeFloat   bool
	parsedSmallNegativeFloat   bool
	parsedInfDouble   bool
	parsedNegInfDouble   bool
	parsedNanDouble   bool
	parsedInfFloat   bool
	parsedNegInfFloat   bool
	parsedNanFloat   bool
	parsedCppTrigraph   bool
	parsedStringWithZero   bool
	parsedBytesWithZero   bool
	parsedStringPieceWithZero   bool
	parsedCordWithZero   bool
	parsedReplacementString   bool
}

func NewTestExtremeDefaultValuesReader() *TestExtremeDefaultValuesReader {
	return &TestExtremeDefaultValuesReader{}
}

func (m *TestExtremeDefaultValuesReader) GetEscapedBytes() []byte {
	if m == nil {
		return []byte("\\0\\001\\a\\b\\f\\n\\r\\t\\v\\\\\\'\\\"\\xfe")
	}
	return m.readEscapedBytes()
}

func (m *TestExtremeDefaultValuesReader) readEscapedBytes() []byte {
	if m.parsedEscapedBytes {
		return m.dataEscapedBytes
	}
	wOffset := m.offsetEscapedBytes
	
	var entry []byte
	if wOffset > 0 {
		entry = m.buf.ReadBytes(wOffset)
	} else {
		entry = []byte("\\0\\001\\a\\b\\f\\n\\r\\t\\v\\\\\\'\\\"\\xfe")
	}
	
	m.dataEscapedBytes = entry
	m.parsedEscapedBytes = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetLargeUint32() uint32 {
	if m == nil {
		return 0xFFFFFFFF
	}
	return m.readLargeUint32()
}

func (m *TestExtremeDefaultValuesReader) readLargeUint32() uint32 {
	if m.parsedLargeUint32 {
		return m.dataLargeUint32
	}
	wOffset := m.offsetLargeUint32
	
	var entry uint32
	if wOffset > 0 {
		entry = m.buf.ReadUint32(wOffset)
	} else {
		entry = 0xFFFFFFFF
	}
	
	m.dataLargeUint32 = entry
	m.parsedLargeUint32 = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetLargeUint64() uint64 {
	if m == nil {
		return 0xFFFFFFFFFFFFFFFF
	}
	return m.readLargeUint64()
}

func (m *TestExtremeDefaultValuesReader) readLargeUint64() uint64 {
	if m.parsedLargeUint64 {
		return m.dataLargeUint64
	}
	wOffset := m.offsetLargeUint64
	
	var entry uint64
	if wOffset > 0 {
		entry = m.buf.ReadUint64(wOffset)
	} else {
		entry = 0xFFFFFFFFFFFFFFFF
	}
	
	m.dataLargeUint64 = entry
	m.parsedLargeUint64 = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetSmallInt32() int32 {
	if m == nil {
		return -0x7FFFFFFF
	}
	return m.readSmallInt32()
}

func (m *TestExtremeDefaultValuesReader) readSmallInt32() int32 {
	if m.parsedSmallInt32 {
		return m.dataSmallInt32
	}
	wOffset := m.offsetSmallInt32
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	} else {
		entry = -0x7FFFFFFF
	}
	
	m.dataSmallInt32 = entry
	m.parsedSmallInt32 = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetSmallInt64() int64 {
	if m == nil {
		return -0x7FFFFFFFFFFFFFFF
	}
	return m.readSmallInt64()
}

func (m *TestExtremeDefaultValuesReader) readSmallInt64() int64 {
	if m.parsedSmallInt64 {
		return m.dataSmallInt64
	}
	wOffset := m.offsetSmallInt64
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadInt64(wOffset)
	} else {
		entry = -0x7FFFFFFFFFFFFFFF
	}
	
	m.dataSmallInt64 = entry
	m.parsedSmallInt64 = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetReallySmallInt32() int32 {
	if m == nil {
		return -0x80000000
	}
	return m.readReallySmallInt32()
}

func (m *TestExtremeDefaultValuesReader) readReallySmallInt32() int32 {
	if m.parsedReallySmallInt32 {
		return m.dataReallySmallInt32
	}
	wOffset := m.offsetReallySmallInt32
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	} else {
		entry = -0x80000000
	}
	
	m.dataReallySmallInt32 = entry
	m.parsedReallySmallInt32 = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetReallySmallInt64() int64 {
	if m == nil {
		return -0x8000000000000000
	}
	return m.readReallySmallInt64()
}

func (m *TestExtremeDefaultValuesReader) readReallySmallInt64() int64 {
	if m.parsedReallySmallInt64 {
		return m.dataReallySmallInt64
	}
	wOffset := m.offsetReallySmallInt64
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadInt64(wOffset)
	} else {
		entry = -0x8000000000000000
	}
	
	m.dataReallySmallInt64 = entry
	m.parsedReallySmallInt64 = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetUtf8String() string {
	if m == nil {
		return "\\341\\210\\264"
	}
	return m.readUtf8String()
}

func (m *TestExtremeDefaultValuesReader) readUtf8String() string {
	if m.parsedUtf8String {
		return m.dataUtf8String
	}
	wOffset := m.offsetUtf8String
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	} else {
		entry = "\\341\\210\\264"
	}
	
	m.dataUtf8String = entry
	m.parsedUtf8String = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetZeroFloat() float32 {
	if m == nil {
		return 0
	}
	return m.readZeroFloat()
}

func (m *TestExtremeDefaultValuesReader) readZeroFloat() float32 {
	if m.parsedZeroFloat {
		return m.dataZeroFloat
	}
	wOffset := m.offsetZeroFloat
	
	var entry float32
	if wOffset > 0 {
		entry = m.buf.ReadFloat32(wOffset)
	} else {
		entry = 0
	}
	
	m.dataZeroFloat = entry
	m.parsedZeroFloat = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetOneFloat() float32 {
	if m == nil {
		return 1
	}
	return m.readOneFloat()
}

func (m *TestExtremeDefaultValuesReader) readOneFloat() float32 {
	if m.parsedOneFloat {
		return m.dataOneFloat
	}
	wOffset := m.offsetOneFloat
	
	var entry float32
	if wOffset > 0 {
		entry = m.buf.ReadFloat32(wOffset)
	} else {
		entry = 1
	}
	
	m.dataOneFloat = entry
	m.parsedOneFloat = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetSmallFloat() float32 {
	if m == nil {
		return 1.5
	}
	return m.readSmallFloat()
}

func (m *TestExtremeDefaultValuesReader) readSmallFloat() float32 {
	if m.parsedSmallFloat {
		return m.dataSmallFloat
	}
	wOffset := m.offsetSmallFloat
	
	var entry float32
	if wOffset > 0 {
		entry = m.buf.ReadFloat32(wOffset)
	} else {
		entry = 1.5
	}
	
	m.dataSmallFloat = entry
	m.parsedSmallFloat = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetNegativeOneFloat() float32 {
	if m == nil {
		return -1
	}
	return m.readNegativeOneFloat()
}

func (m *TestExtremeDefaultValuesReader) readNegativeOneFloat() float32 {
	if m.parsedNegativeOneFloat {
		return m.dataNegativeOneFloat
	}
	wOffset := m.offsetNegativeOneFloat
	
	var entry float32
	if wOffset > 0 {
		entry = m.buf.ReadFloat32(wOffset)
	} else {
		entry = -1
	}
	
	m.dataNegativeOneFloat = entry
	m.parsedNegativeOneFloat = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetNegativeFloat() float32 {
	if m == nil {
		return -1.5
	}
	return m.readNegativeFloat()
}

func (m *TestExtremeDefaultValuesReader) readNegativeFloat() float32 {
	if m.parsedNegativeFloat {
		return m.dataNegativeFloat
	}
	wOffset := m.offsetNegativeFloat
	
	var entry float32
	if wOffset > 0 {
		entry = m.buf.ReadFloat32(wOffset)
	} else {
		entry = -1.5
	}
	
	m.dataNegativeFloat = entry
	m.parsedNegativeFloat = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetLargeFloat() float32 {
	if m == nil {
		return 2E8
	}
	return m.readLargeFloat()
}

func (m *TestExtremeDefaultValuesReader) readLargeFloat() float32 {
	if m.parsedLargeFloat {
		return m.dataLargeFloat
	}
	wOffset := m.offsetLargeFloat
	
	var entry float32
	if wOffset > 0 {
		entry = m.buf.ReadFloat32(wOffset)
	} else {
		entry = 2E8
	}
	
	m.dataLargeFloat = entry
	m.parsedLargeFloat = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetSmallNegativeFloat() float32 {
	if m == nil {
		return -8e-28
	}
	return m.readSmallNegativeFloat()
}

func (m *TestExtremeDefaultValuesReader) readSmallNegativeFloat() float32 {
	if m.parsedSmallNegativeFloat {
		return m.dataSmallNegativeFloat
	}
	wOffset := m.offsetSmallNegativeFloat
	
	var entry float32
	if wOffset > 0 {
		entry = m.buf.ReadFloat32(wOffset)
	} else {
		entry = -8e-28
	}
	
	m.dataSmallNegativeFloat = entry
	m.parsedSmallNegativeFloat = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetInfDouble() float64 {
	if m == nil {
		return math.Inf(1)
	}
	return m.readInfDouble()
}

func (m *TestExtremeDefaultValuesReader) readInfDouble() float64 {
	if m.parsedInfDouble {
		return m.dataInfDouble
	}
	wOffset := m.offsetInfDouble
	
	var entry float64
	if wOffset > 0 {
		entry = m.buf.ReadFloat64(wOffset)
	} else {
		entry = math.Inf(1)
	}
	
	m.dataInfDouble = entry
	m.parsedInfDouble = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetNegInfDouble() float64 {
	if m == nil {
		return math.Inf(-1)
	}
	return m.readNegInfDouble()
}

func (m *TestExtremeDefaultValuesReader) readNegInfDouble() float64 {
	if m.parsedNegInfDouble {
		return m.dataNegInfDouble
	}
	wOffset := m.offsetNegInfDouble
	
	var entry float64
	if wOffset > 0 {
		entry = m.buf.ReadFloat64(wOffset)
	} else {
		entry = math.Inf(-1)
	}
	
	m.dataNegInfDouble = entry
	m.parsedNegInfDouble = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetNanDouble() float64 {
	if m == nil {
		return math.NaN()
	}
	return m.readNanDouble()
}

func (m *TestExtremeDefaultValuesReader) readNanDouble() float64 {
	if m.parsedNanDouble {
		return m.dataNanDouble
	}
	wOffset := m.offsetNanDouble
	
	var entry float64
	if wOffset > 0 {
		entry = m.buf.ReadFloat64(wOffset)
	} else {
		entry = math.NaN()
	}
	
	m.dataNanDouble = entry
	m.parsedNanDouble = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetInfFloat() float32 {
	if m == nil {
		return float32(math.Inf(1))
	}
	return m.readInfFloat()
}

func (m *TestExtremeDefaultValuesReader) readInfFloat() float32 {
	if m.parsedInfFloat {
		return m.dataInfFloat
	}
	wOffset := m.offsetInfFloat
	
	var entry float32
	if wOffset > 0 {
		entry = m.buf.ReadFloat32(wOffset)
	} else {
		entry = float32(math.Inf(1))
	}
	
	m.dataInfFloat = entry
	m.parsedInfFloat = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetNegInfFloat() float32 {
	if m == nil {
		return float32(math.Inf(-1))
	}
	return m.readNegInfFloat()
}

func (m *TestExtremeDefaultValuesReader) readNegInfFloat() float32 {
	if m.parsedNegInfFloat {
		return m.dataNegInfFloat
	}
	wOffset := m.offsetNegInfFloat
	
	var entry float32
	if wOffset > 0 {
		entry = m.buf.ReadFloat32(wOffset)
	} else {
		entry = float32(math.Inf(-1))
	}
	
	m.dataNegInfFloat = entry
	m.parsedNegInfFloat = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetNanFloat() float32 {
	if m == nil {
		return float32(math.NaN())
	}
	return m.readNanFloat()
}

func (m *TestExtremeDefaultValuesReader) readNanFloat() float32 {
	if m.parsedNanFloat {
		return m.dataNanFloat
	}
	wOffset := m.offsetNanFloat
	
	var entry float32
	if wOffset > 0 {
		entry = m.buf.ReadFloat32(wOffset)
	} else {
		entry = float32(math.NaN())
	}
	
	m.dataNanFloat = entry
	m.parsedNanFloat = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetCppTrigraph() string {
	if m == nil {
		return "? \\? ?? \\?? \\??? ??/ ?\\?-"
	}
	return m.readCppTrigraph()
}

func (m *TestExtremeDefaultValuesReader) readCppTrigraph() string {
	if m.parsedCppTrigraph {
		return m.dataCppTrigraph
	}
	wOffset := m.offsetCppTrigraph
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	} else {
		entry = "? \\? ?? \\?? \\??? ??/ ?\\?-"
	}
	
	m.dataCppTrigraph = entry
	m.parsedCppTrigraph = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetStringWithZero() string {
	if m == nil {
		return "hel\\000lo"
	}
	return m.readStringWithZero()
}

func (m *TestExtremeDefaultValuesReader) readStringWithZero() string {
	if m.parsedStringWithZero {
		return m.dataStringWithZero
	}
	wOffset := m.offsetStringWithZero
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	} else {
		entry = "hel\\000lo"
	}
	
	m.dataStringWithZero = entry
	m.parsedStringWithZero = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetBytesWithZero() []byte {
	if m == nil {
		return []byte("wor\\000ld")
	}
	return m.readBytesWithZero()
}

func (m *TestExtremeDefaultValuesReader) readBytesWithZero() []byte {
	if m.parsedBytesWithZero {
		return m.dataBytesWithZero
	}
	wOffset := m.offsetBytesWithZero
	
	var entry []byte
	if wOffset > 0 {
		entry = m.buf.ReadBytes(wOffset)
	} else {
		entry = []byte("wor\\000ld")
	}
	
	m.dataBytesWithZero = entry
	m.parsedBytesWithZero = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetStringPieceWithZero() string {
	if m == nil {
		return "ab\\000c"
	}
	return m.readStringPieceWithZero()
}

func (m *TestExtremeDefaultValuesReader) readStringPieceWithZero() string {
	if m.parsedStringPieceWithZero {
		return m.dataStringPieceWithZero
	}
	wOffset := m.offsetStringPieceWithZero
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	} else {
		entry = "ab\\000c"
	}
	
	m.dataStringPieceWithZero = entry
	m.parsedStringPieceWithZero = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetCordWithZero() string {
	if m == nil {
		return "12\\0003"
	}
	return m.readCordWithZero()
}

func (m *TestExtremeDefaultValuesReader) readCordWithZero() string {
	if m.parsedCordWithZero {
		return m.dataCordWithZero
	}
	wOffset := m.offsetCordWithZero
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	} else {
		entry = "12\\0003"
	}
	
	m.dataCordWithZero = entry
	m.parsedCordWithZero = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) GetReplacementString() string {
	if m == nil {
		return "${unknown}"
	}
	return m.readReplacementString()
}

func (m *TestExtremeDefaultValuesReader) readReplacementString() string {
	if m.parsedReplacementString {
		return m.dataReplacementString
	}
	wOffset := m.offsetReplacementString
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	} else {
		entry = "${unknown}"
	}
	
	m.dataReplacementString = entry
	m.parsedReplacementString = true
	return entry
}

func (m *TestExtremeDefaultValuesReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestExtremeDefaultValues_EscapedBytes:
			m.offsetEscapedBytes = offset
		case wireTestExtremeDefaultValues_LargeUint32:
			m.offsetLargeUint32 = offset
		case wireTestExtremeDefaultValues_LargeUint64:
			m.offsetLargeUint64 = offset
		case wireTestExtremeDefaultValues_SmallInt32:
			m.offsetSmallInt32 = offset
		case wireTestExtremeDefaultValues_SmallInt64:
			m.offsetSmallInt64 = offset
		case wireTestExtremeDefaultValues_ReallySmallInt32:
			m.offsetReallySmallInt32 = offset
		case wireTestExtremeDefaultValues_ReallySmallInt64:
			m.offsetReallySmallInt64 = offset
		case wireTestExtremeDefaultValues_Utf8String:
			m.offsetUtf8String = offset
		case wireTestExtremeDefaultValues_ZeroFloat:
			m.offsetZeroFloat = offset
		case wireTestExtremeDefaultValues_OneFloat:
			m.offsetOneFloat = offset
		case wireTestExtremeDefaultValues_SmallFloat:
			m.offsetSmallFloat = offset
		case wireTestExtremeDefaultValues_NegativeOneFloat:
			m.offsetNegativeOneFloat = offset
		case wireTestExtremeDefaultValues_NegativeFloat:
			m.offsetNegativeFloat = offset
		case wireTestExtremeDefaultValues_LargeFloat:
			m.offsetLargeFloat = offset
		case wireTestExtremeDefaultValues_SmallNegativeFloat:
			m.offsetSmallNegativeFloat = offset
		case wireTestExtremeDefaultValues_InfDouble:
			m.offsetInfDouble = offset
		case wireTestExtremeDefaultValues_NegInfDouble:
			m.offsetNegInfDouble = offset
		case wireTestExtremeDefaultValues_NanDouble:
			m.offsetNanDouble = offset
		case wireTestExtremeDefaultValues_InfFloat:
			m.offsetInfFloat = offset
		case wireTestExtremeDefaultValues_NegInfFloat:
			m.offsetNegInfFloat = offset
		case wireTestExtremeDefaultValues_NanFloat:
			m.offsetNanFloat = offset
		case wireTestExtremeDefaultValues_CppTrigraph:
			m.offsetCppTrigraph = offset
		case wireTestExtremeDefaultValues_StringWithZero:
			m.offsetStringWithZero = offset
		case wireTestExtremeDefaultValues_BytesWithZero:
			m.offsetBytesWithZero = offset
		case wireTestExtremeDefaultValues_StringPieceWithZero:
			m.offsetStringPieceWithZero = offset
		case wireTestExtremeDefaultValues_CordWithZero:
			m.offsetCordWithZero = offset
		case wireTestExtremeDefaultValues_ReplacementString:
			m.offsetReplacementString = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestExtremeDefaultValuesReader) ToStruct() *TestExtremeDefaultValues {
	if m == nil {
		return nil
	}
	res := &TestExtremeDefaultValues{}
	res.EscapedBytes = m.GetEscapedBytes()
	res.LargeUint32 = m.GetLargeUint32()
	res.LargeUint64 = m.GetLargeUint64()
	res.SmallInt32 = m.GetSmallInt32()
	res.SmallInt64 = m.GetSmallInt64()
	res.ReallySmallInt32 = m.GetReallySmallInt32()
	res.ReallySmallInt64 = m.GetReallySmallInt64()
	res.Utf8String = m.GetUtf8String()
	res.ZeroFloat = m.GetZeroFloat()
	res.OneFloat = m.GetOneFloat()
	res.SmallFloat = m.GetSmallFloat()
	res.NegativeOneFloat = m.GetNegativeOneFloat()
	res.NegativeFloat = m.GetNegativeFloat()
	res.LargeFloat = m.GetLargeFloat()
	res.SmallNegativeFloat = m.GetSmallNegativeFloat()
	res.InfDouble = m.GetInfDouble()
	res.NegInfDouble = m.GetNegInfDouble()
	res.NanDouble = m.GetNanDouble()
	res.InfFloat = m.GetInfFloat()
	res.NegInfFloat = m.GetNegInfFloat()
	res.NanFloat = m.GetNanFloat()
	res.CppTrigraph = m.GetCppTrigraph()
	res.StringWithZero = m.GetStringWithZero()
	res.BytesWithZero = m.GetBytesWithZero()
	res.StringPieceWithZero = m.GetStringPieceWithZero()
	res.CordWithZero = m.GetCordWithZero()
	res.ReplacementString = m.GetReplacementString()

	return res
}

func (s *TestExtremeDefaultValuesReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestExtremeDefaultValues struct {
	EscapedBytes	[]byte	`json:"escaped_bytes,omitempty"`
	LargeUint32	uint32	`json:"large_uint32,omitempty"`
	LargeUint64	uint64	`json:"large_uint64,omitempty"`
	SmallInt32	int32	`json:"small_int32,omitempty"`
	SmallInt64	int64	`json:"small_int64,omitempty"`
	ReallySmallInt32	int32	`json:"really_small_int32,omitempty"`
	ReallySmallInt64	int64	`json:"really_small_int64,omitempty"`
	Utf8String	string	`json:"utf8_string,omitempty"`
	ZeroFloat	float32	`json:"zero_float,omitempty"`
	OneFloat	float32	`json:"one_float,omitempty"`
	SmallFloat	float32	`json:"small_float,omitempty"`
	NegativeOneFloat	float32	`json:"negative_one_float,omitempty"`
	NegativeFloat	float32	`json:"negative_float,omitempty"`
	LargeFloat	float32	`json:"large_float,omitempty"`
	SmallNegativeFloat	float32	`json:"small_negative_float,omitempty"`
	InfDouble	float64	`json:"inf_double,omitempty"`
	NegInfDouble	float64	`json:"neg_inf_double,omitempty"`
	NanDouble	float64	`json:"nan_double,omitempty"`
	InfFloat	float32	`json:"inf_float,omitempty"`
	NegInfFloat	float32	`json:"neg_inf_float,omitempty"`
	NanFloat	float32	`json:"nan_float,omitempty"`
	CppTrigraph	string	`json:"cpp_trigraph,omitempty"`
	StringWithZero	string	`json:"string_with_zero,omitempty"`
	BytesWithZero	[]byte	`json:"bytes_with_zero,omitempty"`
	StringPieceWithZero	string	`json:"string_piece_with_zero,omitempty"`
	CordWithZero	string	`json:"cord_with_zero,omitempty"`
	ReplacementString	string	`json:"replacement_string,omitempty"`
}

func (s *TestExtremeDefaultValues) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestExtremeDefaultValues) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if !bytes.Equal(s.EscapedBytes, []byte("\\0\\001\\a\\b\\f\\n\\r\\t\\v\\\\\\'\\\"\\xfe")) {
		res.AppendBytes(wireTestExtremeDefaultValues_EscapedBytes, s.EscapedBytes)
	}
	if s.LargeUint32 != 0xFFFFFFFF {
		res.AppendUint32(wireTestExtremeDefaultValues_LargeUint32, s.LargeUint32)
	}
	if s.LargeUint64 != 0xFFFFFFFFFFFFFFFF {
		res.AppendUint64(wireTestExtremeDefaultValues_LargeUint64, s.LargeUint64)
	}
	if s.SmallInt32 != -0x7FFFFFFF {
		res.AppendInt32(wireTestExtremeDefaultValues_SmallInt32, s.SmallInt32)
	}
	if s.SmallInt64 != -0x7FFFFFFFFFFFFFFF {
		res.AppendInt64(wireTestExtremeDefaultValues_SmallInt64, s.SmallInt64)
	}
	if s.ReallySmallInt32 != -0x80000000 {
		res.AppendInt32(wireTestExtremeDefaultValues_ReallySmallInt32, s.ReallySmallInt32)
	}
	if s.ReallySmallInt64 != -0x8000000000000000 {
		res.AppendInt64(wireTestExtremeDefaultValues_ReallySmallInt64, s.ReallySmallInt64)
	}
	if s.Utf8String != "\\341\\210\\264" {
		res.AppendString(wireTestExtremeDefaultValues_Utf8String, s.Utf8String)
	}
	if s.ZeroFloat != 0 {
		res.AppendFloat32(wireTestExtremeDefaultValues_ZeroFloat, s.ZeroFloat)
	}
	if s.OneFloat != 1 {
		res.AppendFloat32(wireTestExtremeDefaultValues_OneFloat, s.OneFloat)
	}
	if s.SmallFloat != 1.5 {
		res.AppendFloat32(wireTestExtremeDefaultValues_SmallFloat, s.SmallFloat)
	}
	if s.NegativeOneFloat != -1 {
		res.AppendFloat32(wireTestExtremeDefaultValues_NegativeOneFloat, s.NegativeOneFloat)
	}
	if s.NegativeFloat != -1.5 {
		res.AppendFloat32(wireTestExtremeDefaultValues_NegativeFloat, s.NegativeFloat)
	}
	if s.LargeFloat != 2E8 {
		res.AppendFloat32(wireTestExtremeDefaultValues_LargeFloat, s.LargeFloat)
	}
	if s.SmallNegativeFloat != -8e-28 {
		res.AppendFloat32(wireTestExtremeDefaultValues_SmallNegativeFloat, s.SmallNegativeFloat)
	}
	if s.InfDouble != math.Inf(1) {
		res.AppendFloat64(wireTestExtremeDefaultValues_InfDouble, s.InfDouble)
	}
	if s.NegInfDouble != math.Inf(-1) {
		res.AppendFloat64(wireTestExtremeDefaultValues_NegInfDouble, s.NegInfDouble)
	}
	if s.NanDouble != math.NaN() {
		res.AppendFloat64(wireTestExtremeDefaultValues_NanDouble, s.NanDouble)
	}
	if s.InfFloat != float32(math.Inf(1)) {
		res.AppendFloat32(wireTestExtremeDefaultValues_InfFloat, s.InfFloat)
	}
	if s.NegInfFloat != float32(math.Inf(-1)) {
		res.AppendFloat32(wireTestExtremeDefaultValues_NegInfFloat, s.NegInfFloat)
	}
	if s.NanFloat != float32(math.NaN()) {
		res.AppendFloat32(wireTestExtremeDefaultValues_NanFloat, s.NanFloat)
	}
	if s.CppTrigraph != "? \\? ?? \\?? \\??? ??/ ?\\?-" {
		res.AppendString(wireTestExtremeDefaultValues_CppTrigraph, s.CppTrigraph)
	}
	if s.StringWithZero != "hel\\000lo" {
		res.AppendString(wireTestExtremeDefaultValues_StringWithZero, s.StringWithZero)
	}
	if !bytes.Equal(s.BytesWithZero, []byte("wor\\000ld")) {
		res.AppendBytes(wireTestExtremeDefaultValues_BytesWithZero, s.BytesWithZero)
	}
	if s.StringPieceWithZero != "ab\\000c" {
		res.AppendString(wireTestExtremeDefaultValues_StringPieceWithZero, s.StringPieceWithZero)
	}
	if s.CordWithZero != "12\\0003" {
		res.AppendString(wireTestExtremeDefaultValues_CordWithZero, s.CordWithZero)
	}
	if s.ReplacementString != "${unknown}" {
		res.AppendString(wireTestExtremeDefaultValues_ReplacementString, s.ReplacementString)
	}
}

func (s *TestExtremeDefaultValues) Copy() *TestExtremeDefaultValues {
	if s == nil {
		return nil
	}
	res := &TestExtremeDefaultValues{}
	res.EscapedBytes = s.EscapedBytes
	res.LargeUint32 = s.LargeUint32
	res.LargeUint64 = s.LargeUint64
	res.SmallInt32 = s.SmallInt32
	res.SmallInt64 = s.SmallInt64
	res.ReallySmallInt32 = s.ReallySmallInt32
	res.ReallySmallInt64 = s.ReallySmallInt64
	res.Utf8String = s.Utf8String
	res.ZeroFloat = s.ZeroFloat
	res.OneFloat = s.OneFloat
	res.SmallFloat = s.SmallFloat
	res.NegativeOneFloat = s.NegativeOneFloat
	res.NegativeFloat = s.NegativeFloat
	res.LargeFloat = s.LargeFloat
	res.SmallNegativeFloat = s.SmallNegativeFloat
	res.InfDouble = s.InfDouble
	res.NegInfDouble = s.NegInfDouble
	res.NanDouble = s.NanDouble
	res.InfFloat = s.InfFloat
	res.NegInfFloat = s.NegInfFloat
	res.NanFloat = s.NanFloat
	res.CppTrigraph = s.CppTrigraph
	res.StringWithZero = s.StringWithZero
	res.BytesWithZero = s.BytesWithZero
	res.StringPieceWithZero = s.StringPieceWithZero
	res.CordWithZero = s.CordWithZero
	res.ReplacementString = s.ReplacementString

	return res
}

func (s *TestExtremeDefaultValues) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if !bytes.Equal(s.EscapedBytes, []byte("\\0\\001\\a\\b\\f\\n\\r\\t\\v\\\\\\'\\\"\\xfe")) {
		var entrySize = 0
		entrySize = gremlin.SizeBytes(s.EscapedBytes)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestExtremeDefaultValues_EscapedBytes)
		size += entrySize
	}

	if s.LargeUint32 != 0xFFFFFFFF {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtremeDefaultValues_LargeUint32) + gremlin.SizeUint32(s.LargeUint32)
		size += entrySize
	}

	if s.LargeUint64 != 0xFFFFFFFFFFFFFFFF {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtremeDefaultValues_LargeUint64) + gremlin.SizeUint64(s.LargeUint64)
		size += entrySize
	}

	if s.SmallInt32 != -0x7FFFFFFF {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtremeDefaultValues_SmallInt32) + gremlin.SizeInt32(s.SmallInt32)
		size += entrySize
	}

	if s.SmallInt64 != -0x7FFFFFFFFFFFFFFF {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtremeDefaultValues_SmallInt64) + gremlin.SizeInt64(s.SmallInt64)
		size += entrySize
	}

	if s.ReallySmallInt32 != -0x80000000 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtremeDefaultValues_ReallySmallInt32) + gremlin.SizeInt32(s.ReallySmallInt32)
		size += entrySize
	}

	if s.ReallySmallInt64 != -0x8000000000000000 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtremeDefaultValues_ReallySmallInt64) + gremlin.SizeInt64(s.ReallySmallInt64)
		size += entrySize
	}

	if s.Utf8String != "\\341\\210\\264" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Utf8String)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestExtremeDefaultValues_Utf8String)
		size += entrySize
	}

	if s.ZeroFloat != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtremeDefaultValues_ZeroFloat) + gremlin.SizeFloat32(s.ZeroFloat)
		size += entrySize
	}

	if s.OneFloat != 1 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtremeDefaultValues_OneFloat) + gremlin.SizeFloat32(s.OneFloat)
		size += entrySize
	}

	if s.SmallFloat != 1.5 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtremeDefaultValues_SmallFloat) + gremlin.SizeFloat32(s.SmallFloat)
		size += entrySize
	}

	if s.NegativeOneFloat != -1 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtremeDefaultValues_NegativeOneFloat) + gremlin.SizeFloat32(s.NegativeOneFloat)
		size += entrySize
	}

	if s.NegativeFloat != -1.5 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtremeDefaultValues_NegativeFloat) + gremlin.SizeFloat32(s.NegativeFloat)
		size += entrySize
	}

	if s.LargeFloat != 2E8 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtremeDefaultValues_LargeFloat) + gremlin.SizeFloat32(s.LargeFloat)
		size += entrySize
	}

	if s.SmallNegativeFloat != -8e-28 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtremeDefaultValues_SmallNegativeFloat) + gremlin.SizeFloat32(s.SmallNegativeFloat)
		size += entrySize
	}

	if s.InfDouble != math.Inf(1) {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtremeDefaultValues_InfDouble) + gremlin.SizeFloat64(s.InfDouble)
		size += entrySize
	}

	if s.NegInfDouble != math.Inf(-1) {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtremeDefaultValues_NegInfDouble) + gremlin.SizeFloat64(s.NegInfDouble)
		size += entrySize
	}

	if s.NanDouble != math.NaN() {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtremeDefaultValues_NanDouble) + gremlin.SizeFloat64(s.NanDouble)
		size += entrySize
	}

	if s.InfFloat != float32(math.Inf(1)) {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtremeDefaultValues_InfFloat) + gremlin.SizeFloat32(s.InfFloat)
		size += entrySize
	}

	if s.NegInfFloat != float32(math.Inf(-1)) {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtremeDefaultValues_NegInfFloat) + gremlin.SizeFloat32(s.NegInfFloat)
		size += entrySize
	}

	if s.NanFloat != float32(math.NaN()) {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtremeDefaultValues_NanFloat) + gremlin.SizeFloat32(s.NanFloat)
		size += entrySize
	}

	if s.CppTrigraph != "? \\? ?? \\?? \\??? ??/ ?\\?-" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.CppTrigraph)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestExtremeDefaultValues_CppTrigraph)
		size += entrySize
	}

	if s.StringWithZero != "hel\\000lo" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.StringWithZero)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestExtremeDefaultValues_StringWithZero)
		size += entrySize
	}

	if !bytes.Equal(s.BytesWithZero, []byte("wor\\000ld")) {
		var entrySize = 0
		entrySize = gremlin.SizeBytes(s.BytesWithZero)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestExtremeDefaultValues_BytesWithZero)
		size += entrySize
	}

	if s.StringPieceWithZero != "ab\\000c" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.StringPieceWithZero)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestExtremeDefaultValues_StringPieceWithZero)
		size += entrySize
	}

	if s.CordWithZero != "12\\0003" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.CordWithZero)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestExtremeDefaultValues_CordWithZero)
		size += entrySize
	}

	if s.ReplacementString != "${unknown}" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.ReplacementString)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestExtremeDefaultValues_ReplacementString)
		size += entrySize
	}

	return size
}

const (
	wireSparseEnumMessage_SparseEnum gremlin.ProtoWireNumber = 1
)

type SparseEnumMessageReader struct {
	buf *gremlin.Reader

	dataSparseEnum     TestSparseEnum

	offsetSparseEnum   int

	parsedSparseEnum   bool
}

func NewSparseEnumMessageReader() *SparseEnumMessageReader {
	return &SparseEnumMessageReader{}
}

func (m *SparseEnumMessageReader) GetSparseEnum() TestSparseEnum {
	if m == nil {
		return 0
	}
	return m.readSparseEnum()
}

func (m *SparseEnumMessageReader) readSparseEnum() TestSparseEnum {
	if m.parsedSparseEnum {
		return m.dataSparseEnum
	}
	wOffset := m.offsetSparseEnum
	
	var entry TestSparseEnum
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = TestSparseEnum(rawEntry)
	} else {
		entry = 0
	}
	
	m.dataSparseEnum = entry
	m.parsedSparseEnum = true
	return entry
}

func (m *SparseEnumMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireSparseEnumMessage_SparseEnum:
			m.offsetSparseEnum = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *SparseEnumMessageReader) ToStruct() *SparseEnumMessage {
	if m == nil {
		return nil
	}
	res := &SparseEnumMessage{}
	res.SparseEnum = m.GetSparseEnum()

	return res
}

func (s *SparseEnumMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type SparseEnumMessage struct {
	SparseEnum	TestSparseEnum	`json:"sparse_enum,omitempty"`
}

func (s *SparseEnumMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *SparseEnumMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.SparseEnum != 0 {
		res.AppendInt32(wireSparseEnumMessage_SparseEnum, int32(s.SparseEnum))
	}
}

func (s *SparseEnumMessage) Copy() *SparseEnumMessage {
	if s == nil {
		return nil
	}
	res := &SparseEnumMessage{}
	res.SparseEnum = s.SparseEnum

	return res
}

func (s *SparseEnumMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.SparseEnum != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireSparseEnumMessage_SparseEnum) + gremlin.SizeInt32(int32(s.SparseEnum))
		size += entrySize
	}

	return size
}

const (
	wireOneString_Data gremlin.ProtoWireNumber = 1
)

type OneStringReader struct {
	buf *gremlin.Reader

	dataData     string

	offsetData   int

	parsedData   bool
}

func NewOneStringReader() *OneStringReader {
	return &OneStringReader{}
}

func (m *OneStringReader) GetData() string {
	if m == nil {
		return ""
	}
	return m.readData()
}

func (m *OneStringReader) readData() string {
	if m.parsedData {
		return m.dataData
	}
	wOffset := m.offsetData
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataData = entry
	m.parsedData = true
	return entry
}

func (m *OneStringReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireOneString_Data:
			m.offsetData = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *OneStringReader) ToStruct() *OneString {
	if m == nil {
		return nil
	}
	res := &OneString{}
	res.Data = m.GetData()

	return res
}

func (s *OneStringReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type OneString struct {
	Data	string	`json:"data,omitempty"`
}

func (s *OneString) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *OneString) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Data != "" {
		res.AppendString(wireOneString_Data, s.Data)
	}
}

func (s *OneString) Copy() *OneString {
	if s == nil {
		return nil
	}
	res := &OneString{}
	res.Data = s.Data

	return res
}

func (s *OneString) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Data != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Data)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireOneString_Data)
		size += entrySize
	}

	return size
}

const (
	wireMoreString_Data gremlin.ProtoWireNumber = 1
)

type MoreStringReader struct {
	buf *gremlin.Reader

	dataData     []string

	offsetData   []int

	parsedData   bool
}

func NewMoreStringReader() *MoreStringReader {
	return &MoreStringReader{}
}

func (m *MoreStringReader) GetData() []string {
	if m == nil {
		return nil
	}
	return m.readData()
}

func (m *MoreStringReader) readData() []string {
	if m.parsedData {
		return m.dataData
	}
	wOffset := m.offsetData
	
	var entry []string
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry string
		if wOffset > 0 {
			listEntry = m.buf.ReadString(wOffset)
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataData = entry
	m.parsedData = true
	return entry
}

func (m *MoreStringReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireMoreString_Data:
			m.offsetData = append(m.offsetData, offset)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *MoreStringReader) ToStruct() *MoreString {
	if m == nil {
		return nil
	}
	res := &MoreString{}
	res.Data = m.GetData()

	return res
}

func (s *MoreStringReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type MoreString struct {
	Data	[]string	`json:"data,omitempty"`
}

func (s *MoreString) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *MoreString) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if len(s.Data) > 0 {
		for _, entry := range s.Data {
			res.AppendString(wireMoreString_Data, entry)
		}
	}
}

func (s *MoreString) Copy() *MoreString {
	if s == nil {
		return nil
	}
	res := &MoreString{}
	res.Data = s.Data

	return res
}

func (s *MoreString) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if len(s.Data) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.Data {
			var listEntrySize int
			listEntrySize = gremlin.SizeString(val)
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireMoreString_Data)
			entrySize += listEntrySize
		}
		size += entrySize
	}

	return size
}

const (
	wireOneBytes_Data gremlin.ProtoWireNumber = 1
)

type OneBytesReader struct {
	buf *gremlin.Reader

	dataData     []byte

	offsetData   int

	parsedData   bool
}

func NewOneBytesReader() *OneBytesReader {
	return &OneBytesReader{}
}

func (m *OneBytesReader) GetData() []byte {
	if m == nil {
		return nil
	}
	return m.readData()
}

func (m *OneBytesReader) readData() []byte {
	if m.parsedData {
		return m.dataData
	}
	wOffset := m.offsetData
	
	var entry []byte
	if wOffset > 0 {
		entry = m.buf.ReadBytes(wOffset)
	}
	
	m.dataData = entry
	m.parsedData = true
	return entry
}

func (m *OneBytesReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireOneBytes_Data:
			m.offsetData = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *OneBytesReader) ToStruct() *OneBytes {
	if m == nil {
		return nil
	}
	res := &OneBytes{}
	res.Data = m.GetData()

	return res
}

func (s *OneBytesReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type OneBytes struct {
	Data	[]byte	`json:"data,omitempty"`
}

func (s *OneBytes) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *OneBytes) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if len(s.Data) != 0 {
		res.AppendBytes(wireOneBytes_Data, s.Data)
	}
}

func (s *OneBytes) Copy() *OneBytes {
	if s == nil {
		return nil
	}
	res := &OneBytes{}
	res.Data = s.Data

	return res
}

func (s *OneBytes) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if len(s.Data) != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeBytes(s.Data)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireOneBytes_Data)
		size += entrySize
	}

	return size
}

const (
	wireMoreBytes_Data gremlin.ProtoWireNumber = 1
)

type MoreBytesReader struct {
	buf *gremlin.Reader

	dataData     [][]byte

	offsetData   []int

	parsedData   bool
}

func NewMoreBytesReader() *MoreBytesReader {
	return &MoreBytesReader{}
}

func (m *MoreBytesReader) GetData() [][]byte {
	if m == nil {
		return nil
	}
	return m.readData()
}

func (m *MoreBytesReader) readData() [][]byte {
	if m.parsedData {
		return m.dataData
	}
	wOffset := m.offsetData
	
	var entry [][]byte
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry []byte
		if wOffset > 0 {
			listEntry = m.buf.ReadBytes(wOffset)
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataData = entry
	m.parsedData = true
	return entry
}

func (m *MoreBytesReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireMoreBytes_Data:
			m.offsetData = append(m.offsetData, offset)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *MoreBytesReader) ToStruct() *MoreBytes {
	if m == nil {
		return nil
	}
	res := &MoreBytes{}
	res.Data = m.GetData()

	return res
}

func (s *MoreBytesReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type MoreBytes struct {
	Data	[][]byte	`json:"data,omitempty"`
}

func (s *MoreBytes) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *MoreBytes) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if len(s.Data) > 0 {
		for _, entry := range s.Data {
			res.AppendBytes(wireMoreBytes_Data, entry)
		}
	}
}

func (s *MoreBytes) Copy() *MoreBytes {
	if s == nil {
		return nil
	}
	res := &MoreBytes{}
	res.Data = s.Data

	return res
}

func (s *MoreBytes) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if len(s.Data) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.Data {
			var listEntrySize int
			listEntrySize = gremlin.SizeBytes(val)
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireMoreBytes_Data)
			entrySize += listEntrySize
		}
		size += entrySize
	}

	return size
}

const (
	wireManyOptionalString_Str1 gremlin.ProtoWireNumber = 1
	wireManyOptionalString_Str2 gremlin.ProtoWireNumber = 2
	wireManyOptionalString_Str3 gremlin.ProtoWireNumber = 3
	wireManyOptionalString_Str4 gremlin.ProtoWireNumber = 4
	wireManyOptionalString_Str5 gremlin.ProtoWireNumber = 5
	wireManyOptionalString_Str6 gremlin.ProtoWireNumber = 6
	wireManyOptionalString_Str7 gremlin.ProtoWireNumber = 7
	wireManyOptionalString_Str8 gremlin.ProtoWireNumber = 8
	wireManyOptionalString_Str9 gremlin.ProtoWireNumber = 9
	wireManyOptionalString_Str10 gremlin.ProtoWireNumber = 10
	wireManyOptionalString_Str11 gremlin.ProtoWireNumber = 11
	wireManyOptionalString_Str12 gremlin.ProtoWireNumber = 12
	wireManyOptionalString_Str13 gremlin.ProtoWireNumber = 13
	wireManyOptionalString_Str14 gremlin.ProtoWireNumber = 14
	wireManyOptionalString_Str15 gremlin.ProtoWireNumber = 15
	wireManyOptionalString_Str16 gremlin.ProtoWireNumber = 16
	wireManyOptionalString_Str17 gremlin.ProtoWireNumber = 17
	wireManyOptionalString_Str18 gremlin.ProtoWireNumber = 18
	wireManyOptionalString_Str19 gremlin.ProtoWireNumber = 19
	wireManyOptionalString_Str20 gremlin.ProtoWireNumber = 20
	wireManyOptionalString_Str21 gremlin.ProtoWireNumber = 21
	wireManyOptionalString_Str22 gremlin.ProtoWireNumber = 22
	wireManyOptionalString_Str23 gremlin.ProtoWireNumber = 23
	wireManyOptionalString_Str24 gremlin.ProtoWireNumber = 24
	wireManyOptionalString_Str25 gremlin.ProtoWireNumber = 25
	wireManyOptionalString_Str26 gremlin.ProtoWireNumber = 26
	wireManyOptionalString_Str27 gremlin.ProtoWireNumber = 27
	wireManyOptionalString_Str28 gremlin.ProtoWireNumber = 28
	wireManyOptionalString_Str29 gremlin.ProtoWireNumber = 29
	wireManyOptionalString_Str30 gremlin.ProtoWireNumber = 30
	wireManyOptionalString_Str31 gremlin.ProtoWireNumber = 31
	wireManyOptionalString_Str32 gremlin.ProtoWireNumber = 32
)

type ManyOptionalStringReader struct {
	buf *gremlin.Reader

	dataStr1     string
	dataStr2     string
	dataStr3     string
	dataStr4     string
	dataStr5     string
	dataStr6     string
	dataStr7     string
	dataStr8     string
	dataStr9     string
	dataStr10     string
	dataStr11     string
	dataStr12     string
	dataStr13     string
	dataStr14     string
	dataStr15     string
	dataStr16     string
	dataStr17     string
	dataStr18     string
	dataStr19     string
	dataStr20     string
	dataStr21     string
	dataStr22     string
	dataStr23     string
	dataStr24     string
	dataStr25     string
	dataStr26     string
	dataStr27     string
	dataStr28     string
	dataStr29     string
	dataStr30     string
	dataStr31     string
	dataStr32     string

	offsetStr1   int
	offsetStr2   int
	offsetStr3   int
	offsetStr4   int
	offsetStr5   int
	offsetStr6   int
	offsetStr7   int
	offsetStr8   int
	offsetStr9   int
	offsetStr10   int
	offsetStr11   int
	offsetStr12   int
	offsetStr13   int
	offsetStr14   int
	offsetStr15   int
	offsetStr16   int
	offsetStr17   int
	offsetStr18   int
	offsetStr19   int
	offsetStr20   int
	offsetStr21   int
	offsetStr22   int
	offsetStr23   int
	offsetStr24   int
	offsetStr25   int
	offsetStr26   int
	offsetStr27   int
	offsetStr28   int
	offsetStr29   int
	offsetStr30   int
	offsetStr31   int
	offsetStr32   int

	parsedStr1   bool
	parsedStr2   bool
	parsedStr3   bool
	parsedStr4   bool
	parsedStr5   bool
	parsedStr6   bool
	parsedStr7   bool
	parsedStr8   bool
	parsedStr9   bool
	parsedStr10   bool
	parsedStr11   bool
	parsedStr12   bool
	parsedStr13   bool
	parsedStr14   bool
	parsedStr15   bool
	parsedStr16   bool
	parsedStr17   bool
	parsedStr18   bool
	parsedStr19   bool
	parsedStr20   bool
	parsedStr21   bool
	parsedStr22   bool
	parsedStr23   bool
	parsedStr24   bool
	parsedStr25   bool
	parsedStr26   bool
	parsedStr27   bool
	parsedStr28   bool
	parsedStr29   bool
	parsedStr30   bool
	parsedStr31   bool
	parsedStr32   bool
}

func NewManyOptionalStringReader() *ManyOptionalStringReader {
	return &ManyOptionalStringReader{}
}

func (m *ManyOptionalStringReader) GetStr1() string {
	if m == nil {
		return ""
	}
	return m.readStr1()
}

func (m *ManyOptionalStringReader) readStr1() string {
	if m.parsedStr1 {
		return m.dataStr1
	}
	wOffset := m.offsetStr1
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr1 = entry
	m.parsedStr1 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr2() string {
	if m == nil {
		return ""
	}
	return m.readStr2()
}

func (m *ManyOptionalStringReader) readStr2() string {
	if m.parsedStr2 {
		return m.dataStr2
	}
	wOffset := m.offsetStr2
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr2 = entry
	m.parsedStr2 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr3() string {
	if m == nil {
		return ""
	}
	return m.readStr3()
}

func (m *ManyOptionalStringReader) readStr3() string {
	if m.parsedStr3 {
		return m.dataStr3
	}
	wOffset := m.offsetStr3
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr3 = entry
	m.parsedStr3 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr4() string {
	if m == nil {
		return ""
	}
	return m.readStr4()
}

func (m *ManyOptionalStringReader) readStr4() string {
	if m.parsedStr4 {
		return m.dataStr4
	}
	wOffset := m.offsetStr4
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr4 = entry
	m.parsedStr4 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr5() string {
	if m == nil {
		return ""
	}
	return m.readStr5()
}

func (m *ManyOptionalStringReader) readStr5() string {
	if m.parsedStr5 {
		return m.dataStr5
	}
	wOffset := m.offsetStr5
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr5 = entry
	m.parsedStr5 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr6() string {
	if m == nil {
		return ""
	}
	return m.readStr6()
}

func (m *ManyOptionalStringReader) readStr6() string {
	if m.parsedStr6 {
		return m.dataStr6
	}
	wOffset := m.offsetStr6
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr6 = entry
	m.parsedStr6 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr7() string {
	if m == nil {
		return ""
	}
	return m.readStr7()
}

func (m *ManyOptionalStringReader) readStr7() string {
	if m.parsedStr7 {
		return m.dataStr7
	}
	wOffset := m.offsetStr7
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr7 = entry
	m.parsedStr7 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr8() string {
	if m == nil {
		return ""
	}
	return m.readStr8()
}

func (m *ManyOptionalStringReader) readStr8() string {
	if m.parsedStr8 {
		return m.dataStr8
	}
	wOffset := m.offsetStr8
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr8 = entry
	m.parsedStr8 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr9() string {
	if m == nil {
		return ""
	}
	return m.readStr9()
}

func (m *ManyOptionalStringReader) readStr9() string {
	if m.parsedStr9 {
		return m.dataStr9
	}
	wOffset := m.offsetStr9
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr9 = entry
	m.parsedStr9 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr10() string {
	if m == nil {
		return ""
	}
	return m.readStr10()
}

func (m *ManyOptionalStringReader) readStr10() string {
	if m.parsedStr10 {
		return m.dataStr10
	}
	wOffset := m.offsetStr10
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr10 = entry
	m.parsedStr10 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr11() string {
	if m == nil {
		return ""
	}
	return m.readStr11()
}

func (m *ManyOptionalStringReader) readStr11() string {
	if m.parsedStr11 {
		return m.dataStr11
	}
	wOffset := m.offsetStr11
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr11 = entry
	m.parsedStr11 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr12() string {
	if m == nil {
		return ""
	}
	return m.readStr12()
}

func (m *ManyOptionalStringReader) readStr12() string {
	if m.parsedStr12 {
		return m.dataStr12
	}
	wOffset := m.offsetStr12
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr12 = entry
	m.parsedStr12 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr13() string {
	if m == nil {
		return ""
	}
	return m.readStr13()
}

func (m *ManyOptionalStringReader) readStr13() string {
	if m.parsedStr13 {
		return m.dataStr13
	}
	wOffset := m.offsetStr13
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr13 = entry
	m.parsedStr13 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr14() string {
	if m == nil {
		return ""
	}
	return m.readStr14()
}

func (m *ManyOptionalStringReader) readStr14() string {
	if m.parsedStr14 {
		return m.dataStr14
	}
	wOffset := m.offsetStr14
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr14 = entry
	m.parsedStr14 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr15() string {
	if m == nil {
		return ""
	}
	return m.readStr15()
}

func (m *ManyOptionalStringReader) readStr15() string {
	if m.parsedStr15 {
		return m.dataStr15
	}
	wOffset := m.offsetStr15
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr15 = entry
	m.parsedStr15 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr16() string {
	if m == nil {
		return ""
	}
	return m.readStr16()
}

func (m *ManyOptionalStringReader) readStr16() string {
	if m.parsedStr16 {
		return m.dataStr16
	}
	wOffset := m.offsetStr16
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr16 = entry
	m.parsedStr16 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr17() string {
	if m == nil {
		return ""
	}
	return m.readStr17()
}

func (m *ManyOptionalStringReader) readStr17() string {
	if m.parsedStr17 {
		return m.dataStr17
	}
	wOffset := m.offsetStr17
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr17 = entry
	m.parsedStr17 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr18() string {
	if m == nil {
		return ""
	}
	return m.readStr18()
}

func (m *ManyOptionalStringReader) readStr18() string {
	if m.parsedStr18 {
		return m.dataStr18
	}
	wOffset := m.offsetStr18
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr18 = entry
	m.parsedStr18 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr19() string {
	if m == nil {
		return ""
	}
	return m.readStr19()
}

func (m *ManyOptionalStringReader) readStr19() string {
	if m.parsedStr19 {
		return m.dataStr19
	}
	wOffset := m.offsetStr19
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr19 = entry
	m.parsedStr19 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr20() string {
	if m == nil {
		return ""
	}
	return m.readStr20()
}

func (m *ManyOptionalStringReader) readStr20() string {
	if m.parsedStr20 {
		return m.dataStr20
	}
	wOffset := m.offsetStr20
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr20 = entry
	m.parsedStr20 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr21() string {
	if m == nil {
		return ""
	}
	return m.readStr21()
}

func (m *ManyOptionalStringReader) readStr21() string {
	if m.parsedStr21 {
		return m.dataStr21
	}
	wOffset := m.offsetStr21
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr21 = entry
	m.parsedStr21 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr22() string {
	if m == nil {
		return ""
	}
	return m.readStr22()
}

func (m *ManyOptionalStringReader) readStr22() string {
	if m.parsedStr22 {
		return m.dataStr22
	}
	wOffset := m.offsetStr22
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr22 = entry
	m.parsedStr22 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr23() string {
	if m == nil {
		return ""
	}
	return m.readStr23()
}

func (m *ManyOptionalStringReader) readStr23() string {
	if m.parsedStr23 {
		return m.dataStr23
	}
	wOffset := m.offsetStr23
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr23 = entry
	m.parsedStr23 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr24() string {
	if m == nil {
		return ""
	}
	return m.readStr24()
}

func (m *ManyOptionalStringReader) readStr24() string {
	if m.parsedStr24 {
		return m.dataStr24
	}
	wOffset := m.offsetStr24
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr24 = entry
	m.parsedStr24 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr25() string {
	if m == nil {
		return ""
	}
	return m.readStr25()
}

func (m *ManyOptionalStringReader) readStr25() string {
	if m.parsedStr25 {
		return m.dataStr25
	}
	wOffset := m.offsetStr25
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr25 = entry
	m.parsedStr25 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr26() string {
	if m == nil {
		return ""
	}
	return m.readStr26()
}

func (m *ManyOptionalStringReader) readStr26() string {
	if m.parsedStr26 {
		return m.dataStr26
	}
	wOffset := m.offsetStr26
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr26 = entry
	m.parsedStr26 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr27() string {
	if m == nil {
		return ""
	}
	return m.readStr27()
}

func (m *ManyOptionalStringReader) readStr27() string {
	if m.parsedStr27 {
		return m.dataStr27
	}
	wOffset := m.offsetStr27
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr27 = entry
	m.parsedStr27 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr28() string {
	if m == nil {
		return ""
	}
	return m.readStr28()
}

func (m *ManyOptionalStringReader) readStr28() string {
	if m.parsedStr28 {
		return m.dataStr28
	}
	wOffset := m.offsetStr28
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr28 = entry
	m.parsedStr28 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr29() string {
	if m == nil {
		return ""
	}
	return m.readStr29()
}

func (m *ManyOptionalStringReader) readStr29() string {
	if m.parsedStr29 {
		return m.dataStr29
	}
	wOffset := m.offsetStr29
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr29 = entry
	m.parsedStr29 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr30() string {
	if m == nil {
		return ""
	}
	return m.readStr30()
}

func (m *ManyOptionalStringReader) readStr30() string {
	if m.parsedStr30 {
		return m.dataStr30
	}
	wOffset := m.offsetStr30
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr30 = entry
	m.parsedStr30 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr31() string {
	if m == nil {
		return ""
	}
	return m.readStr31()
}

func (m *ManyOptionalStringReader) readStr31() string {
	if m.parsedStr31 {
		return m.dataStr31
	}
	wOffset := m.offsetStr31
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr31 = entry
	m.parsedStr31 = true
	return entry
}

func (m *ManyOptionalStringReader) GetStr32() string {
	if m == nil {
		return ""
	}
	return m.readStr32()
}

func (m *ManyOptionalStringReader) readStr32() string {
	if m.parsedStr32 {
		return m.dataStr32
	}
	wOffset := m.offsetStr32
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataStr32 = entry
	m.parsedStr32 = true
	return entry
}

func (m *ManyOptionalStringReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireManyOptionalString_Str1:
			m.offsetStr1 = offset
		case wireManyOptionalString_Str2:
			m.offsetStr2 = offset
		case wireManyOptionalString_Str3:
			m.offsetStr3 = offset
		case wireManyOptionalString_Str4:
			m.offsetStr4 = offset
		case wireManyOptionalString_Str5:
			m.offsetStr5 = offset
		case wireManyOptionalString_Str6:
			m.offsetStr6 = offset
		case wireManyOptionalString_Str7:
			m.offsetStr7 = offset
		case wireManyOptionalString_Str8:
			m.offsetStr8 = offset
		case wireManyOptionalString_Str9:
			m.offsetStr9 = offset
		case wireManyOptionalString_Str10:
			m.offsetStr10 = offset
		case wireManyOptionalString_Str11:
			m.offsetStr11 = offset
		case wireManyOptionalString_Str12:
			m.offsetStr12 = offset
		case wireManyOptionalString_Str13:
			m.offsetStr13 = offset
		case wireManyOptionalString_Str14:
			m.offsetStr14 = offset
		case wireManyOptionalString_Str15:
			m.offsetStr15 = offset
		case wireManyOptionalString_Str16:
			m.offsetStr16 = offset
		case wireManyOptionalString_Str17:
			m.offsetStr17 = offset
		case wireManyOptionalString_Str18:
			m.offsetStr18 = offset
		case wireManyOptionalString_Str19:
			m.offsetStr19 = offset
		case wireManyOptionalString_Str20:
			m.offsetStr20 = offset
		case wireManyOptionalString_Str21:
			m.offsetStr21 = offset
		case wireManyOptionalString_Str22:
			m.offsetStr22 = offset
		case wireManyOptionalString_Str23:
			m.offsetStr23 = offset
		case wireManyOptionalString_Str24:
			m.offsetStr24 = offset
		case wireManyOptionalString_Str25:
			m.offsetStr25 = offset
		case wireManyOptionalString_Str26:
			m.offsetStr26 = offset
		case wireManyOptionalString_Str27:
			m.offsetStr27 = offset
		case wireManyOptionalString_Str28:
			m.offsetStr28 = offset
		case wireManyOptionalString_Str29:
			m.offsetStr29 = offset
		case wireManyOptionalString_Str30:
			m.offsetStr30 = offset
		case wireManyOptionalString_Str31:
			m.offsetStr31 = offset
		case wireManyOptionalString_Str32:
			m.offsetStr32 = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *ManyOptionalStringReader) ToStruct() *ManyOptionalString {
	if m == nil {
		return nil
	}
	res := &ManyOptionalString{}
	res.Str1 = m.GetStr1()
	res.Str2 = m.GetStr2()
	res.Str3 = m.GetStr3()
	res.Str4 = m.GetStr4()
	res.Str5 = m.GetStr5()
	res.Str6 = m.GetStr6()
	res.Str7 = m.GetStr7()
	res.Str8 = m.GetStr8()
	res.Str9 = m.GetStr9()
	res.Str10 = m.GetStr10()
	res.Str11 = m.GetStr11()
	res.Str12 = m.GetStr12()
	res.Str13 = m.GetStr13()
	res.Str14 = m.GetStr14()
	res.Str15 = m.GetStr15()
	res.Str16 = m.GetStr16()
	res.Str17 = m.GetStr17()
	res.Str18 = m.GetStr18()
	res.Str19 = m.GetStr19()
	res.Str20 = m.GetStr20()
	res.Str21 = m.GetStr21()
	res.Str22 = m.GetStr22()
	res.Str23 = m.GetStr23()
	res.Str24 = m.GetStr24()
	res.Str25 = m.GetStr25()
	res.Str26 = m.GetStr26()
	res.Str27 = m.GetStr27()
	res.Str28 = m.GetStr28()
	res.Str29 = m.GetStr29()
	res.Str30 = m.GetStr30()
	res.Str31 = m.GetStr31()
	res.Str32 = m.GetStr32()

	return res
}

func (s *ManyOptionalStringReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type ManyOptionalString struct {
	Str1	string	`json:"str1,omitempty"`
	Str2	string	`json:"str2,omitempty"`
	Str3	string	`json:"str3,omitempty"`
	Str4	string	`json:"str4,omitempty"`
	Str5	string	`json:"str5,omitempty"`
	Str6	string	`json:"str6,omitempty"`
	Str7	string	`json:"str7,omitempty"`
	Str8	string	`json:"str8,omitempty"`
	Str9	string	`json:"str9,omitempty"`
	Str10	string	`json:"str10,omitempty"`
	Str11	string	`json:"str11,omitempty"`
	Str12	string	`json:"str12,omitempty"`
	Str13	string	`json:"str13,omitempty"`
	Str14	string	`json:"str14,omitempty"`
	Str15	string	`json:"str15,omitempty"`
	Str16	string	`json:"str16,omitempty"`
	Str17	string	`json:"str17,omitempty"`
	Str18	string	`json:"str18,omitempty"`
	Str19	string	`json:"str19,omitempty"`
	Str20	string	`json:"str20,omitempty"`
	Str21	string	`json:"str21,omitempty"`
	Str22	string	`json:"str22,omitempty"`
	Str23	string	`json:"str23,omitempty"`
	Str24	string	`json:"str24,omitempty"`
	Str25	string	`json:"str25,omitempty"`
	Str26	string	`json:"str26,omitempty"`
	Str27	string	`json:"str27,omitempty"`
	Str28	string	`json:"str28,omitempty"`
	Str29	string	`json:"str29,omitempty"`
	Str30	string	`json:"str30,omitempty"`
	Str31	string	`json:"str31,omitempty"`
	Str32	string	`json:"str32,omitempty"`
}

func (s *ManyOptionalString) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *ManyOptionalString) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Str1 != "" {
		res.AppendString(wireManyOptionalString_Str1, s.Str1)
	}
	if s.Str2 != "" {
		res.AppendString(wireManyOptionalString_Str2, s.Str2)
	}
	if s.Str3 != "" {
		res.AppendString(wireManyOptionalString_Str3, s.Str3)
	}
	if s.Str4 != "" {
		res.AppendString(wireManyOptionalString_Str4, s.Str4)
	}
	if s.Str5 != "" {
		res.AppendString(wireManyOptionalString_Str5, s.Str5)
	}
	if s.Str6 != "" {
		res.AppendString(wireManyOptionalString_Str6, s.Str6)
	}
	if s.Str7 != "" {
		res.AppendString(wireManyOptionalString_Str7, s.Str7)
	}
	if s.Str8 != "" {
		res.AppendString(wireManyOptionalString_Str8, s.Str8)
	}
	if s.Str9 != "" {
		res.AppendString(wireManyOptionalString_Str9, s.Str9)
	}
	if s.Str10 != "" {
		res.AppendString(wireManyOptionalString_Str10, s.Str10)
	}
	if s.Str11 != "" {
		res.AppendString(wireManyOptionalString_Str11, s.Str11)
	}
	if s.Str12 != "" {
		res.AppendString(wireManyOptionalString_Str12, s.Str12)
	}
	if s.Str13 != "" {
		res.AppendString(wireManyOptionalString_Str13, s.Str13)
	}
	if s.Str14 != "" {
		res.AppendString(wireManyOptionalString_Str14, s.Str14)
	}
	if s.Str15 != "" {
		res.AppendString(wireManyOptionalString_Str15, s.Str15)
	}
	if s.Str16 != "" {
		res.AppendString(wireManyOptionalString_Str16, s.Str16)
	}
	if s.Str17 != "" {
		res.AppendString(wireManyOptionalString_Str17, s.Str17)
	}
	if s.Str18 != "" {
		res.AppendString(wireManyOptionalString_Str18, s.Str18)
	}
	if s.Str19 != "" {
		res.AppendString(wireManyOptionalString_Str19, s.Str19)
	}
	if s.Str20 != "" {
		res.AppendString(wireManyOptionalString_Str20, s.Str20)
	}
	if s.Str21 != "" {
		res.AppendString(wireManyOptionalString_Str21, s.Str21)
	}
	if s.Str22 != "" {
		res.AppendString(wireManyOptionalString_Str22, s.Str22)
	}
	if s.Str23 != "" {
		res.AppendString(wireManyOptionalString_Str23, s.Str23)
	}
	if s.Str24 != "" {
		res.AppendString(wireManyOptionalString_Str24, s.Str24)
	}
	if s.Str25 != "" {
		res.AppendString(wireManyOptionalString_Str25, s.Str25)
	}
	if s.Str26 != "" {
		res.AppendString(wireManyOptionalString_Str26, s.Str26)
	}
	if s.Str27 != "" {
		res.AppendString(wireManyOptionalString_Str27, s.Str27)
	}
	if s.Str28 != "" {
		res.AppendString(wireManyOptionalString_Str28, s.Str28)
	}
	if s.Str29 != "" {
		res.AppendString(wireManyOptionalString_Str29, s.Str29)
	}
	if s.Str30 != "" {
		res.AppendString(wireManyOptionalString_Str30, s.Str30)
	}
	if s.Str31 != "" {
		res.AppendString(wireManyOptionalString_Str31, s.Str31)
	}
	if s.Str32 != "" {
		res.AppendString(wireManyOptionalString_Str32, s.Str32)
	}
}

func (s *ManyOptionalString) Copy() *ManyOptionalString {
	if s == nil {
		return nil
	}
	res := &ManyOptionalString{}
	res.Str1 = s.Str1
	res.Str2 = s.Str2
	res.Str3 = s.Str3
	res.Str4 = s.Str4
	res.Str5 = s.Str5
	res.Str6 = s.Str6
	res.Str7 = s.Str7
	res.Str8 = s.Str8
	res.Str9 = s.Str9
	res.Str10 = s.Str10
	res.Str11 = s.Str11
	res.Str12 = s.Str12
	res.Str13 = s.Str13
	res.Str14 = s.Str14
	res.Str15 = s.Str15
	res.Str16 = s.Str16
	res.Str17 = s.Str17
	res.Str18 = s.Str18
	res.Str19 = s.Str19
	res.Str20 = s.Str20
	res.Str21 = s.Str21
	res.Str22 = s.Str22
	res.Str23 = s.Str23
	res.Str24 = s.Str24
	res.Str25 = s.Str25
	res.Str26 = s.Str26
	res.Str27 = s.Str27
	res.Str28 = s.Str28
	res.Str29 = s.Str29
	res.Str30 = s.Str30
	res.Str31 = s.Str31
	res.Str32 = s.Str32

	return res
}

func (s *ManyOptionalString) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Str1 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str1)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str1)
		size += entrySize
	}

	if s.Str2 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str2)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str2)
		size += entrySize
	}

	if s.Str3 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str3)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str3)
		size += entrySize
	}

	if s.Str4 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str4)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str4)
		size += entrySize
	}

	if s.Str5 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str5)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str5)
		size += entrySize
	}

	if s.Str6 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str6)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str6)
		size += entrySize
	}

	if s.Str7 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str7)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str7)
		size += entrySize
	}

	if s.Str8 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str8)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str8)
		size += entrySize
	}

	if s.Str9 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str9)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str9)
		size += entrySize
	}

	if s.Str10 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str10)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str10)
		size += entrySize
	}

	if s.Str11 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str11)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str11)
		size += entrySize
	}

	if s.Str12 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str12)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str12)
		size += entrySize
	}

	if s.Str13 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str13)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str13)
		size += entrySize
	}

	if s.Str14 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str14)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str14)
		size += entrySize
	}

	if s.Str15 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str15)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str15)
		size += entrySize
	}

	if s.Str16 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str16)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str16)
		size += entrySize
	}

	if s.Str17 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str17)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str17)
		size += entrySize
	}

	if s.Str18 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str18)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str18)
		size += entrySize
	}

	if s.Str19 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str19)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str19)
		size += entrySize
	}

	if s.Str20 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str20)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str20)
		size += entrySize
	}

	if s.Str21 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str21)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str21)
		size += entrySize
	}

	if s.Str22 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str22)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str22)
		size += entrySize
	}

	if s.Str23 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str23)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str23)
		size += entrySize
	}

	if s.Str24 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str24)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str24)
		size += entrySize
	}

	if s.Str25 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str25)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str25)
		size += entrySize
	}

	if s.Str26 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str26)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str26)
		size += entrySize
	}

	if s.Str27 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str27)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str27)
		size += entrySize
	}

	if s.Str28 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str28)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str28)
		size += entrySize
	}

	if s.Str29 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str29)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str29)
		size += entrySize
	}

	if s.Str30 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str30)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str30)
		size += entrySize
	}

	if s.Str31 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str31)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str31)
		size += entrySize
	}

	if s.Str32 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Str32)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireManyOptionalString_Str32)
		size += entrySize
	}

	return size
}

const (
	wireInt32Message_Data gremlin.ProtoWireNumber = 1
)

type Int32MessageReader struct {
	buf *gremlin.Reader

	dataData     int32

	offsetData   int

	parsedData   bool
}

func NewInt32MessageReader() *Int32MessageReader {
	return &Int32MessageReader{}
}

func (m *Int32MessageReader) GetData() int32 {
	if m == nil {
		return 0
	}
	return m.readData()
}

func (m *Int32MessageReader) readData() int32 {
	if m.parsedData {
		return m.dataData
	}
	wOffset := m.offsetData
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataData = entry
	m.parsedData = true
	return entry
}

func (m *Int32MessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireInt32Message_Data:
			m.offsetData = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *Int32MessageReader) ToStruct() *Int32Message {
	if m == nil {
		return nil
	}
	res := &Int32Message{}
	res.Data = m.GetData()

	return res
}

func (s *Int32MessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type Int32Message struct {
	Data	int32	`json:"data,omitempty"`
}

func (s *Int32Message) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *Int32Message) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Data != 0 {
		res.AppendInt32(wireInt32Message_Data, s.Data)
	}
}

func (s *Int32Message) Copy() *Int32Message {
	if s == nil {
		return nil
	}
	res := &Int32Message{}
	res.Data = s.Data

	return res
}

func (s *Int32Message) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Data != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireInt32Message_Data) + gremlin.SizeInt32(s.Data)
		size += entrySize
	}

	return size
}

const (
	wireUint32Message_Data gremlin.ProtoWireNumber = 1
)

type Uint32MessageReader struct {
	buf *gremlin.Reader

	dataData     uint32

	offsetData   int

	parsedData   bool
}

func NewUint32MessageReader() *Uint32MessageReader {
	return &Uint32MessageReader{}
}

func (m *Uint32MessageReader) GetData() uint32 {
	if m == nil {
		return 0
	}
	return m.readData()
}

func (m *Uint32MessageReader) readData() uint32 {
	if m.parsedData {
		return m.dataData
	}
	wOffset := m.offsetData
	
	var entry uint32
	if wOffset > 0 {
		entry = m.buf.ReadUint32(wOffset)
	}
	
	m.dataData = entry
	m.parsedData = true
	return entry
}

func (m *Uint32MessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireUint32Message_Data:
			m.offsetData = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *Uint32MessageReader) ToStruct() *Uint32Message {
	if m == nil {
		return nil
	}
	res := &Uint32Message{}
	res.Data = m.GetData()

	return res
}

func (s *Uint32MessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type Uint32Message struct {
	Data	uint32	`json:"data,omitempty"`
}

func (s *Uint32Message) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *Uint32Message) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Data != 0 {
		res.AppendUint32(wireUint32Message_Data, s.Data)
	}
}

func (s *Uint32Message) Copy() *Uint32Message {
	if s == nil {
		return nil
	}
	res := &Uint32Message{}
	res.Data = s.Data

	return res
}

func (s *Uint32Message) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Data != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireUint32Message_Data) + gremlin.SizeUint32(s.Data)
		size += entrySize
	}

	return size
}

const (
	wireInt64Message_Data gremlin.ProtoWireNumber = 1
)

type Int64MessageReader struct {
	buf *gremlin.Reader

	dataData     int64

	offsetData   int

	parsedData   bool
}

func NewInt64MessageReader() *Int64MessageReader {
	return &Int64MessageReader{}
}

func (m *Int64MessageReader) GetData() int64 {
	if m == nil {
		return 0
	}
	return m.readData()
}

func (m *Int64MessageReader) readData() int64 {
	if m.parsedData {
		return m.dataData
	}
	wOffset := m.offsetData
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadInt64(wOffset)
	}
	
	m.dataData = entry
	m.parsedData = true
	return entry
}

func (m *Int64MessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireInt64Message_Data:
			m.offsetData = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *Int64MessageReader) ToStruct() *Int64Message {
	if m == nil {
		return nil
	}
	res := &Int64Message{}
	res.Data = m.GetData()

	return res
}

func (s *Int64MessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type Int64Message struct {
	Data	int64	`json:"data,omitempty"`
}

func (s *Int64Message) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *Int64Message) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Data != 0 {
		res.AppendInt64(wireInt64Message_Data, s.Data)
	}
}

func (s *Int64Message) Copy() *Int64Message {
	if s == nil {
		return nil
	}
	res := &Int64Message{}
	res.Data = s.Data

	return res
}

func (s *Int64Message) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Data != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireInt64Message_Data) + gremlin.SizeInt64(s.Data)
		size += entrySize
	}

	return size
}

const (
	wireUint64Message_Data gremlin.ProtoWireNumber = 1
)

type Uint64MessageReader struct {
	buf *gremlin.Reader

	dataData     uint64

	offsetData   int

	parsedData   bool
}

func NewUint64MessageReader() *Uint64MessageReader {
	return &Uint64MessageReader{}
}

func (m *Uint64MessageReader) GetData() uint64 {
	if m == nil {
		return 0
	}
	return m.readData()
}

func (m *Uint64MessageReader) readData() uint64 {
	if m.parsedData {
		return m.dataData
	}
	wOffset := m.offsetData
	
	var entry uint64
	if wOffset > 0 {
		entry = m.buf.ReadUint64(wOffset)
	}
	
	m.dataData = entry
	m.parsedData = true
	return entry
}

func (m *Uint64MessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireUint64Message_Data:
			m.offsetData = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *Uint64MessageReader) ToStruct() *Uint64Message {
	if m == nil {
		return nil
	}
	res := &Uint64Message{}
	res.Data = m.GetData()

	return res
}

func (s *Uint64MessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type Uint64Message struct {
	Data	uint64	`json:"data,omitempty"`
}

func (s *Uint64Message) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *Uint64Message) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Data != 0 {
		res.AppendUint64(wireUint64Message_Data, s.Data)
	}
}

func (s *Uint64Message) Copy() *Uint64Message {
	if s == nil {
		return nil
	}
	res := &Uint64Message{}
	res.Data = s.Data

	return res
}

func (s *Uint64Message) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Data != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireUint64Message_Data) + gremlin.SizeUint64(s.Data)
		size += entrySize
	}

	return size
}

const (
	wireBoolMessage_Data gremlin.ProtoWireNumber = 1
)

type BoolMessageReader struct {
	buf *gremlin.Reader

	dataData     bool

	offsetData   int

	parsedData   bool
}

func NewBoolMessageReader() *BoolMessageReader {
	return &BoolMessageReader{}
}

func (m *BoolMessageReader) GetData() bool {
	if m == nil {
		return false
	}
	return m.readData()
}

func (m *BoolMessageReader) readData() bool {
	if m.parsedData {
		return m.dataData
	}
	wOffset := m.offsetData
	
	var entry bool
	if wOffset > 0 {
		entry = m.buf.ReadBool(wOffset)
	}
	
	m.dataData = entry
	m.parsedData = true
	return entry
}

func (m *BoolMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireBoolMessage_Data:
			m.offsetData = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *BoolMessageReader) ToStruct() *BoolMessage {
	if m == nil {
		return nil
	}
	res := &BoolMessage{}
	res.Data = m.GetData()

	return res
}

func (s *BoolMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type BoolMessage struct {
	Data	bool	`json:"data,omitempty"`
}

func (s *BoolMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *BoolMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Data {
		res.AppendBool(wireBoolMessage_Data, s.Data)
	}
}

func (s *BoolMessage) Copy() *BoolMessage {
	if s == nil {
		return nil
	}
	res := &BoolMessage{}
	res.Data = s.Data

	return res
}

func (s *BoolMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Data {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireBoolMessage_Data) + gremlin.SizeBool(s.Data)
		size += entrySize
	}

	return size
}

const (
	wireTestOneof_FooInt gremlin.ProtoWireNumber = 1
	wireTestOneof_FooString gremlin.ProtoWireNumber = 2
	wireTestOneof_FooMessage gremlin.ProtoWireNumber = 3
)

type TestOneofReader struct {
	buf *gremlin.Reader

	dataFooInt     int32
	dataFooString     string
	dataFooMessage     *TestAllTypesReader

	offsetFooInt   int
	offsetFooString   int
	offsetFooMessage   int

	parsedFooInt   bool
	parsedFooString   bool
	parsedFooMessage   bool
}

func NewTestOneofReader() *TestOneofReader {
	return &TestOneofReader{}
}

func (m *TestOneofReader) GetFooInt() int32 {
	if m == nil {
		return 0
	}
	return m.readFooInt()
}

func (m *TestOneofReader) readFooInt() int32 {
	if m.parsedFooInt {
		return m.dataFooInt
	}
	wOffset := m.offsetFooInt
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataFooInt = entry
	m.parsedFooInt = true
	return entry
}

func (m *TestOneofReader) GetFooString() string {
	if m == nil {
		return ""
	}
	return m.readFooString()
}

func (m *TestOneofReader) readFooString() string {
	if m.parsedFooString {
		return m.dataFooString
	}
	wOffset := m.offsetFooString
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataFooString = entry
	m.parsedFooString = true
	return entry
}

func (m *TestOneofReader) GetFooMessage() *TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readFooMessage()
}

func (m *TestOneofReader) readFooMessage() *TestAllTypesReader {
	if m.parsedFooMessage {
		return m.dataFooMessage
	}
	wOffset := m.offsetFooMessage
	
	var entry *TestAllTypesReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypesReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataFooMessage = entry
	m.parsedFooMessage = true
	return entry
}

func (m *TestOneofReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestOneof_FooInt:
			m.offsetFooInt = offset
		case wireTestOneof_FooString:
			m.offsetFooString = offset
		case wireTestOneof_FooMessage:
			m.offsetFooMessage = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestOneofReader) ToStruct() *TestOneof {
	if m == nil {
		return nil
	}
	res := &TestOneof{}
	res.FooInt = m.GetFooInt()
	res.FooString = m.GetFooString()

	{
		var data = m.GetFooMessage()
		var structData *TestAllTypes
		if data != nil {
			structData = data.ToStruct()
		}
		res.FooMessage = structData
	}

	return res
}

func (s *TestOneofReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestOneof struct {
	FooInt	int32	`json:"foo_int,omitempty"`
	FooString	string	`json:"foo_string,omitempty"`
	FooMessage	*TestAllTypes	`json:"foo_message,omitempty"`
}

func (s *TestOneof) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestOneof) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.FooInt != 0 {
		res.AppendInt32(wireTestOneof_FooInt, s.FooInt)
	}
	if s.FooString != "" {
		res.AppendString(wireTestOneof_FooString, s.FooString)
	}
	if s.FooMessage != nil {
		structSize := s.FooMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestOneof_FooMessage, structSize)
		s.FooMessage.MarshalTo(res)
	}
}

func (s *TestOneof) Copy() *TestOneof {
	if s == nil {
		return nil
	}
	res := &TestOneof{}
	res.FooInt = s.FooInt
	res.FooString = s.FooString
	if s.FooMessage != nil {
		res.FooMessage = s.FooMessage.Copy()
	}

	return res
}

func (s *TestOneof) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.FooInt != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestOneof_FooInt) + gremlin.SizeInt32(s.FooInt)
		size += entrySize
	}

	if s.FooString != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.FooString)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestOneof_FooString)
		size += entrySize
	}

	if s.FooMessage != nil {
		var entrySize = 0
		entrySize = s.FooMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestOneof_FooMessage)
		
		size += entrySize
	}

	return size
}

const (
	wireTestOneofBackwardsCompatible_FooInt gremlin.ProtoWireNumber = 1
	wireTestOneofBackwardsCompatible_FooString gremlin.ProtoWireNumber = 2
	wireTestOneofBackwardsCompatible_FooMessage gremlin.ProtoWireNumber = 3
)

type TestOneofBackwardsCompatibleReader struct {
	buf *gremlin.Reader

	dataFooInt     int32
	dataFooString     string
	dataFooMessage     *TestAllTypesReader

	offsetFooInt   int
	offsetFooString   int
	offsetFooMessage   int

	parsedFooInt   bool
	parsedFooString   bool
	parsedFooMessage   bool
}

func NewTestOneofBackwardsCompatibleReader() *TestOneofBackwardsCompatibleReader {
	return &TestOneofBackwardsCompatibleReader{}
}

func (m *TestOneofBackwardsCompatibleReader) GetFooInt() int32 {
	if m == nil {
		return 0
	}
	return m.readFooInt()
}

func (m *TestOneofBackwardsCompatibleReader) readFooInt() int32 {
	if m.parsedFooInt {
		return m.dataFooInt
	}
	wOffset := m.offsetFooInt
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataFooInt = entry
	m.parsedFooInt = true
	return entry
}

func (m *TestOneofBackwardsCompatibleReader) GetFooString() string {
	if m == nil {
		return ""
	}
	return m.readFooString()
}

func (m *TestOneofBackwardsCompatibleReader) readFooString() string {
	if m.parsedFooString {
		return m.dataFooString
	}
	wOffset := m.offsetFooString
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataFooString = entry
	m.parsedFooString = true
	return entry
}

func (m *TestOneofBackwardsCompatibleReader) GetFooMessage() *TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readFooMessage()
}

func (m *TestOneofBackwardsCompatibleReader) readFooMessage() *TestAllTypesReader {
	if m.parsedFooMessage {
		return m.dataFooMessage
	}
	wOffset := m.offsetFooMessage
	
	var entry *TestAllTypesReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypesReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataFooMessage = entry
	m.parsedFooMessage = true
	return entry
}

func (m *TestOneofBackwardsCompatibleReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestOneofBackwardsCompatible_FooInt:
			m.offsetFooInt = offset
		case wireTestOneofBackwardsCompatible_FooString:
			m.offsetFooString = offset
		case wireTestOneofBackwardsCompatible_FooMessage:
			m.offsetFooMessage = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestOneofBackwardsCompatibleReader) ToStruct() *TestOneofBackwardsCompatible {
	if m == nil {
		return nil
	}
	res := &TestOneofBackwardsCompatible{}
	res.FooInt = m.GetFooInt()
	res.FooString = m.GetFooString()

	{
		var data = m.GetFooMessage()
		var structData *TestAllTypes
		if data != nil {
			structData = data.ToStruct()
		}
		res.FooMessage = structData
	}

	return res
}

func (s *TestOneofBackwardsCompatibleReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestOneofBackwardsCompatible struct {
	FooInt	int32	`json:"foo_int,omitempty"`
	FooString	string	`json:"foo_string,omitempty"`
	FooMessage	*TestAllTypes	`json:"foo_message,omitempty"`
}

func (s *TestOneofBackwardsCompatible) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestOneofBackwardsCompatible) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.FooInt != 0 {
		res.AppendInt32(wireTestOneofBackwardsCompatible_FooInt, s.FooInt)
	}
	if s.FooString != "" {
		res.AppendString(wireTestOneofBackwardsCompatible_FooString, s.FooString)
	}
	if s.FooMessage != nil {
		structSize := s.FooMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestOneofBackwardsCompatible_FooMessage, structSize)
		s.FooMessage.MarshalTo(res)
	}
}

func (s *TestOneofBackwardsCompatible) Copy() *TestOneofBackwardsCompatible {
	if s == nil {
		return nil
	}
	res := &TestOneofBackwardsCompatible{}
	res.FooInt = s.FooInt
	res.FooString = s.FooString
	if s.FooMessage != nil {
		res.FooMessage = s.FooMessage.Copy()
	}

	return res
}

func (s *TestOneofBackwardsCompatible) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.FooInt != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestOneofBackwardsCompatible_FooInt) + gremlin.SizeInt32(s.FooInt)
		size += entrySize
	}

	if s.FooString != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.FooString)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestOneofBackwardsCompatible_FooString)
		size += entrySize
	}

	if s.FooMessage != nil {
		var entrySize = 0
		entrySize = s.FooMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestOneofBackwardsCompatible_FooMessage)
		
		size += entrySize
	}

	return size
}

const (
	wireTestOneof2_FooInt gremlin.ProtoWireNumber = 1
	wireTestOneof2_FooString gremlin.ProtoWireNumber = 2
	wireTestOneof2_FooCord gremlin.ProtoWireNumber = 3
	wireTestOneof2_FooStringPiece gremlin.ProtoWireNumber = 4
	wireTestOneof2_FooBytes gremlin.ProtoWireNumber = 5
	wireTestOneof2_FooEnum gremlin.ProtoWireNumber = 6
	wireTestOneof2_FooMessage gremlin.ProtoWireNumber = 7
	wireTestOneof2_FooLazyMessage gremlin.ProtoWireNumber = 11
	wireTestOneof2_BarInt gremlin.ProtoWireNumber = 12
	wireTestOneof2_BarString gremlin.ProtoWireNumber = 13
	wireTestOneof2_BarCord gremlin.ProtoWireNumber = 14
	wireTestOneof2_BarStringPiece gremlin.ProtoWireNumber = 15
	wireTestOneof2_BarBytes gremlin.ProtoWireNumber = 16
	wireTestOneof2_BarEnum gremlin.ProtoWireNumber = 17
	wireTestOneof2_BarStringWithEmptyDefault gremlin.ProtoWireNumber = 20
	wireTestOneof2_BarCordWithEmptyDefault gremlin.ProtoWireNumber = 21
	wireTestOneof2_BarStringPieceWithEmptyDefault gremlin.ProtoWireNumber = 22
	wireTestOneof2_BarBytesWithEmptyDefault gremlin.ProtoWireNumber = 23
	wireTestOneof2_BazInt gremlin.ProtoWireNumber = 18
	wireTestOneof2_BazString gremlin.ProtoWireNumber = 19
)

type TestOneof2Reader struct {
	buf *gremlin.Reader

	dataFooInt     int32
	dataFooString     string
	dataFooCord     string
	dataFooStringPiece     string
	dataFooBytes     []byte
	dataFooEnum     TestOneof2_NestedEnum
	dataFooMessage     *TestOneof2_NestedMessageReader
	dataFooLazyMessage     *TestOneof2_NestedMessageReader
	dataBarInt     int32
	dataBarString     string
	dataBarCord     string
	dataBarStringPiece     string
	dataBarBytes     []byte
	dataBarEnum     TestOneof2_NestedEnum
	dataBarStringWithEmptyDefault     string
	dataBarCordWithEmptyDefault     string
	dataBarStringPieceWithEmptyDefault     string
	dataBarBytesWithEmptyDefault     []byte
	dataBazInt     int32
	dataBazString     string

	offsetFooInt   int
	offsetFooString   int
	offsetFooCord   int
	offsetFooStringPiece   int
	offsetFooBytes   int
	offsetFooEnum   int
	offsetFooMessage   int
	offsetFooLazyMessage   int
	offsetBarInt   int
	offsetBarString   int
	offsetBarCord   int
	offsetBarStringPiece   int
	offsetBarBytes   int
	offsetBarEnum   int
	offsetBarStringWithEmptyDefault   int
	offsetBarCordWithEmptyDefault   int
	offsetBarStringPieceWithEmptyDefault   int
	offsetBarBytesWithEmptyDefault   int
	offsetBazInt   int
	offsetBazString   int

	parsedFooInt   bool
	parsedFooString   bool
	parsedFooCord   bool
	parsedFooStringPiece   bool
	parsedFooBytes   bool
	parsedFooEnum   bool
	parsedFooMessage   bool
	parsedFooLazyMessage   bool
	parsedBarInt   bool
	parsedBarString   bool
	parsedBarCord   bool
	parsedBarStringPiece   bool
	parsedBarBytes   bool
	parsedBarEnum   bool
	parsedBarStringWithEmptyDefault   bool
	parsedBarCordWithEmptyDefault   bool
	parsedBarStringPieceWithEmptyDefault   bool
	parsedBarBytesWithEmptyDefault   bool
	parsedBazInt   bool
	parsedBazString   bool
}

func NewTestOneof2Reader() *TestOneof2Reader {
	return &TestOneof2Reader{}
}

func (m *TestOneof2Reader) GetFooInt() int32 {
	if m == nil {
		return 0
	}
	return m.readFooInt()
}

func (m *TestOneof2Reader) readFooInt() int32 {
	if m.parsedFooInt {
		return m.dataFooInt
	}
	wOffset := m.offsetFooInt
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataFooInt = entry
	m.parsedFooInt = true
	return entry
}

func (m *TestOneof2Reader) GetFooString() string {
	if m == nil {
		return ""
	}
	return m.readFooString()
}

func (m *TestOneof2Reader) readFooString() string {
	if m.parsedFooString {
		return m.dataFooString
	}
	wOffset := m.offsetFooString
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataFooString = entry
	m.parsedFooString = true
	return entry
}

func (m *TestOneof2Reader) GetFooCord() string {
	if m == nil {
		return ""
	}
	return m.readFooCord()
}

func (m *TestOneof2Reader) readFooCord() string {
	if m.parsedFooCord {
		return m.dataFooCord
	}
	wOffset := m.offsetFooCord
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataFooCord = entry
	m.parsedFooCord = true
	return entry
}

func (m *TestOneof2Reader) GetFooStringPiece() string {
	if m == nil {
		return ""
	}
	return m.readFooStringPiece()
}

func (m *TestOneof2Reader) readFooStringPiece() string {
	if m.parsedFooStringPiece {
		return m.dataFooStringPiece
	}
	wOffset := m.offsetFooStringPiece
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataFooStringPiece = entry
	m.parsedFooStringPiece = true
	return entry
}

func (m *TestOneof2Reader) GetFooBytes() []byte {
	if m == nil {
		return nil
	}
	return m.readFooBytes()
}

func (m *TestOneof2Reader) readFooBytes() []byte {
	if m.parsedFooBytes {
		return m.dataFooBytes
	}
	wOffset := m.offsetFooBytes
	
	var entry []byte
	if wOffset > 0 {
		entry = m.buf.ReadBytes(wOffset)
	}
	
	m.dataFooBytes = entry
	m.parsedFooBytes = true
	return entry
}

func (m *TestOneof2Reader) GetFooEnum() TestOneof2_NestedEnum {
	if m == nil {
		return 0
	}
	return m.readFooEnum()
}

func (m *TestOneof2Reader) readFooEnum() TestOneof2_NestedEnum {
	if m.parsedFooEnum {
		return m.dataFooEnum
	}
	wOffset := m.offsetFooEnum
	
	var entry TestOneof2_NestedEnum
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = TestOneof2_NestedEnum(rawEntry)
	} else {
		entry = 0
	}
	
	m.dataFooEnum = entry
	m.parsedFooEnum = true
	return entry
}

func (m *TestOneof2Reader) GetFooMessage() *TestOneof2_NestedMessageReader {
	if m == nil {
		return nil
	}
	return m.readFooMessage()
}

func (m *TestOneof2Reader) readFooMessage() *TestOneof2_NestedMessageReader {
	if m.parsedFooMessage {
		return m.dataFooMessage
	}
	wOffset := m.offsetFooMessage
	
	var entry *TestOneof2_NestedMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestOneof2_NestedMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataFooMessage = entry
	m.parsedFooMessage = true
	return entry
}

func (m *TestOneof2Reader) GetFooLazyMessage() *TestOneof2_NestedMessageReader {
	if m == nil {
		return nil
	}
	return m.readFooLazyMessage()
}

func (m *TestOneof2Reader) readFooLazyMessage() *TestOneof2_NestedMessageReader {
	if m.parsedFooLazyMessage {
		return m.dataFooLazyMessage
	}
	wOffset := m.offsetFooLazyMessage
	
	var entry *TestOneof2_NestedMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestOneof2_NestedMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataFooLazyMessage = entry
	m.parsedFooLazyMessage = true
	return entry
}

func (m *TestOneof2Reader) GetBarInt() int32 {
	if m == nil {
		return 5
	}
	return m.readBarInt()
}

func (m *TestOneof2Reader) readBarInt() int32 {
	if m.parsedBarInt {
		return m.dataBarInt
	}
	wOffset := m.offsetBarInt
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	} else {
		entry = 5
	}
	
	m.dataBarInt = entry
	m.parsedBarInt = true
	return entry
}

func (m *TestOneof2Reader) GetBarString() string {
	if m == nil {
		return "STRING"
	}
	return m.readBarString()
}

func (m *TestOneof2Reader) readBarString() string {
	if m.parsedBarString {
		return m.dataBarString
	}
	wOffset := m.offsetBarString
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	} else {
		entry = "STRING"
	}
	
	m.dataBarString = entry
	m.parsedBarString = true
	return entry
}

func (m *TestOneof2Reader) GetBarCord() string {
	if m == nil {
		return "CORD"
	}
	return m.readBarCord()
}

func (m *TestOneof2Reader) readBarCord() string {
	if m.parsedBarCord {
		return m.dataBarCord
	}
	wOffset := m.offsetBarCord
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	} else {
		entry = "CORD"
	}
	
	m.dataBarCord = entry
	m.parsedBarCord = true
	return entry
}

func (m *TestOneof2Reader) GetBarStringPiece() string {
	if m == nil {
		return "SPIECE"
	}
	return m.readBarStringPiece()
}

func (m *TestOneof2Reader) readBarStringPiece() string {
	if m.parsedBarStringPiece {
		return m.dataBarStringPiece
	}
	wOffset := m.offsetBarStringPiece
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	} else {
		entry = "SPIECE"
	}
	
	m.dataBarStringPiece = entry
	m.parsedBarStringPiece = true
	return entry
}

func (m *TestOneof2Reader) GetBarBytes() []byte {
	if m == nil {
		return []byte("BYTES")
	}
	return m.readBarBytes()
}

func (m *TestOneof2Reader) readBarBytes() []byte {
	if m.parsedBarBytes {
		return m.dataBarBytes
	}
	wOffset := m.offsetBarBytes
	
	var entry []byte
	if wOffset > 0 {
		entry = m.buf.ReadBytes(wOffset)
	} else {
		entry = []byte("BYTES")
	}
	
	m.dataBarBytes = entry
	m.parsedBarBytes = true
	return entry
}

func (m *TestOneof2Reader) GetBarEnum() TestOneof2_NestedEnum {
	if m == nil {
		return 0
	}
	return m.readBarEnum()
}

func (m *TestOneof2Reader) readBarEnum() TestOneof2_NestedEnum {
	if m.parsedBarEnum {
		return m.dataBarEnum
	}
	wOffset := m.offsetBarEnum
	
	var entry TestOneof2_NestedEnum
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = TestOneof2_NestedEnum(rawEntry)
	} else {
		entry = 0
	}
	
	m.dataBarEnum = entry
	m.parsedBarEnum = true
	return entry
}

func (m *TestOneof2Reader) GetBarStringWithEmptyDefault() string {
	if m == nil {
		return ""
	}
	return m.readBarStringWithEmptyDefault()
}

func (m *TestOneof2Reader) readBarStringWithEmptyDefault() string {
	if m.parsedBarStringWithEmptyDefault {
		return m.dataBarStringWithEmptyDefault
	}
	wOffset := m.offsetBarStringWithEmptyDefault
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	} else {
		entry = ""
	}
	
	m.dataBarStringWithEmptyDefault = entry
	m.parsedBarStringWithEmptyDefault = true
	return entry
}

func (m *TestOneof2Reader) GetBarCordWithEmptyDefault() string {
	if m == nil {
		return ""
	}
	return m.readBarCordWithEmptyDefault()
}

func (m *TestOneof2Reader) readBarCordWithEmptyDefault() string {
	if m.parsedBarCordWithEmptyDefault {
		return m.dataBarCordWithEmptyDefault
	}
	wOffset := m.offsetBarCordWithEmptyDefault
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	} else {
		entry = ""
	}
	
	m.dataBarCordWithEmptyDefault = entry
	m.parsedBarCordWithEmptyDefault = true
	return entry
}

func (m *TestOneof2Reader) GetBarStringPieceWithEmptyDefault() string {
	if m == nil {
		return ""
	}
	return m.readBarStringPieceWithEmptyDefault()
}

func (m *TestOneof2Reader) readBarStringPieceWithEmptyDefault() string {
	if m.parsedBarStringPieceWithEmptyDefault {
		return m.dataBarStringPieceWithEmptyDefault
	}
	wOffset := m.offsetBarStringPieceWithEmptyDefault
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	} else {
		entry = ""
	}
	
	m.dataBarStringPieceWithEmptyDefault = entry
	m.parsedBarStringPieceWithEmptyDefault = true
	return entry
}

func (m *TestOneof2Reader) GetBarBytesWithEmptyDefault() []byte {
	if m == nil {
		return []byte("")
	}
	return m.readBarBytesWithEmptyDefault()
}

func (m *TestOneof2Reader) readBarBytesWithEmptyDefault() []byte {
	if m.parsedBarBytesWithEmptyDefault {
		return m.dataBarBytesWithEmptyDefault
	}
	wOffset := m.offsetBarBytesWithEmptyDefault
	
	var entry []byte
	if wOffset > 0 {
		entry = m.buf.ReadBytes(wOffset)
	} else {
		entry = []byte("")
	}
	
	m.dataBarBytesWithEmptyDefault = entry
	m.parsedBarBytesWithEmptyDefault = true
	return entry
}

func (m *TestOneof2Reader) GetBazInt() int32 {
	if m == nil {
		return 0
	}
	return m.readBazInt()
}

func (m *TestOneof2Reader) readBazInt() int32 {
	if m.parsedBazInt {
		return m.dataBazInt
	}
	wOffset := m.offsetBazInt
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataBazInt = entry
	m.parsedBazInt = true
	return entry
}

func (m *TestOneof2Reader) GetBazString() string {
	if m == nil {
		return "BAZ"
	}
	return m.readBazString()
}

func (m *TestOneof2Reader) readBazString() string {
	if m.parsedBazString {
		return m.dataBazString
	}
	wOffset := m.offsetBazString
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	} else {
		entry = "BAZ"
	}
	
	m.dataBazString = entry
	m.parsedBazString = true
	return entry
}

func (m *TestOneof2Reader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestOneof2_FooInt:
			m.offsetFooInt = offset
		case wireTestOneof2_FooString:
			m.offsetFooString = offset
		case wireTestOneof2_FooCord:
			m.offsetFooCord = offset
		case wireTestOneof2_FooStringPiece:
			m.offsetFooStringPiece = offset
		case wireTestOneof2_FooBytes:
			m.offsetFooBytes = offset
		case wireTestOneof2_FooEnum:
			m.offsetFooEnum = offset
		case wireTestOneof2_FooMessage:
			m.offsetFooMessage = offset
		case wireTestOneof2_FooLazyMessage:
			m.offsetFooLazyMessage = offset
		case wireTestOneof2_BarInt:
			m.offsetBarInt = offset
		case wireTestOneof2_BarString:
			m.offsetBarString = offset
		case wireTestOneof2_BarCord:
			m.offsetBarCord = offset
		case wireTestOneof2_BarStringPiece:
			m.offsetBarStringPiece = offset
		case wireTestOneof2_BarBytes:
			m.offsetBarBytes = offset
		case wireTestOneof2_BarEnum:
			m.offsetBarEnum = offset
		case wireTestOneof2_BarStringWithEmptyDefault:
			m.offsetBarStringWithEmptyDefault = offset
		case wireTestOneof2_BarCordWithEmptyDefault:
			m.offsetBarCordWithEmptyDefault = offset
		case wireTestOneof2_BarStringPieceWithEmptyDefault:
			m.offsetBarStringPieceWithEmptyDefault = offset
		case wireTestOneof2_BarBytesWithEmptyDefault:
			m.offsetBarBytesWithEmptyDefault = offset
		case wireTestOneof2_BazInt:
			m.offsetBazInt = offset
		case wireTestOneof2_BazString:
			m.offsetBazString = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestOneof2Reader) ToStruct() *TestOneof2 {
	if m == nil {
		return nil
	}
	res := &TestOneof2{}
	res.FooInt = m.GetFooInt()
	res.FooString = m.GetFooString()
	res.FooCord = m.GetFooCord()
	res.FooStringPiece = m.GetFooStringPiece()
	res.FooBytes = m.GetFooBytes()
	res.FooEnum = m.GetFooEnum()

	{
		var data = m.GetFooMessage()
		var structData *TestOneof2_NestedMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.FooMessage = structData
	}

	{
		var data = m.GetFooLazyMessage()
		var structData *TestOneof2_NestedMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.FooLazyMessage = structData
	}
	res.BarInt = m.GetBarInt()
	res.BarString = m.GetBarString()
	res.BarCord = m.GetBarCord()
	res.BarStringPiece = m.GetBarStringPiece()
	res.BarBytes = m.GetBarBytes()
	res.BarEnum = m.GetBarEnum()
	res.BarStringWithEmptyDefault = m.GetBarStringWithEmptyDefault()
	res.BarCordWithEmptyDefault = m.GetBarCordWithEmptyDefault()
	res.BarStringPieceWithEmptyDefault = m.GetBarStringPieceWithEmptyDefault()
	res.BarBytesWithEmptyDefault = m.GetBarBytesWithEmptyDefault()
	res.BazInt = m.GetBazInt()
	res.BazString = m.GetBazString()

	return res
}

func (s *TestOneof2Reader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestOneof2 struct {
	FooInt	int32	`json:"foo_int,omitempty"`
	FooString	string	`json:"foo_string,omitempty"`
	FooCord	string	`json:"foo_cord,omitempty"`
	FooStringPiece	string	`json:"foo_string_piece,omitempty"`
	FooBytes	[]byte	`json:"foo_bytes,omitempty"`
	FooEnum	TestOneof2_NestedEnum	`json:"foo_enum,omitempty"`
	FooMessage	*TestOneof2_NestedMessage	`json:"foo_message,omitempty"`
	FooLazyMessage	*TestOneof2_NestedMessage	`json:"foo_lazy_message,omitempty"`
	BarInt	int32	`json:"bar_int,omitempty"`
	BarString	string	`json:"bar_string,omitempty"`
	BarCord	string	`json:"bar_cord,omitempty"`
	BarStringPiece	string	`json:"bar_string_piece,omitempty"`
	BarBytes	[]byte	`json:"bar_bytes,omitempty"`
	BarEnum	TestOneof2_NestedEnum	`json:"bar_enum,omitempty"`
	BarStringWithEmptyDefault	string	`json:"bar_string_with_empty_default,omitempty"`
	BarCordWithEmptyDefault	string	`json:"bar_cord_with_empty_default,omitempty"`
	BarStringPieceWithEmptyDefault	string	`json:"bar_string_piece_with_empty_default,omitempty"`
	BarBytesWithEmptyDefault	[]byte	`json:"bar_bytes_with_empty_default,omitempty"`
	BazInt	int32	`json:"baz_int,omitempty"`
	BazString	string	`json:"baz_string,omitempty"`
}

func (s *TestOneof2) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestOneof2) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.FooInt != 0 {
		res.AppendInt32(wireTestOneof2_FooInt, s.FooInt)
	}
	if s.FooString != "" {
		res.AppendString(wireTestOneof2_FooString, s.FooString)
	}
	if s.FooCord != "" {
		res.AppendString(wireTestOneof2_FooCord, s.FooCord)
	}
	if s.FooStringPiece != "" {
		res.AppendString(wireTestOneof2_FooStringPiece, s.FooStringPiece)
	}
	if len(s.FooBytes) != 0 {
		res.AppendBytes(wireTestOneof2_FooBytes, s.FooBytes)
	}
	if s.FooEnum != 0 {
		res.AppendInt32(wireTestOneof2_FooEnum, int32(s.FooEnum))
	}
	if s.FooMessage != nil {
		structSize := s.FooMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestOneof2_FooMessage, structSize)
		s.FooMessage.MarshalTo(res)
	}
	if s.FooLazyMessage != nil {
		structSize := s.FooLazyMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestOneof2_FooLazyMessage, structSize)
		s.FooLazyMessage.MarshalTo(res)
	}
	if s.BarInt != 5 {
		res.AppendInt32(wireTestOneof2_BarInt, s.BarInt)
	}
	if s.BarString != "STRING" {
		res.AppendString(wireTestOneof2_BarString, s.BarString)
	}
	if s.BarCord != "CORD" {
		res.AppendString(wireTestOneof2_BarCord, s.BarCord)
	}
	if s.BarStringPiece != "SPIECE" {
		res.AppendString(wireTestOneof2_BarStringPiece, s.BarStringPiece)
	}
	if !bytes.Equal(s.BarBytes, []byte("BYTES")) {
		res.AppendBytes(wireTestOneof2_BarBytes, s.BarBytes)
	}
	if s.BarEnum != 0 {
		res.AppendInt32(wireTestOneof2_BarEnum, int32(s.BarEnum))
	}
	if s.BarStringWithEmptyDefault != "" {
		res.AppendString(wireTestOneof2_BarStringWithEmptyDefault, s.BarStringWithEmptyDefault)
	}
	if s.BarCordWithEmptyDefault != "" {
		res.AppendString(wireTestOneof2_BarCordWithEmptyDefault, s.BarCordWithEmptyDefault)
	}
	if s.BarStringPieceWithEmptyDefault != "" {
		res.AppendString(wireTestOneof2_BarStringPieceWithEmptyDefault, s.BarStringPieceWithEmptyDefault)
	}
	if !bytes.Equal(s.BarBytesWithEmptyDefault, []byte("")) {
		res.AppendBytes(wireTestOneof2_BarBytesWithEmptyDefault, s.BarBytesWithEmptyDefault)
	}
	if s.BazInt != 0 {
		res.AppendInt32(wireTestOneof2_BazInt, s.BazInt)
	}
	if s.BazString != "BAZ" {
		res.AppendString(wireTestOneof2_BazString, s.BazString)
	}
}

func (s *TestOneof2) Copy() *TestOneof2 {
	if s == nil {
		return nil
	}
	res := &TestOneof2{}
	res.FooInt = s.FooInt
	res.FooString = s.FooString
	res.FooCord = s.FooCord
	res.FooStringPiece = s.FooStringPiece
	res.FooBytes = s.FooBytes
	res.FooEnum = s.FooEnum
	if s.FooMessage != nil {
		res.FooMessage = s.FooMessage.Copy()
	}
	if s.FooLazyMessage != nil {
		res.FooLazyMessage = s.FooLazyMessage.Copy()
	}
	res.BarInt = s.BarInt
	res.BarString = s.BarString
	res.BarCord = s.BarCord
	res.BarStringPiece = s.BarStringPiece
	res.BarBytes = s.BarBytes
	res.BarEnum = s.BarEnum
	res.BarStringWithEmptyDefault = s.BarStringWithEmptyDefault
	res.BarCordWithEmptyDefault = s.BarCordWithEmptyDefault
	res.BarStringPieceWithEmptyDefault = s.BarStringPieceWithEmptyDefault
	res.BarBytesWithEmptyDefault = s.BarBytesWithEmptyDefault
	res.BazInt = s.BazInt
	res.BazString = s.BazString

	return res
}

func (s *TestOneof2) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.FooInt != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestOneof2_FooInt) + gremlin.SizeInt32(s.FooInt)
		size += entrySize
	}

	if s.FooString != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.FooString)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestOneof2_FooString)
		size += entrySize
	}

	if s.FooCord != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.FooCord)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestOneof2_FooCord)
		size += entrySize
	}

	if s.FooStringPiece != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.FooStringPiece)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestOneof2_FooStringPiece)
		size += entrySize
	}

	if len(s.FooBytes) != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeBytes(s.FooBytes)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestOneof2_FooBytes)
		size += entrySize
	}

	if s.FooEnum != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestOneof2_FooEnum) + gremlin.SizeInt32(int32(s.FooEnum))
		size += entrySize
	}

	if s.FooMessage != nil {
		var entrySize = 0
		entrySize = s.FooMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestOneof2_FooMessage)
		
		size += entrySize
	}

	if s.FooLazyMessage != nil {
		var entrySize = 0
		entrySize = s.FooLazyMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestOneof2_FooLazyMessage)
		
		size += entrySize
	}

	if s.BarInt != 5 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestOneof2_BarInt) + gremlin.SizeInt32(s.BarInt)
		size += entrySize
	}

	if s.BarString != "STRING" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.BarString)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestOneof2_BarString)
		size += entrySize
	}

	if s.BarCord != "CORD" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.BarCord)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestOneof2_BarCord)
		size += entrySize
	}

	if s.BarStringPiece != "SPIECE" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.BarStringPiece)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestOneof2_BarStringPiece)
		size += entrySize
	}

	if !bytes.Equal(s.BarBytes, []byte("BYTES")) {
		var entrySize = 0
		entrySize = gremlin.SizeBytes(s.BarBytes)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestOneof2_BarBytes)
		size += entrySize
	}

	if s.BarEnum != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestOneof2_BarEnum) + gremlin.SizeInt32(int32(s.BarEnum))
		size += entrySize
	}

	if s.BarStringWithEmptyDefault != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.BarStringWithEmptyDefault)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestOneof2_BarStringWithEmptyDefault)
		size += entrySize
	}

	if s.BarCordWithEmptyDefault != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.BarCordWithEmptyDefault)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestOneof2_BarCordWithEmptyDefault)
		size += entrySize
	}

	if s.BarStringPieceWithEmptyDefault != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.BarStringPieceWithEmptyDefault)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestOneof2_BarStringPieceWithEmptyDefault)
		size += entrySize
	}

	if !bytes.Equal(s.BarBytesWithEmptyDefault, []byte("")) {
		var entrySize = 0
		entrySize = gremlin.SizeBytes(s.BarBytesWithEmptyDefault)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestOneof2_BarBytesWithEmptyDefault)
		size += entrySize
	}

	if s.BazInt != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestOneof2_BazInt) + gremlin.SizeInt32(s.BazInt)
		size += entrySize
	}

	if s.BazString != "BAZ" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.BazString)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestOneof2_BazString)
		size += entrySize
	}

	return size
}

const (
	wireTestOneof2_NestedMessage_MooInt gremlin.ProtoWireNumber = 1
	wireTestOneof2_NestedMessage_CorgeInt gremlin.ProtoWireNumber = 2
)

type TestOneof2_NestedMessageReader struct {
	buf *gremlin.Reader

	dataMooInt     int64
	dataCorgeInt     []int32

	offsetMooInt   int
	offsetCorgeInt   []int
	wireTypeCorgeInt []gremlin.ProtoWireType

	parsedMooInt   bool
	parsedCorgeInt   bool
}

func NewTestOneof2_NestedMessageReader() *TestOneof2_NestedMessageReader {
	return &TestOneof2_NestedMessageReader{}
}

func (m *TestOneof2_NestedMessageReader) GetMooInt() int64 {
	if m == nil {
		return 0
	}
	return m.readMooInt()
}

func (m *TestOneof2_NestedMessageReader) readMooInt() int64 {
	if m.parsedMooInt {
		return m.dataMooInt
	}
	wOffset := m.offsetMooInt
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadInt64(wOffset)
	}
	
	m.dataMooInt = entry
	m.parsedMooInt = true
	return entry
}

func (m *TestOneof2_NestedMessageReader) GetCorgeInt() []int32 {
	if m == nil {
		return nil
	}
	return m.readCorgeInt()
}

func (m *TestOneof2_NestedMessageReader) readCorgeInt() []int32 {
	if m.parsedCorgeInt {
		return m.dataCorgeInt
	}
	wOffset := m.offsetCorgeInt
	var wType = m.wireTypeCorgeInt
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadInt32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataCorgeInt = entry
	m.parsedCorgeInt = true
	return entry
}

func (m *TestOneof2_NestedMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestOneof2_NestedMessage_MooInt:
			m.offsetMooInt = offset
		case wireTestOneof2_NestedMessage_CorgeInt:
			m.offsetCorgeInt = append(m.offsetCorgeInt, offset)
			m.wireTypeCorgeInt = append(m.wireTypeCorgeInt, wire)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestOneof2_NestedMessageReader) ToStruct() *TestOneof2_NestedMessage {
	if m == nil {
		return nil
	}
	res := &TestOneof2_NestedMessage{}
	res.MooInt = m.GetMooInt()
	res.CorgeInt = m.GetCorgeInt()

	return res
}

func (s *TestOneof2_NestedMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestOneof2_NestedMessage struct {
	MooInt	int64	`json:"moo_int,omitempty"`
	CorgeInt	[]int32	`json:"corge_int,omitempty"`
}

func (s *TestOneof2_NestedMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestOneof2_NestedMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.MooInt != 0 {
		res.AppendInt64(wireTestOneof2_NestedMessage_MooInt, s.MooInt)
	}
	if len(s.CorgeInt) > 0 {
		if len(s.CorgeInt) > 1 {
			var listBytesSize = 0
			for _, entry := range s.CorgeInt {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestOneof2_NestedMessage_CorgeInt, listBytesSize)
			for _, entry := range s.CorgeInt {
				res.AppendInt32WithoutTag(entry)
			}
		} else if len(s.CorgeInt) == 1 {
			res.AppendInt32(wireTestOneof2_NestedMessage_CorgeInt, s.CorgeInt[0])
		}
	}
}

func (s *TestOneof2_NestedMessage) Copy() *TestOneof2_NestedMessage {
	if s == nil {
		return nil
	}
	res := &TestOneof2_NestedMessage{}
	res.MooInt = s.MooInt
	res.CorgeInt = s.CorgeInt

	return res
}

func (s *TestOneof2_NestedMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.MooInt != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestOneof2_NestedMessage_MooInt) + gremlin.SizeInt64(s.MooInt)
		size += entrySize
	}

	if len(s.CorgeInt) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.CorgeInt) > 1 {
			var listBytesSize = 0
			for _, entry := range s.CorgeInt {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestOneof2_NestedMessage_CorgeInt) + listBytesSize
		} else if len(s.CorgeInt) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestOneof2_NestedMessage_CorgeInt) + gremlin.SizeInt32(s.CorgeInt[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	return size
}

const (
	wireTestRequiredOneof_FooInt gremlin.ProtoWireNumber = 1
	wireTestRequiredOneof_FooString gremlin.ProtoWireNumber = 2
	wireTestRequiredOneof_FooMessage gremlin.ProtoWireNumber = 3
)

type TestRequiredOneofReader struct {
	buf *gremlin.Reader

	dataFooInt     int32
	dataFooString     string
	dataFooMessage     *TestRequiredOneof_NestedMessageReader

	offsetFooInt   int
	offsetFooString   int
	offsetFooMessage   int

	parsedFooInt   bool
	parsedFooString   bool
	parsedFooMessage   bool
}

func NewTestRequiredOneofReader() *TestRequiredOneofReader {
	return &TestRequiredOneofReader{}
}

func (m *TestRequiredOneofReader) GetFooInt() int32 {
	if m == nil {
		return 0
	}
	return m.readFooInt()
}

func (m *TestRequiredOneofReader) readFooInt() int32 {
	if m.parsedFooInt {
		return m.dataFooInt
	}
	wOffset := m.offsetFooInt
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataFooInt = entry
	m.parsedFooInt = true
	return entry
}

func (m *TestRequiredOneofReader) GetFooString() string {
	if m == nil {
		return ""
	}
	return m.readFooString()
}

func (m *TestRequiredOneofReader) readFooString() string {
	if m.parsedFooString {
		return m.dataFooString
	}
	wOffset := m.offsetFooString
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataFooString = entry
	m.parsedFooString = true
	return entry
}

func (m *TestRequiredOneofReader) GetFooMessage() *TestRequiredOneof_NestedMessageReader {
	if m == nil {
		return nil
	}
	return m.readFooMessage()
}

func (m *TestRequiredOneofReader) readFooMessage() *TestRequiredOneof_NestedMessageReader {
	if m.parsedFooMessage {
		return m.dataFooMessage
	}
	wOffset := m.offsetFooMessage
	
	var entry *TestRequiredOneof_NestedMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestRequiredOneof_NestedMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataFooMessage = entry
	m.parsedFooMessage = true
	return entry
}

func (m *TestRequiredOneofReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestRequiredOneof_FooInt:
			m.offsetFooInt = offset
		case wireTestRequiredOneof_FooString:
			m.offsetFooString = offset
		case wireTestRequiredOneof_FooMessage:
			m.offsetFooMessage = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestRequiredOneofReader) ToStruct() *TestRequiredOneof {
	if m == nil {
		return nil
	}
	res := &TestRequiredOneof{}
	res.FooInt = m.GetFooInt()
	res.FooString = m.GetFooString()

	{
		var data = m.GetFooMessage()
		var structData *TestRequiredOneof_NestedMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.FooMessage = structData
	}

	return res
}

func (s *TestRequiredOneofReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestRequiredOneof struct {
	FooInt	int32	`json:"foo_int,omitempty"`
	FooString	string	`json:"foo_string,omitempty"`
	FooMessage	*TestRequiredOneof_NestedMessage	`json:"foo_message,omitempty"`
}

func (s *TestRequiredOneof) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestRequiredOneof) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.FooInt != 0 {
		res.AppendInt32(wireTestRequiredOneof_FooInt, s.FooInt)
	}
	if s.FooString != "" {
		res.AppendString(wireTestRequiredOneof_FooString, s.FooString)
	}
	if s.FooMessage != nil {
		structSize := s.FooMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestRequiredOneof_FooMessage, structSize)
		s.FooMessage.MarshalTo(res)
	}
}

func (s *TestRequiredOneof) Copy() *TestRequiredOneof {
	if s == nil {
		return nil
	}
	res := &TestRequiredOneof{}
	res.FooInt = s.FooInt
	res.FooString = s.FooString
	if s.FooMessage != nil {
		res.FooMessage = s.FooMessage.Copy()
	}

	return res
}

func (s *TestRequiredOneof) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.FooInt != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequiredOneof_FooInt) + gremlin.SizeInt32(s.FooInt)
		size += entrySize
	}

	if s.FooString != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.FooString)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestRequiredOneof_FooString)
		size += entrySize
	}

	if s.FooMessage != nil {
		var entrySize = 0
		entrySize = s.FooMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestRequiredOneof_FooMessage)
		
		size += entrySize
	}

	return size
}

const (
	wireTestRequiredOneof_NestedMessage_RequiredDouble gremlin.ProtoWireNumber = 1
)

type TestRequiredOneof_NestedMessageReader struct {
	buf *gremlin.Reader

	dataRequiredDouble     float64

	offsetRequiredDouble   int

	parsedRequiredDouble   bool
}

func NewTestRequiredOneof_NestedMessageReader() *TestRequiredOneof_NestedMessageReader {
	return &TestRequiredOneof_NestedMessageReader{}
}

func (m *TestRequiredOneof_NestedMessageReader) GetRequiredDouble() float64 {
	if m == nil {
		return 0
	}
	return m.readRequiredDouble()
}

func (m *TestRequiredOneof_NestedMessageReader) readRequiredDouble() float64 {
	if m.parsedRequiredDouble {
		return m.dataRequiredDouble
	}
	wOffset := m.offsetRequiredDouble
	
	var entry float64
	if wOffset > 0 {
		entry = m.buf.ReadFloat64(wOffset)
	}
	
	m.dataRequiredDouble = entry
	m.parsedRequiredDouble = true
	return entry
}

func (m *TestRequiredOneof_NestedMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestRequiredOneof_NestedMessage_RequiredDouble:
			m.offsetRequiredDouble = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestRequiredOneof_NestedMessageReader) ToStruct() *TestRequiredOneof_NestedMessage {
	if m == nil {
		return nil
	}
	res := &TestRequiredOneof_NestedMessage{}
	res.RequiredDouble = m.GetRequiredDouble()

	return res
}

func (s *TestRequiredOneof_NestedMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestRequiredOneof_NestedMessage struct {
	RequiredDouble	float64	`json:"required_double,omitempty"`
}

func (s *TestRequiredOneof_NestedMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestRequiredOneof_NestedMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if true {
		res.AppendFloat64(wireTestRequiredOneof_NestedMessage_RequiredDouble, s.RequiredDouble)
	}
}

func (s *TestRequiredOneof_NestedMessage) Copy() *TestRequiredOneof_NestedMessage {
	if s == nil {
		return nil
	}
	res := &TestRequiredOneof_NestedMessage{}
	res.RequiredDouble = s.RequiredDouble

	return res
}

func (s *TestRequiredOneof_NestedMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if true {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestRequiredOneof_NestedMessage_RequiredDouble) + gremlin.SizeFloat64(s.RequiredDouble)
		size += entrySize
	}

	return size
}

const (
	wireTestPackedTypes_PackedInt32 gremlin.ProtoWireNumber = 90
	wireTestPackedTypes_PackedInt64 gremlin.ProtoWireNumber = 91
	wireTestPackedTypes_PackedUint32 gremlin.ProtoWireNumber = 92
	wireTestPackedTypes_PackedUint64 gremlin.ProtoWireNumber = 93
	wireTestPackedTypes_PackedSint32 gremlin.ProtoWireNumber = 94
	wireTestPackedTypes_PackedSint64 gremlin.ProtoWireNumber = 95
	wireTestPackedTypes_PackedFixed32 gremlin.ProtoWireNumber = 96
	wireTestPackedTypes_PackedFixed64 gremlin.ProtoWireNumber = 97
	wireTestPackedTypes_PackedSfixed32 gremlin.ProtoWireNumber = 98
	wireTestPackedTypes_PackedSfixed64 gremlin.ProtoWireNumber = 99
	wireTestPackedTypes_PackedFloat gremlin.ProtoWireNumber = 100
	wireTestPackedTypes_PackedDouble gremlin.ProtoWireNumber = 101
	wireTestPackedTypes_PackedBool gremlin.ProtoWireNumber = 102
	wireTestPackedTypes_PackedEnum gremlin.ProtoWireNumber = 103
)

type TestPackedTypesReader struct {
	buf *gremlin.Reader

	dataPackedInt32     []int32
	dataPackedInt64     []int64
	dataPackedUint32     []uint32
	dataPackedUint64     []uint64
	dataPackedSint32     []int32
	dataPackedSint64     []int64
	dataPackedFixed32     []uint32
	dataPackedFixed64     []uint64
	dataPackedSfixed32     []int32
	dataPackedSfixed64     []int64
	dataPackedFloat     []float32
	dataPackedDouble     []float64
	dataPackedBool     []bool
	dataPackedEnum     []ForeignEnum

	offsetPackedInt32   []int
	wireTypePackedInt32 []gremlin.ProtoWireType
	offsetPackedInt64   []int
	wireTypePackedInt64 []gremlin.ProtoWireType
	offsetPackedUint32   []int
	wireTypePackedUint32 []gremlin.ProtoWireType
	offsetPackedUint64   []int
	wireTypePackedUint64 []gremlin.ProtoWireType
	offsetPackedSint32   []int
	wireTypePackedSint32 []gremlin.ProtoWireType
	offsetPackedSint64   []int
	wireTypePackedSint64 []gremlin.ProtoWireType
	offsetPackedFixed32   []int
	wireTypePackedFixed32 []gremlin.ProtoWireType
	offsetPackedFixed64   []int
	wireTypePackedFixed64 []gremlin.ProtoWireType
	offsetPackedSfixed32   []int
	wireTypePackedSfixed32 []gremlin.ProtoWireType
	offsetPackedSfixed64   []int
	wireTypePackedSfixed64 []gremlin.ProtoWireType
	offsetPackedFloat   []int
	wireTypePackedFloat []gremlin.ProtoWireType
	offsetPackedDouble   []int
	wireTypePackedDouble []gremlin.ProtoWireType
	offsetPackedBool   []int
	wireTypePackedBool []gremlin.ProtoWireType
	offsetPackedEnum   []int
	wireTypePackedEnum []gremlin.ProtoWireType

	parsedPackedInt32   bool
	parsedPackedInt64   bool
	parsedPackedUint32   bool
	parsedPackedUint64   bool
	parsedPackedSint32   bool
	parsedPackedSint64   bool
	parsedPackedFixed32   bool
	parsedPackedFixed64   bool
	parsedPackedSfixed32   bool
	parsedPackedSfixed64   bool
	parsedPackedFloat   bool
	parsedPackedDouble   bool
	parsedPackedBool   bool
	parsedPackedEnum   bool
}

func NewTestPackedTypesReader() *TestPackedTypesReader {
	return &TestPackedTypesReader{}
}

func (m *TestPackedTypesReader) GetPackedInt32() []int32 {
	if m == nil {
		return nil
	}
	return m.readPackedInt32()
}

func (m *TestPackedTypesReader) readPackedInt32() []int32 {
	if m.parsedPackedInt32 {
		return m.dataPackedInt32
	}
	wOffset := m.offsetPackedInt32
	var wType = m.wireTypePackedInt32
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadInt32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedInt32 = entry
	m.parsedPackedInt32 = true
	return entry
}

func (m *TestPackedTypesReader) GetPackedInt64() []int64 {
	if m == nil {
		return nil
	}
	return m.readPackedInt64()
}

func (m *TestPackedTypesReader) readPackedInt64() []int64 {
	if m.parsedPackedInt64 {
		return m.dataPackedInt64
	}
	wOffset := m.offsetPackedInt64
	var wType = m.wireTypePackedInt64
	
	var entry []int64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadInt64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int64
			if wOffset > 0 {
				listEntry = m.buf.ReadInt64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedInt64 = entry
	m.parsedPackedInt64 = true
	return entry
}

func (m *TestPackedTypesReader) GetPackedUint32() []uint32 {
	if m == nil {
		return nil
	}
	return m.readPackedUint32()
}

func (m *TestPackedTypesReader) readPackedUint32() []uint32 {
	if m.parsedPackedUint32 {
		return m.dataPackedUint32
	}
	wOffset := m.offsetPackedUint32
	var wType = m.wireTypePackedUint32
	
	var entry []uint32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadUint32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint32
			if wOffset > 0 {
				listEntry = m.buf.ReadUint32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedUint32 = entry
	m.parsedPackedUint32 = true
	return entry
}

func (m *TestPackedTypesReader) GetPackedUint64() []uint64 {
	if m == nil {
		return nil
	}
	return m.readPackedUint64()
}

func (m *TestPackedTypesReader) readPackedUint64() []uint64 {
	if m.parsedPackedUint64 {
		return m.dataPackedUint64
	}
	wOffset := m.offsetPackedUint64
	var wType = m.wireTypePackedUint64
	
	var entry []uint64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadUint64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint64
			if wOffset > 0 {
				listEntry = m.buf.ReadUint64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedUint64 = entry
	m.parsedPackedUint64 = true
	return entry
}

func (m *TestPackedTypesReader) GetPackedSint32() []int32 {
	if m == nil {
		return nil
	}
	return m.readPackedSint32()
}

func (m *TestPackedTypesReader) readPackedSint32() []int32 {
	if m.parsedPackedSint32 {
		return m.dataPackedSint32
	}
	wOffset := m.offsetPackedSint32
	var wType = m.wireTypePackedSint32
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSInt32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadSInt32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedSint32 = entry
	m.parsedPackedSint32 = true
	return entry
}

func (m *TestPackedTypesReader) GetPackedSint64() []int64 {
	if m == nil {
		return nil
	}
	return m.readPackedSint64()
}

func (m *TestPackedTypesReader) readPackedSint64() []int64 {
	if m.parsedPackedSint64 {
		return m.dataPackedSint64
	}
	wOffset := m.offsetPackedSint64
	var wType = m.wireTypePackedSint64
	
	var entry []int64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSInt64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int64
			if wOffset > 0 {
				listEntry = m.buf.ReadSInt64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedSint64 = entry
	m.parsedPackedSint64 = true
	return entry
}

func (m *TestPackedTypesReader) GetPackedFixed32() []uint32 {
	if m == nil {
		return nil
	}
	return m.readPackedFixed32()
}

func (m *TestPackedTypesReader) readPackedFixed32() []uint32 {
	if m.parsedPackedFixed32 {
		return m.dataPackedFixed32
	}
	wOffset := m.offsetPackedFixed32
	var wType = m.wireTypePackedFixed32
	
	var entry []uint32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFixed32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint32
			if wOffset > 0 {
				listEntry = m.buf.ReadFixed32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedFixed32 = entry
	m.parsedPackedFixed32 = true
	return entry
}

func (m *TestPackedTypesReader) GetPackedFixed64() []uint64 {
	if m == nil {
		return nil
	}
	return m.readPackedFixed64()
}

func (m *TestPackedTypesReader) readPackedFixed64() []uint64 {
	if m.parsedPackedFixed64 {
		return m.dataPackedFixed64
	}
	wOffset := m.offsetPackedFixed64
	var wType = m.wireTypePackedFixed64
	
	var entry []uint64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFixed64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint64
			if wOffset > 0 {
				listEntry = m.buf.ReadFixed64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedFixed64 = entry
	m.parsedPackedFixed64 = true
	return entry
}

func (m *TestPackedTypesReader) GetPackedSfixed32() []int32 {
	if m == nil {
		return nil
	}
	return m.readPackedSfixed32()
}

func (m *TestPackedTypesReader) readPackedSfixed32() []int32 {
	if m.parsedPackedSfixed32 {
		return m.dataPackedSfixed32
	}
	wOffset := m.offsetPackedSfixed32
	var wType = m.wireTypePackedSfixed32
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSFixed32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadSFixed32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedSfixed32 = entry
	m.parsedPackedSfixed32 = true
	return entry
}

func (m *TestPackedTypesReader) GetPackedSfixed64() []int64 {
	if m == nil {
		return nil
	}
	return m.readPackedSfixed64()
}

func (m *TestPackedTypesReader) readPackedSfixed64() []int64 {
	if m.parsedPackedSfixed64 {
		return m.dataPackedSfixed64
	}
	wOffset := m.offsetPackedSfixed64
	var wType = m.wireTypePackedSfixed64
	
	var entry []int64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSFixed64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int64
			if wOffset > 0 {
				listEntry = m.buf.ReadSFixed64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedSfixed64 = entry
	m.parsedPackedSfixed64 = true
	return entry
}

func (m *TestPackedTypesReader) GetPackedFloat() []float32 {
	if m == nil {
		return nil
	}
	return m.readPackedFloat()
}

func (m *TestPackedTypesReader) readPackedFloat() []float32 {
	if m.parsedPackedFloat {
		return m.dataPackedFloat
	}
	wOffset := m.offsetPackedFloat
	var wType = m.wireTypePackedFloat
	
	var entry []float32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry float32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFloat32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry float32
			if wOffset > 0 {
				listEntry = m.buf.ReadFloat32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedFloat = entry
	m.parsedPackedFloat = true
	return entry
}

func (m *TestPackedTypesReader) GetPackedDouble() []float64 {
	if m == nil {
		return nil
	}
	return m.readPackedDouble()
}

func (m *TestPackedTypesReader) readPackedDouble() []float64 {
	if m.parsedPackedDouble {
		return m.dataPackedDouble
	}
	wOffset := m.offsetPackedDouble
	var wType = m.wireTypePackedDouble
	
	var entry []float64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry float64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFloat64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry float64
			if wOffset > 0 {
				listEntry = m.buf.ReadFloat64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedDouble = entry
	m.parsedPackedDouble = true
	return entry
}

func (m *TestPackedTypesReader) GetPackedBool() []bool {
	if m == nil {
		return nil
	}
	return m.readPackedBool()
}

func (m *TestPackedTypesReader) readPackedBool() []bool {
	if m.parsedPackedBool {
		return m.dataPackedBool
	}
	wOffset := m.offsetPackedBool
	var wType = m.wireTypePackedBool
	
	var entry []bool
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry bool
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadBool(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry bool
			if wOffset > 0 {
				listEntry = m.buf.ReadBool(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedBool = entry
	m.parsedPackedBool = true
	return entry
}

func (m *TestPackedTypesReader) GetPackedEnum() []ForeignEnum {
	if m == nil {
		return nil
	}
	return m.readPackedEnum()
}

func (m *TestPackedTypesReader) readPackedEnum() []ForeignEnum {
	if m.parsedPackedEnum {
		return m.dataPackedEnum
	}
	wOffset := m.offsetPackedEnum
	var wType = m.wireTypePackedEnum
	
	var entry []ForeignEnum
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry ForeignEnum
				var listEntrySize int
				if wOffset > 0 {
					rawEntry, size := m.buf.SizedReadInt32(wOffset)
					listEntry = ForeignEnum(rawEntry)
					listEntrySize = size
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry ForeignEnum
			if wOffset > 0 {
				rawEntry := m.buf.ReadInt32(wOffset)
				listEntry = ForeignEnum(rawEntry)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedEnum = entry
	m.parsedPackedEnum = true
	return entry
}

func (m *TestPackedTypesReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestPackedTypes_PackedInt32:
			m.offsetPackedInt32 = append(m.offsetPackedInt32, offset)
			m.wireTypePackedInt32 = append(m.wireTypePackedInt32, wire)
		case wireTestPackedTypes_PackedInt64:
			m.offsetPackedInt64 = append(m.offsetPackedInt64, offset)
			m.wireTypePackedInt64 = append(m.wireTypePackedInt64, wire)
		case wireTestPackedTypes_PackedUint32:
			m.offsetPackedUint32 = append(m.offsetPackedUint32, offset)
			m.wireTypePackedUint32 = append(m.wireTypePackedUint32, wire)
		case wireTestPackedTypes_PackedUint64:
			m.offsetPackedUint64 = append(m.offsetPackedUint64, offset)
			m.wireTypePackedUint64 = append(m.wireTypePackedUint64, wire)
		case wireTestPackedTypes_PackedSint32:
			m.offsetPackedSint32 = append(m.offsetPackedSint32, offset)
			m.wireTypePackedSint32 = append(m.wireTypePackedSint32, wire)
		case wireTestPackedTypes_PackedSint64:
			m.offsetPackedSint64 = append(m.offsetPackedSint64, offset)
			m.wireTypePackedSint64 = append(m.wireTypePackedSint64, wire)
		case wireTestPackedTypes_PackedFixed32:
			m.offsetPackedFixed32 = append(m.offsetPackedFixed32, offset)
			m.wireTypePackedFixed32 = append(m.wireTypePackedFixed32, wire)
		case wireTestPackedTypes_PackedFixed64:
			m.offsetPackedFixed64 = append(m.offsetPackedFixed64, offset)
			m.wireTypePackedFixed64 = append(m.wireTypePackedFixed64, wire)
		case wireTestPackedTypes_PackedSfixed32:
			m.offsetPackedSfixed32 = append(m.offsetPackedSfixed32, offset)
			m.wireTypePackedSfixed32 = append(m.wireTypePackedSfixed32, wire)
		case wireTestPackedTypes_PackedSfixed64:
			m.offsetPackedSfixed64 = append(m.offsetPackedSfixed64, offset)
			m.wireTypePackedSfixed64 = append(m.wireTypePackedSfixed64, wire)
		case wireTestPackedTypes_PackedFloat:
			m.offsetPackedFloat = append(m.offsetPackedFloat, offset)
			m.wireTypePackedFloat = append(m.wireTypePackedFloat, wire)
		case wireTestPackedTypes_PackedDouble:
			m.offsetPackedDouble = append(m.offsetPackedDouble, offset)
			m.wireTypePackedDouble = append(m.wireTypePackedDouble, wire)
		case wireTestPackedTypes_PackedBool:
			m.offsetPackedBool = append(m.offsetPackedBool, offset)
			m.wireTypePackedBool = append(m.wireTypePackedBool, wire)
		case wireTestPackedTypes_PackedEnum:
			m.offsetPackedEnum = append(m.offsetPackedEnum, offset)
			m.wireTypePackedEnum = append(m.wireTypePackedEnum, wire)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestPackedTypesReader) ToStruct() *TestPackedTypes {
	if m == nil {
		return nil
	}
	res := &TestPackedTypes{}
	res.PackedInt32 = m.GetPackedInt32()
	res.PackedInt64 = m.GetPackedInt64()
	res.PackedUint32 = m.GetPackedUint32()
	res.PackedUint64 = m.GetPackedUint64()
	res.PackedSint32 = m.GetPackedSint32()
	res.PackedSint64 = m.GetPackedSint64()
	res.PackedFixed32 = m.GetPackedFixed32()
	res.PackedFixed64 = m.GetPackedFixed64()
	res.PackedSfixed32 = m.GetPackedSfixed32()
	res.PackedSfixed64 = m.GetPackedSfixed64()
	res.PackedFloat = m.GetPackedFloat()
	res.PackedDouble = m.GetPackedDouble()
	res.PackedBool = m.GetPackedBool()
	res.PackedEnum = m.GetPackedEnum()

	return res
}

func (s *TestPackedTypesReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestPackedTypes struct {
	PackedInt32	[]int32	`json:"packed_int32,omitempty"`
	PackedInt64	[]int64	`json:"packed_int64,omitempty"`
	PackedUint32	[]uint32	`json:"packed_uint32,omitempty"`
	PackedUint64	[]uint64	`json:"packed_uint64,omitempty"`
	PackedSint32	[]int32	`json:"packed_sint32,omitempty"`
	PackedSint64	[]int64	`json:"packed_sint64,omitempty"`
	PackedFixed32	[]uint32	`json:"packed_fixed32,omitempty"`
	PackedFixed64	[]uint64	`json:"packed_fixed64,omitempty"`
	PackedSfixed32	[]int32	`json:"packed_sfixed32,omitempty"`
	PackedSfixed64	[]int64	`json:"packed_sfixed64,omitempty"`
	PackedFloat	[]float32	`json:"packed_float,omitempty"`
	PackedDouble	[]float64	`json:"packed_double,omitempty"`
	PackedBool	[]bool	`json:"packed_bool,omitempty"`
	PackedEnum	[]ForeignEnum	`json:"packed_enum,omitempty"`
}

func (s *TestPackedTypes) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestPackedTypes) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if len(s.PackedInt32) > 0 {
		if len(s.PackedInt32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedInt32 {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedTypes_PackedInt32, listBytesSize)
			for _, entry := range s.PackedInt32 {
				res.AppendInt32WithoutTag(entry)
			}
		} else if len(s.PackedInt32) == 1 {
			res.AppendInt32(wireTestPackedTypes_PackedInt32, s.PackedInt32[0])
		}
	}
	if len(s.PackedInt64) > 0 {
		if len(s.PackedInt64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedInt64 {
				var entrySize = 0
				entrySize = gremlin.SizeInt64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedTypes_PackedInt64, listBytesSize)
			for _, entry := range s.PackedInt64 {
				res.AppendInt64WithoutTag(entry)
			}
		} else if len(s.PackedInt64) == 1 {
			res.AppendInt64(wireTestPackedTypes_PackedInt64, s.PackedInt64[0])
		}
	}
	if len(s.PackedUint32) > 0 {
		if len(s.PackedUint32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedUint32 {
				var entrySize = 0
				entrySize = gremlin.SizeUint32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedTypes_PackedUint32, listBytesSize)
			for _, entry := range s.PackedUint32 {
				res.AppendUint32WithoutTag(entry)
			}
		} else if len(s.PackedUint32) == 1 {
			res.AppendUint32(wireTestPackedTypes_PackedUint32, s.PackedUint32[0])
		}
	}
	if len(s.PackedUint64) > 0 {
		if len(s.PackedUint64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedUint64 {
				var entrySize = 0
				entrySize = gremlin.SizeUint64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedTypes_PackedUint64, listBytesSize)
			for _, entry := range s.PackedUint64 {
				res.AppendUint64WithoutTag(entry)
			}
		} else if len(s.PackedUint64) == 1 {
			res.AppendUint64(wireTestPackedTypes_PackedUint64, s.PackedUint64[0])
		}
	}
	if len(s.PackedSint32) > 0 {
		if len(s.PackedSint32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedSint32 {
				var entrySize = 0
				entrySize = gremlin.SizeSInt32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedTypes_PackedSint32, listBytesSize)
			for _, entry := range s.PackedSint32 {
				res.AppendSInt32WithoutTag(entry)
			}
		} else if len(s.PackedSint32) == 1 {
			res.AppendSInt32(wireTestPackedTypes_PackedSint32, s.PackedSint32[0])
		}
	}
	if len(s.PackedSint64) > 0 {
		if len(s.PackedSint64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedSint64 {
				var entrySize = 0
				entrySize = gremlin.SizeSInt64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedTypes_PackedSint64, listBytesSize)
			for _, entry := range s.PackedSint64 {
				res.AppendSInt64WithoutTag(entry)
			}
		} else if len(s.PackedSint64) == 1 {
			res.AppendSInt64(wireTestPackedTypes_PackedSint64, s.PackedSint64[0])
		}
	}
	if len(s.PackedFixed32) > 0 {
		if len(s.PackedFixed32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedFixed32 {
				var entrySize = 0
				entrySize = gremlin.SizeFixed32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedTypes_PackedFixed32, listBytesSize)
			for _, entry := range s.PackedFixed32 {
				res.AppendFixed32WithoutTag(entry)
			}
		} else if len(s.PackedFixed32) == 1 {
			res.AppendFixed32(wireTestPackedTypes_PackedFixed32, s.PackedFixed32[0])
		}
	}
	if len(s.PackedFixed64) > 0 {
		if len(s.PackedFixed64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedFixed64 {
				var entrySize = 0
				entrySize = gremlin.SizeFixed64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedTypes_PackedFixed64, listBytesSize)
			for _, entry := range s.PackedFixed64 {
				res.AppendFixed64WithoutTag(entry)
			}
		} else if len(s.PackedFixed64) == 1 {
			res.AppendFixed64(wireTestPackedTypes_PackedFixed64, s.PackedFixed64[0])
		}
	}
	if len(s.PackedSfixed32) > 0 {
		if len(s.PackedSfixed32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedSfixed32 {
				var entrySize = 0
				entrySize = gremlin.SizeSFixed32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedTypes_PackedSfixed32, listBytesSize)
			for _, entry := range s.PackedSfixed32 {
				res.AppendSFixed32WithoutTag(entry)
			}
		} else if len(s.PackedSfixed32) == 1 {
			res.AppendSFixed32(wireTestPackedTypes_PackedSfixed32, s.PackedSfixed32[0])
		}
	}
	if len(s.PackedSfixed64) > 0 {
		if len(s.PackedSfixed64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedSfixed64 {
				var entrySize = 0
				entrySize = gremlin.SizeSFixed64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedTypes_PackedSfixed64, listBytesSize)
			for _, entry := range s.PackedSfixed64 {
				res.AppendSFixed64WithoutTag(entry)
			}
		} else if len(s.PackedSfixed64) == 1 {
			res.AppendSFixed64(wireTestPackedTypes_PackedSfixed64, s.PackedSfixed64[0])
		}
	}
	if len(s.PackedFloat) > 0 {
		if len(s.PackedFloat) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedFloat {
				var entrySize = 0
				entrySize = gremlin.SizeFloat32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedTypes_PackedFloat, listBytesSize)
			for _, entry := range s.PackedFloat {
				res.AppendFloat32WithoutTag(entry)
			}
		} else if len(s.PackedFloat) == 1 {
			res.AppendFloat32(wireTestPackedTypes_PackedFloat, s.PackedFloat[0])
		}
	}
	if len(s.PackedDouble) > 0 {
		if len(s.PackedDouble) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedDouble {
				var entrySize = 0
				entrySize = gremlin.SizeFloat64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedTypes_PackedDouble, listBytesSize)
			for _, entry := range s.PackedDouble {
				res.AppendFloat64WithoutTag(entry)
			}
		} else if len(s.PackedDouble) == 1 {
			res.AppendFloat64(wireTestPackedTypes_PackedDouble, s.PackedDouble[0])
		}
	}
	if len(s.PackedBool) > 0 {
		if len(s.PackedBool) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedBool {
				var entrySize = 0
				entrySize = gremlin.SizeBool(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedTypes_PackedBool, listBytesSize)
			for _, entry := range s.PackedBool {
				res.AppendBoolWithoutTag(entry)
			}
		} else if len(s.PackedBool) == 1 {
			res.AppendBool(wireTestPackedTypes_PackedBool, s.PackedBool[0])
		}
	}
	if len(s.PackedEnum) > 0 {
		if len(s.PackedEnum) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedEnum {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(int32(entry))
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedTypes_PackedEnum, listBytesSize)
			for _, entry := range s.PackedEnum {
				res.AppendInt32WithoutTag(int32(entry))
			}
		} else if len(s.PackedEnum) == 1 {
			res.AppendInt32(wireTestPackedTypes_PackedEnum, int32(s.PackedEnum[0]))
		}
	}
}

func (s *TestPackedTypes) Copy() *TestPackedTypes {
	if s == nil {
		return nil
	}
	res := &TestPackedTypes{}
	res.PackedInt32 = s.PackedInt32
	res.PackedInt64 = s.PackedInt64
	res.PackedUint32 = s.PackedUint32
	res.PackedUint64 = s.PackedUint64
	res.PackedSint32 = s.PackedSint32
	res.PackedSint64 = s.PackedSint64
	res.PackedFixed32 = s.PackedFixed32
	res.PackedFixed64 = s.PackedFixed64
	res.PackedSfixed32 = s.PackedSfixed32
	res.PackedSfixed64 = s.PackedSfixed64
	res.PackedFloat = s.PackedFloat
	res.PackedDouble = s.PackedDouble
	res.PackedBool = s.PackedBool
	res.PackedEnum = s.PackedEnum

	return res
}

func (s *TestPackedTypes) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if len(s.PackedInt32) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedInt32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedInt32 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedTypes_PackedInt32) + listBytesSize
		} else if len(s.PackedInt32) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedTypes_PackedInt32) + gremlin.SizeInt32(s.PackedInt32[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedInt64) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedInt64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedInt64 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedTypes_PackedInt64) + listBytesSize
		} else if len(s.PackedInt64) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedTypes_PackedInt64) + gremlin.SizeInt64(s.PackedInt64[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedUint32) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedUint32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedUint32 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeUint32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedTypes_PackedUint32) + listBytesSize
		} else if len(s.PackedUint32) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedTypes_PackedUint32) + gremlin.SizeUint32(s.PackedUint32[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedUint64) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedUint64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedUint64 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeUint64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedTypes_PackedUint64) + listBytesSize
		} else if len(s.PackedUint64) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedTypes_PackedUint64) + gremlin.SizeUint64(s.PackedUint64[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedSint32) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedSint32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedSint32 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSInt32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedTypes_PackedSint32) + listBytesSize
		} else if len(s.PackedSint32) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedTypes_PackedSint32) + gremlin.SizeSInt32(s.PackedSint32[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedSint64) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedSint64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedSint64 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSInt64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedTypes_PackedSint64) + listBytesSize
		} else if len(s.PackedSint64) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedTypes_PackedSint64) + gremlin.SizeSInt64(s.PackedSint64[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedFixed32) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedFixed32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedFixed32 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFixed32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedTypes_PackedFixed32) + listBytesSize
		} else if len(s.PackedFixed32) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedTypes_PackedFixed32) + gremlin.SizeFixed32(s.PackedFixed32[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedFixed64) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedFixed64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedFixed64 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFixed64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedTypes_PackedFixed64) + listBytesSize
		} else if len(s.PackedFixed64) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedTypes_PackedFixed64) + gremlin.SizeFixed64(s.PackedFixed64[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedSfixed32) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedSfixed32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedSfixed32 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSFixed32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedTypes_PackedSfixed32) + listBytesSize
		} else if len(s.PackedSfixed32) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedTypes_PackedSfixed32) + gremlin.SizeSFixed32(s.PackedSfixed32[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedSfixed64) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedSfixed64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedSfixed64 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSFixed64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedTypes_PackedSfixed64) + listBytesSize
		} else if len(s.PackedSfixed64) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedTypes_PackedSfixed64) + gremlin.SizeSFixed64(s.PackedSfixed64[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedFloat) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedFloat) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedFloat {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFloat32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedTypes_PackedFloat) + listBytesSize
		} else if len(s.PackedFloat) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedTypes_PackedFloat) + gremlin.SizeFloat32(s.PackedFloat[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedDouble) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedDouble) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedDouble {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFloat64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedTypes_PackedDouble) + listBytesSize
		} else if len(s.PackedDouble) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedTypes_PackedDouble) + gremlin.SizeFloat64(s.PackedDouble[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedBool) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedBool) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedBool {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeBool(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedTypes_PackedBool) + listBytesSize
		} else if len(s.PackedBool) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedTypes_PackedBool) + gremlin.SizeBool(s.PackedBool[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedEnum) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedEnum) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedEnum {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(int32(entry))
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedTypes_PackedEnum) + listBytesSize
		} else if len(s.PackedEnum) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedTypes_PackedEnum) + gremlin.SizeInt32(int32(s.PackedEnum[0]))
			entrySize += listEntrySize
		}
		size += entrySize
	}

	return size
}

const (
	wireTestUnpackedTypes_UnpackedInt32 gremlin.ProtoWireNumber = 90
	wireTestUnpackedTypes_UnpackedInt64 gremlin.ProtoWireNumber = 91
	wireTestUnpackedTypes_UnpackedUint32 gremlin.ProtoWireNumber = 92
	wireTestUnpackedTypes_UnpackedUint64 gremlin.ProtoWireNumber = 93
	wireTestUnpackedTypes_UnpackedSint32 gremlin.ProtoWireNumber = 94
	wireTestUnpackedTypes_UnpackedSint64 gremlin.ProtoWireNumber = 95
	wireTestUnpackedTypes_UnpackedFixed32 gremlin.ProtoWireNumber = 96
	wireTestUnpackedTypes_UnpackedFixed64 gremlin.ProtoWireNumber = 97
	wireTestUnpackedTypes_UnpackedSfixed32 gremlin.ProtoWireNumber = 98
	wireTestUnpackedTypes_UnpackedSfixed64 gremlin.ProtoWireNumber = 99
	wireTestUnpackedTypes_UnpackedFloat gremlin.ProtoWireNumber = 100
	wireTestUnpackedTypes_UnpackedDouble gremlin.ProtoWireNumber = 101
	wireTestUnpackedTypes_UnpackedBool gremlin.ProtoWireNumber = 102
	wireTestUnpackedTypes_UnpackedEnum gremlin.ProtoWireNumber = 103
)

type TestUnpackedTypesReader struct {
	buf *gremlin.Reader

	dataUnpackedInt32     []int32
	dataUnpackedInt64     []int64
	dataUnpackedUint32     []uint32
	dataUnpackedUint64     []uint64
	dataUnpackedSint32     []int32
	dataUnpackedSint64     []int64
	dataUnpackedFixed32     []uint32
	dataUnpackedFixed64     []uint64
	dataUnpackedSfixed32     []int32
	dataUnpackedSfixed64     []int64
	dataUnpackedFloat     []float32
	dataUnpackedDouble     []float64
	dataUnpackedBool     []bool
	dataUnpackedEnum     []ForeignEnum

	offsetUnpackedInt32   []int
	wireTypeUnpackedInt32 []gremlin.ProtoWireType
	offsetUnpackedInt64   []int
	wireTypeUnpackedInt64 []gremlin.ProtoWireType
	offsetUnpackedUint32   []int
	wireTypeUnpackedUint32 []gremlin.ProtoWireType
	offsetUnpackedUint64   []int
	wireTypeUnpackedUint64 []gremlin.ProtoWireType
	offsetUnpackedSint32   []int
	wireTypeUnpackedSint32 []gremlin.ProtoWireType
	offsetUnpackedSint64   []int
	wireTypeUnpackedSint64 []gremlin.ProtoWireType
	offsetUnpackedFixed32   []int
	wireTypeUnpackedFixed32 []gremlin.ProtoWireType
	offsetUnpackedFixed64   []int
	wireTypeUnpackedFixed64 []gremlin.ProtoWireType
	offsetUnpackedSfixed32   []int
	wireTypeUnpackedSfixed32 []gremlin.ProtoWireType
	offsetUnpackedSfixed64   []int
	wireTypeUnpackedSfixed64 []gremlin.ProtoWireType
	offsetUnpackedFloat   []int
	wireTypeUnpackedFloat []gremlin.ProtoWireType
	offsetUnpackedDouble   []int
	wireTypeUnpackedDouble []gremlin.ProtoWireType
	offsetUnpackedBool   []int
	wireTypeUnpackedBool []gremlin.ProtoWireType
	offsetUnpackedEnum   []int
	wireTypeUnpackedEnum []gremlin.ProtoWireType

	parsedUnpackedInt32   bool
	parsedUnpackedInt64   bool
	parsedUnpackedUint32   bool
	parsedUnpackedUint64   bool
	parsedUnpackedSint32   bool
	parsedUnpackedSint64   bool
	parsedUnpackedFixed32   bool
	parsedUnpackedFixed64   bool
	parsedUnpackedSfixed32   bool
	parsedUnpackedSfixed64   bool
	parsedUnpackedFloat   bool
	parsedUnpackedDouble   bool
	parsedUnpackedBool   bool
	parsedUnpackedEnum   bool
}

func NewTestUnpackedTypesReader() *TestUnpackedTypesReader {
	return &TestUnpackedTypesReader{}
}

func (m *TestUnpackedTypesReader) GetUnpackedInt32() []int32 {
	if m == nil {
		return nil
	}
	return m.readUnpackedInt32()
}

func (m *TestUnpackedTypesReader) readUnpackedInt32() []int32 {
	if m.parsedUnpackedInt32 {
		return m.dataUnpackedInt32
	}
	wOffset := m.offsetUnpackedInt32
	var wType = m.wireTypeUnpackedInt32
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadInt32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedInt32 = entry
	m.parsedUnpackedInt32 = true
	return entry
}

func (m *TestUnpackedTypesReader) GetUnpackedInt64() []int64 {
	if m == nil {
		return nil
	}
	return m.readUnpackedInt64()
}

func (m *TestUnpackedTypesReader) readUnpackedInt64() []int64 {
	if m.parsedUnpackedInt64 {
		return m.dataUnpackedInt64
	}
	wOffset := m.offsetUnpackedInt64
	var wType = m.wireTypeUnpackedInt64
	
	var entry []int64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadInt64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int64
			if wOffset > 0 {
				listEntry = m.buf.ReadInt64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedInt64 = entry
	m.parsedUnpackedInt64 = true
	return entry
}

func (m *TestUnpackedTypesReader) GetUnpackedUint32() []uint32 {
	if m == nil {
		return nil
	}
	return m.readUnpackedUint32()
}

func (m *TestUnpackedTypesReader) readUnpackedUint32() []uint32 {
	if m.parsedUnpackedUint32 {
		return m.dataUnpackedUint32
	}
	wOffset := m.offsetUnpackedUint32
	var wType = m.wireTypeUnpackedUint32
	
	var entry []uint32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadUint32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint32
			if wOffset > 0 {
				listEntry = m.buf.ReadUint32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedUint32 = entry
	m.parsedUnpackedUint32 = true
	return entry
}

func (m *TestUnpackedTypesReader) GetUnpackedUint64() []uint64 {
	if m == nil {
		return nil
	}
	return m.readUnpackedUint64()
}

func (m *TestUnpackedTypesReader) readUnpackedUint64() []uint64 {
	if m.parsedUnpackedUint64 {
		return m.dataUnpackedUint64
	}
	wOffset := m.offsetUnpackedUint64
	var wType = m.wireTypeUnpackedUint64
	
	var entry []uint64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadUint64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint64
			if wOffset > 0 {
				listEntry = m.buf.ReadUint64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedUint64 = entry
	m.parsedUnpackedUint64 = true
	return entry
}

func (m *TestUnpackedTypesReader) GetUnpackedSint32() []int32 {
	if m == nil {
		return nil
	}
	return m.readUnpackedSint32()
}

func (m *TestUnpackedTypesReader) readUnpackedSint32() []int32 {
	if m.parsedUnpackedSint32 {
		return m.dataUnpackedSint32
	}
	wOffset := m.offsetUnpackedSint32
	var wType = m.wireTypeUnpackedSint32
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSInt32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadSInt32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedSint32 = entry
	m.parsedUnpackedSint32 = true
	return entry
}

func (m *TestUnpackedTypesReader) GetUnpackedSint64() []int64 {
	if m == nil {
		return nil
	}
	return m.readUnpackedSint64()
}

func (m *TestUnpackedTypesReader) readUnpackedSint64() []int64 {
	if m.parsedUnpackedSint64 {
		return m.dataUnpackedSint64
	}
	wOffset := m.offsetUnpackedSint64
	var wType = m.wireTypeUnpackedSint64
	
	var entry []int64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSInt64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int64
			if wOffset > 0 {
				listEntry = m.buf.ReadSInt64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedSint64 = entry
	m.parsedUnpackedSint64 = true
	return entry
}

func (m *TestUnpackedTypesReader) GetUnpackedFixed32() []uint32 {
	if m == nil {
		return nil
	}
	return m.readUnpackedFixed32()
}

func (m *TestUnpackedTypesReader) readUnpackedFixed32() []uint32 {
	if m.parsedUnpackedFixed32 {
		return m.dataUnpackedFixed32
	}
	wOffset := m.offsetUnpackedFixed32
	var wType = m.wireTypeUnpackedFixed32
	
	var entry []uint32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFixed32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint32
			if wOffset > 0 {
				listEntry = m.buf.ReadFixed32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedFixed32 = entry
	m.parsedUnpackedFixed32 = true
	return entry
}

func (m *TestUnpackedTypesReader) GetUnpackedFixed64() []uint64 {
	if m == nil {
		return nil
	}
	return m.readUnpackedFixed64()
}

func (m *TestUnpackedTypesReader) readUnpackedFixed64() []uint64 {
	if m.parsedUnpackedFixed64 {
		return m.dataUnpackedFixed64
	}
	wOffset := m.offsetUnpackedFixed64
	var wType = m.wireTypeUnpackedFixed64
	
	var entry []uint64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFixed64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint64
			if wOffset > 0 {
				listEntry = m.buf.ReadFixed64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedFixed64 = entry
	m.parsedUnpackedFixed64 = true
	return entry
}

func (m *TestUnpackedTypesReader) GetUnpackedSfixed32() []int32 {
	if m == nil {
		return nil
	}
	return m.readUnpackedSfixed32()
}

func (m *TestUnpackedTypesReader) readUnpackedSfixed32() []int32 {
	if m.parsedUnpackedSfixed32 {
		return m.dataUnpackedSfixed32
	}
	wOffset := m.offsetUnpackedSfixed32
	var wType = m.wireTypeUnpackedSfixed32
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSFixed32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadSFixed32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedSfixed32 = entry
	m.parsedUnpackedSfixed32 = true
	return entry
}

func (m *TestUnpackedTypesReader) GetUnpackedSfixed64() []int64 {
	if m == nil {
		return nil
	}
	return m.readUnpackedSfixed64()
}

func (m *TestUnpackedTypesReader) readUnpackedSfixed64() []int64 {
	if m.parsedUnpackedSfixed64 {
		return m.dataUnpackedSfixed64
	}
	wOffset := m.offsetUnpackedSfixed64
	var wType = m.wireTypeUnpackedSfixed64
	
	var entry []int64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSFixed64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int64
			if wOffset > 0 {
				listEntry = m.buf.ReadSFixed64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedSfixed64 = entry
	m.parsedUnpackedSfixed64 = true
	return entry
}

func (m *TestUnpackedTypesReader) GetUnpackedFloat() []float32 {
	if m == nil {
		return nil
	}
	return m.readUnpackedFloat()
}

func (m *TestUnpackedTypesReader) readUnpackedFloat() []float32 {
	if m.parsedUnpackedFloat {
		return m.dataUnpackedFloat
	}
	wOffset := m.offsetUnpackedFloat
	var wType = m.wireTypeUnpackedFloat
	
	var entry []float32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry float32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFloat32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry float32
			if wOffset > 0 {
				listEntry = m.buf.ReadFloat32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedFloat = entry
	m.parsedUnpackedFloat = true
	return entry
}

func (m *TestUnpackedTypesReader) GetUnpackedDouble() []float64 {
	if m == nil {
		return nil
	}
	return m.readUnpackedDouble()
}

func (m *TestUnpackedTypesReader) readUnpackedDouble() []float64 {
	if m.parsedUnpackedDouble {
		return m.dataUnpackedDouble
	}
	wOffset := m.offsetUnpackedDouble
	var wType = m.wireTypeUnpackedDouble
	
	var entry []float64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry float64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFloat64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry float64
			if wOffset > 0 {
				listEntry = m.buf.ReadFloat64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedDouble = entry
	m.parsedUnpackedDouble = true
	return entry
}

func (m *TestUnpackedTypesReader) GetUnpackedBool() []bool {
	if m == nil {
		return nil
	}
	return m.readUnpackedBool()
}

func (m *TestUnpackedTypesReader) readUnpackedBool() []bool {
	if m.parsedUnpackedBool {
		return m.dataUnpackedBool
	}
	wOffset := m.offsetUnpackedBool
	var wType = m.wireTypeUnpackedBool
	
	var entry []bool
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry bool
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadBool(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry bool
			if wOffset > 0 {
				listEntry = m.buf.ReadBool(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedBool = entry
	m.parsedUnpackedBool = true
	return entry
}

func (m *TestUnpackedTypesReader) GetUnpackedEnum() []ForeignEnum {
	if m == nil {
		return nil
	}
	return m.readUnpackedEnum()
}

func (m *TestUnpackedTypesReader) readUnpackedEnum() []ForeignEnum {
	if m.parsedUnpackedEnum {
		return m.dataUnpackedEnum
	}
	wOffset := m.offsetUnpackedEnum
	var wType = m.wireTypeUnpackedEnum
	
	var entry []ForeignEnum
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry ForeignEnum
				var listEntrySize int
				if wOffset > 0 {
					rawEntry, size := m.buf.SizedReadInt32(wOffset)
					listEntry = ForeignEnum(rawEntry)
					listEntrySize = size
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry ForeignEnum
			if wOffset > 0 {
				rawEntry := m.buf.ReadInt32(wOffset)
				listEntry = ForeignEnum(rawEntry)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedEnum = entry
	m.parsedUnpackedEnum = true
	return entry
}

func (m *TestUnpackedTypesReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestUnpackedTypes_UnpackedInt32:
			m.offsetUnpackedInt32 = append(m.offsetUnpackedInt32, offset)
			m.wireTypeUnpackedInt32 = append(m.wireTypeUnpackedInt32, wire)
		case wireTestUnpackedTypes_UnpackedInt64:
			m.offsetUnpackedInt64 = append(m.offsetUnpackedInt64, offset)
			m.wireTypeUnpackedInt64 = append(m.wireTypeUnpackedInt64, wire)
		case wireTestUnpackedTypes_UnpackedUint32:
			m.offsetUnpackedUint32 = append(m.offsetUnpackedUint32, offset)
			m.wireTypeUnpackedUint32 = append(m.wireTypeUnpackedUint32, wire)
		case wireTestUnpackedTypes_UnpackedUint64:
			m.offsetUnpackedUint64 = append(m.offsetUnpackedUint64, offset)
			m.wireTypeUnpackedUint64 = append(m.wireTypeUnpackedUint64, wire)
		case wireTestUnpackedTypes_UnpackedSint32:
			m.offsetUnpackedSint32 = append(m.offsetUnpackedSint32, offset)
			m.wireTypeUnpackedSint32 = append(m.wireTypeUnpackedSint32, wire)
		case wireTestUnpackedTypes_UnpackedSint64:
			m.offsetUnpackedSint64 = append(m.offsetUnpackedSint64, offset)
			m.wireTypeUnpackedSint64 = append(m.wireTypeUnpackedSint64, wire)
		case wireTestUnpackedTypes_UnpackedFixed32:
			m.offsetUnpackedFixed32 = append(m.offsetUnpackedFixed32, offset)
			m.wireTypeUnpackedFixed32 = append(m.wireTypeUnpackedFixed32, wire)
		case wireTestUnpackedTypes_UnpackedFixed64:
			m.offsetUnpackedFixed64 = append(m.offsetUnpackedFixed64, offset)
			m.wireTypeUnpackedFixed64 = append(m.wireTypeUnpackedFixed64, wire)
		case wireTestUnpackedTypes_UnpackedSfixed32:
			m.offsetUnpackedSfixed32 = append(m.offsetUnpackedSfixed32, offset)
			m.wireTypeUnpackedSfixed32 = append(m.wireTypeUnpackedSfixed32, wire)
		case wireTestUnpackedTypes_UnpackedSfixed64:
			m.offsetUnpackedSfixed64 = append(m.offsetUnpackedSfixed64, offset)
			m.wireTypeUnpackedSfixed64 = append(m.wireTypeUnpackedSfixed64, wire)
		case wireTestUnpackedTypes_UnpackedFloat:
			m.offsetUnpackedFloat = append(m.offsetUnpackedFloat, offset)
			m.wireTypeUnpackedFloat = append(m.wireTypeUnpackedFloat, wire)
		case wireTestUnpackedTypes_UnpackedDouble:
			m.offsetUnpackedDouble = append(m.offsetUnpackedDouble, offset)
			m.wireTypeUnpackedDouble = append(m.wireTypeUnpackedDouble, wire)
		case wireTestUnpackedTypes_UnpackedBool:
			m.offsetUnpackedBool = append(m.offsetUnpackedBool, offset)
			m.wireTypeUnpackedBool = append(m.wireTypeUnpackedBool, wire)
		case wireTestUnpackedTypes_UnpackedEnum:
			m.offsetUnpackedEnum = append(m.offsetUnpackedEnum, offset)
			m.wireTypeUnpackedEnum = append(m.wireTypeUnpackedEnum, wire)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestUnpackedTypesReader) ToStruct() *TestUnpackedTypes {
	if m == nil {
		return nil
	}
	res := &TestUnpackedTypes{}
	res.UnpackedInt32 = m.GetUnpackedInt32()
	res.UnpackedInt64 = m.GetUnpackedInt64()
	res.UnpackedUint32 = m.GetUnpackedUint32()
	res.UnpackedUint64 = m.GetUnpackedUint64()
	res.UnpackedSint32 = m.GetUnpackedSint32()
	res.UnpackedSint64 = m.GetUnpackedSint64()
	res.UnpackedFixed32 = m.GetUnpackedFixed32()
	res.UnpackedFixed64 = m.GetUnpackedFixed64()
	res.UnpackedSfixed32 = m.GetUnpackedSfixed32()
	res.UnpackedSfixed64 = m.GetUnpackedSfixed64()
	res.UnpackedFloat = m.GetUnpackedFloat()
	res.UnpackedDouble = m.GetUnpackedDouble()
	res.UnpackedBool = m.GetUnpackedBool()
	res.UnpackedEnum = m.GetUnpackedEnum()

	return res
}

func (s *TestUnpackedTypesReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestUnpackedTypes struct {
	UnpackedInt32	[]int32	`json:"unpacked_int32,omitempty"`
	UnpackedInt64	[]int64	`json:"unpacked_int64,omitempty"`
	UnpackedUint32	[]uint32	`json:"unpacked_uint32,omitempty"`
	UnpackedUint64	[]uint64	`json:"unpacked_uint64,omitempty"`
	UnpackedSint32	[]int32	`json:"unpacked_sint32,omitempty"`
	UnpackedSint64	[]int64	`json:"unpacked_sint64,omitempty"`
	UnpackedFixed32	[]uint32	`json:"unpacked_fixed32,omitempty"`
	UnpackedFixed64	[]uint64	`json:"unpacked_fixed64,omitempty"`
	UnpackedSfixed32	[]int32	`json:"unpacked_sfixed32,omitempty"`
	UnpackedSfixed64	[]int64	`json:"unpacked_sfixed64,omitempty"`
	UnpackedFloat	[]float32	`json:"unpacked_float,omitempty"`
	UnpackedDouble	[]float64	`json:"unpacked_double,omitempty"`
	UnpackedBool	[]bool	`json:"unpacked_bool,omitempty"`
	UnpackedEnum	[]ForeignEnum	`json:"unpacked_enum,omitempty"`
}

func (s *TestUnpackedTypes) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestUnpackedTypes) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if len(s.UnpackedInt32) > 0 {
		if len(s.UnpackedInt32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedInt32 {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedTypes_UnpackedInt32, listBytesSize)
			for _, entry := range s.UnpackedInt32 {
				res.AppendInt32WithoutTag(entry)
			}
		} else if len(s.UnpackedInt32) == 1 {
			res.AppendInt32(wireTestUnpackedTypes_UnpackedInt32, s.UnpackedInt32[0])
		}
	}
	if len(s.UnpackedInt64) > 0 {
		if len(s.UnpackedInt64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedInt64 {
				var entrySize = 0
				entrySize = gremlin.SizeInt64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedTypes_UnpackedInt64, listBytesSize)
			for _, entry := range s.UnpackedInt64 {
				res.AppendInt64WithoutTag(entry)
			}
		} else if len(s.UnpackedInt64) == 1 {
			res.AppendInt64(wireTestUnpackedTypes_UnpackedInt64, s.UnpackedInt64[0])
		}
	}
	if len(s.UnpackedUint32) > 0 {
		if len(s.UnpackedUint32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedUint32 {
				var entrySize = 0
				entrySize = gremlin.SizeUint32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedTypes_UnpackedUint32, listBytesSize)
			for _, entry := range s.UnpackedUint32 {
				res.AppendUint32WithoutTag(entry)
			}
		} else if len(s.UnpackedUint32) == 1 {
			res.AppendUint32(wireTestUnpackedTypes_UnpackedUint32, s.UnpackedUint32[0])
		}
	}
	if len(s.UnpackedUint64) > 0 {
		if len(s.UnpackedUint64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedUint64 {
				var entrySize = 0
				entrySize = gremlin.SizeUint64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedTypes_UnpackedUint64, listBytesSize)
			for _, entry := range s.UnpackedUint64 {
				res.AppendUint64WithoutTag(entry)
			}
		} else if len(s.UnpackedUint64) == 1 {
			res.AppendUint64(wireTestUnpackedTypes_UnpackedUint64, s.UnpackedUint64[0])
		}
	}
	if len(s.UnpackedSint32) > 0 {
		if len(s.UnpackedSint32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedSint32 {
				var entrySize = 0
				entrySize = gremlin.SizeSInt32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedTypes_UnpackedSint32, listBytesSize)
			for _, entry := range s.UnpackedSint32 {
				res.AppendSInt32WithoutTag(entry)
			}
		} else if len(s.UnpackedSint32) == 1 {
			res.AppendSInt32(wireTestUnpackedTypes_UnpackedSint32, s.UnpackedSint32[0])
		}
	}
	if len(s.UnpackedSint64) > 0 {
		if len(s.UnpackedSint64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedSint64 {
				var entrySize = 0
				entrySize = gremlin.SizeSInt64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedTypes_UnpackedSint64, listBytesSize)
			for _, entry := range s.UnpackedSint64 {
				res.AppendSInt64WithoutTag(entry)
			}
		} else if len(s.UnpackedSint64) == 1 {
			res.AppendSInt64(wireTestUnpackedTypes_UnpackedSint64, s.UnpackedSint64[0])
		}
	}
	if len(s.UnpackedFixed32) > 0 {
		if len(s.UnpackedFixed32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedFixed32 {
				var entrySize = 0
				entrySize = gremlin.SizeFixed32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedTypes_UnpackedFixed32, listBytesSize)
			for _, entry := range s.UnpackedFixed32 {
				res.AppendFixed32WithoutTag(entry)
			}
		} else if len(s.UnpackedFixed32) == 1 {
			res.AppendFixed32(wireTestUnpackedTypes_UnpackedFixed32, s.UnpackedFixed32[0])
		}
	}
	if len(s.UnpackedFixed64) > 0 {
		if len(s.UnpackedFixed64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedFixed64 {
				var entrySize = 0
				entrySize = gremlin.SizeFixed64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedTypes_UnpackedFixed64, listBytesSize)
			for _, entry := range s.UnpackedFixed64 {
				res.AppendFixed64WithoutTag(entry)
			}
		} else if len(s.UnpackedFixed64) == 1 {
			res.AppendFixed64(wireTestUnpackedTypes_UnpackedFixed64, s.UnpackedFixed64[0])
		}
	}
	if len(s.UnpackedSfixed32) > 0 {
		if len(s.UnpackedSfixed32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedSfixed32 {
				var entrySize = 0
				entrySize = gremlin.SizeSFixed32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedTypes_UnpackedSfixed32, listBytesSize)
			for _, entry := range s.UnpackedSfixed32 {
				res.AppendSFixed32WithoutTag(entry)
			}
		} else if len(s.UnpackedSfixed32) == 1 {
			res.AppendSFixed32(wireTestUnpackedTypes_UnpackedSfixed32, s.UnpackedSfixed32[0])
		}
	}
	if len(s.UnpackedSfixed64) > 0 {
		if len(s.UnpackedSfixed64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedSfixed64 {
				var entrySize = 0
				entrySize = gremlin.SizeSFixed64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedTypes_UnpackedSfixed64, listBytesSize)
			for _, entry := range s.UnpackedSfixed64 {
				res.AppendSFixed64WithoutTag(entry)
			}
		} else if len(s.UnpackedSfixed64) == 1 {
			res.AppendSFixed64(wireTestUnpackedTypes_UnpackedSfixed64, s.UnpackedSfixed64[0])
		}
	}
	if len(s.UnpackedFloat) > 0 {
		if len(s.UnpackedFloat) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedFloat {
				var entrySize = 0
				entrySize = gremlin.SizeFloat32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedTypes_UnpackedFloat, listBytesSize)
			for _, entry := range s.UnpackedFloat {
				res.AppendFloat32WithoutTag(entry)
			}
		} else if len(s.UnpackedFloat) == 1 {
			res.AppendFloat32(wireTestUnpackedTypes_UnpackedFloat, s.UnpackedFloat[0])
		}
	}
	if len(s.UnpackedDouble) > 0 {
		if len(s.UnpackedDouble) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedDouble {
				var entrySize = 0
				entrySize = gremlin.SizeFloat64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedTypes_UnpackedDouble, listBytesSize)
			for _, entry := range s.UnpackedDouble {
				res.AppendFloat64WithoutTag(entry)
			}
		} else if len(s.UnpackedDouble) == 1 {
			res.AppendFloat64(wireTestUnpackedTypes_UnpackedDouble, s.UnpackedDouble[0])
		}
	}
	if len(s.UnpackedBool) > 0 {
		if len(s.UnpackedBool) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedBool {
				var entrySize = 0
				entrySize = gremlin.SizeBool(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedTypes_UnpackedBool, listBytesSize)
			for _, entry := range s.UnpackedBool {
				res.AppendBoolWithoutTag(entry)
			}
		} else if len(s.UnpackedBool) == 1 {
			res.AppendBool(wireTestUnpackedTypes_UnpackedBool, s.UnpackedBool[0])
		}
	}
	if len(s.UnpackedEnum) > 0 {
		if len(s.UnpackedEnum) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedEnum {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(int32(entry))
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedTypes_UnpackedEnum, listBytesSize)
			for _, entry := range s.UnpackedEnum {
				res.AppendInt32WithoutTag(int32(entry))
			}
		} else if len(s.UnpackedEnum) == 1 {
			res.AppendInt32(wireTestUnpackedTypes_UnpackedEnum, int32(s.UnpackedEnum[0]))
		}
	}
}

func (s *TestUnpackedTypes) Copy() *TestUnpackedTypes {
	if s == nil {
		return nil
	}
	res := &TestUnpackedTypes{}
	res.UnpackedInt32 = s.UnpackedInt32
	res.UnpackedInt64 = s.UnpackedInt64
	res.UnpackedUint32 = s.UnpackedUint32
	res.UnpackedUint64 = s.UnpackedUint64
	res.UnpackedSint32 = s.UnpackedSint32
	res.UnpackedSint64 = s.UnpackedSint64
	res.UnpackedFixed32 = s.UnpackedFixed32
	res.UnpackedFixed64 = s.UnpackedFixed64
	res.UnpackedSfixed32 = s.UnpackedSfixed32
	res.UnpackedSfixed64 = s.UnpackedSfixed64
	res.UnpackedFloat = s.UnpackedFloat
	res.UnpackedDouble = s.UnpackedDouble
	res.UnpackedBool = s.UnpackedBool
	res.UnpackedEnum = s.UnpackedEnum

	return res
}

func (s *TestUnpackedTypes) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if len(s.UnpackedInt32) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedInt32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedInt32 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedTypes_UnpackedInt32) + listBytesSize
		} else if len(s.UnpackedInt32) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedTypes_UnpackedInt32) + gremlin.SizeInt32(s.UnpackedInt32[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedInt64) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedInt64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedInt64 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedTypes_UnpackedInt64) + listBytesSize
		} else if len(s.UnpackedInt64) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedTypes_UnpackedInt64) + gremlin.SizeInt64(s.UnpackedInt64[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedUint32) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedUint32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedUint32 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeUint32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedTypes_UnpackedUint32) + listBytesSize
		} else if len(s.UnpackedUint32) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedTypes_UnpackedUint32) + gremlin.SizeUint32(s.UnpackedUint32[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedUint64) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedUint64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedUint64 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeUint64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedTypes_UnpackedUint64) + listBytesSize
		} else if len(s.UnpackedUint64) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedTypes_UnpackedUint64) + gremlin.SizeUint64(s.UnpackedUint64[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedSint32) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedSint32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedSint32 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSInt32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedTypes_UnpackedSint32) + listBytesSize
		} else if len(s.UnpackedSint32) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedTypes_UnpackedSint32) + gremlin.SizeSInt32(s.UnpackedSint32[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedSint64) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedSint64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedSint64 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSInt64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedTypes_UnpackedSint64) + listBytesSize
		} else if len(s.UnpackedSint64) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedTypes_UnpackedSint64) + gremlin.SizeSInt64(s.UnpackedSint64[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedFixed32) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedFixed32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedFixed32 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFixed32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedTypes_UnpackedFixed32) + listBytesSize
		} else if len(s.UnpackedFixed32) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedTypes_UnpackedFixed32) + gremlin.SizeFixed32(s.UnpackedFixed32[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedFixed64) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedFixed64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedFixed64 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFixed64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedTypes_UnpackedFixed64) + listBytesSize
		} else if len(s.UnpackedFixed64) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedTypes_UnpackedFixed64) + gremlin.SizeFixed64(s.UnpackedFixed64[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedSfixed32) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedSfixed32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedSfixed32 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSFixed32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedTypes_UnpackedSfixed32) + listBytesSize
		} else if len(s.UnpackedSfixed32) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedTypes_UnpackedSfixed32) + gremlin.SizeSFixed32(s.UnpackedSfixed32[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedSfixed64) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedSfixed64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedSfixed64 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSFixed64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedTypes_UnpackedSfixed64) + listBytesSize
		} else if len(s.UnpackedSfixed64) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedTypes_UnpackedSfixed64) + gremlin.SizeSFixed64(s.UnpackedSfixed64[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedFloat) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedFloat) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedFloat {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFloat32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedTypes_UnpackedFloat) + listBytesSize
		} else if len(s.UnpackedFloat) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedTypes_UnpackedFloat) + gremlin.SizeFloat32(s.UnpackedFloat[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedDouble) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedDouble) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedDouble {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFloat64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedTypes_UnpackedDouble) + listBytesSize
		} else if len(s.UnpackedDouble) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedTypes_UnpackedDouble) + gremlin.SizeFloat64(s.UnpackedDouble[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedBool) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedBool) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedBool {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeBool(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedTypes_UnpackedBool) + listBytesSize
		} else if len(s.UnpackedBool) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedTypes_UnpackedBool) + gremlin.SizeBool(s.UnpackedBool[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedEnum) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedEnum) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedEnum {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(int32(entry))
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedTypes_UnpackedEnum) + listBytesSize
		} else if len(s.UnpackedEnum) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedTypes_UnpackedEnum) + gremlin.SizeInt32(int32(s.UnpackedEnum[0]))
			entrySize += listEntrySize
		}
		size += entrySize
	}

	return size
}

const (
	wireTestPackedExtensions_PackedInt32Extension gremlin.ProtoWireNumber = 90
	wireTestPackedExtensions_PackedInt64Extension gremlin.ProtoWireNumber = 91
	wireTestPackedExtensions_PackedUint32Extension gremlin.ProtoWireNumber = 92
	wireTestPackedExtensions_PackedUint64Extension gremlin.ProtoWireNumber = 93
	wireTestPackedExtensions_PackedSint32Extension gremlin.ProtoWireNumber = 94
	wireTestPackedExtensions_PackedSint64Extension gremlin.ProtoWireNumber = 95
	wireTestPackedExtensions_PackedFixed32Extension gremlin.ProtoWireNumber = 96
	wireTestPackedExtensions_PackedFixed64Extension gremlin.ProtoWireNumber = 97
	wireTestPackedExtensions_PackedSfixed32Extension gremlin.ProtoWireNumber = 98
	wireTestPackedExtensions_PackedSfixed64Extension gremlin.ProtoWireNumber = 99
	wireTestPackedExtensions_PackedFloatExtension gremlin.ProtoWireNumber = 100
	wireTestPackedExtensions_PackedDoubleExtension gremlin.ProtoWireNumber = 101
	wireTestPackedExtensions_PackedBoolExtension gremlin.ProtoWireNumber = 102
	wireTestPackedExtensions_PackedEnumExtension gremlin.ProtoWireNumber = 103
)

type TestPackedExtensionsReader struct {
	buf *gremlin.Reader

	dataPackedInt32Extension     []int32
	dataPackedInt64Extension     []int64
	dataPackedUint32Extension     []uint32
	dataPackedUint64Extension     []uint64
	dataPackedSint32Extension     []int32
	dataPackedSint64Extension     []int64
	dataPackedFixed32Extension     []uint32
	dataPackedFixed64Extension     []uint64
	dataPackedSfixed32Extension     []int32
	dataPackedSfixed64Extension     []int64
	dataPackedFloatExtension     []float32
	dataPackedDoubleExtension     []float64
	dataPackedBoolExtension     []bool
	dataPackedEnumExtension     []ForeignEnum

	offsetPackedInt32Extension   []int
	wireTypePackedInt32Extension []gremlin.ProtoWireType
	offsetPackedInt64Extension   []int
	wireTypePackedInt64Extension []gremlin.ProtoWireType
	offsetPackedUint32Extension   []int
	wireTypePackedUint32Extension []gremlin.ProtoWireType
	offsetPackedUint64Extension   []int
	wireTypePackedUint64Extension []gremlin.ProtoWireType
	offsetPackedSint32Extension   []int
	wireTypePackedSint32Extension []gremlin.ProtoWireType
	offsetPackedSint64Extension   []int
	wireTypePackedSint64Extension []gremlin.ProtoWireType
	offsetPackedFixed32Extension   []int
	wireTypePackedFixed32Extension []gremlin.ProtoWireType
	offsetPackedFixed64Extension   []int
	wireTypePackedFixed64Extension []gremlin.ProtoWireType
	offsetPackedSfixed32Extension   []int
	wireTypePackedSfixed32Extension []gremlin.ProtoWireType
	offsetPackedSfixed64Extension   []int
	wireTypePackedSfixed64Extension []gremlin.ProtoWireType
	offsetPackedFloatExtension   []int
	wireTypePackedFloatExtension []gremlin.ProtoWireType
	offsetPackedDoubleExtension   []int
	wireTypePackedDoubleExtension []gremlin.ProtoWireType
	offsetPackedBoolExtension   []int
	wireTypePackedBoolExtension []gremlin.ProtoWireType
	offsetPackedEnumExtension   []int
	wireTypePackedEnumExtension []gremlin.ProtoWireType

	parsedPackedInt32Extension   bool
	parsedPackedInt64Extension   bool
	parsedPackedUint32Extension   bool
	parsedPackedUint64Extension   bool
	parsedPackedSint32Extension   bool
	parsedPackedSint64Extension   bool
	parsedPackedFixed32Extension   bool
	parsedPackedFixed64Extension   bool
	parsedPackedSfixed32Extension   bool
	parsedPackedSfixed64Extension   bool
	parsedPackedFloatExtension   bool
	parsedPackedDoubleExtension   bool
	parsedPackedBoolExtension   bool
	parsedPackedEnumExtension   bool
}

func NewTestPackedExtensionsReader() *TestPackedExtensionsReader {
	return &TestPackedExtensionsReader{}
}

func (m *TestPackedExtensionsReader) GetPackedInt32Extension() []int32 {
	if m == nil {
		return nil
	}
	return m.readPackedInt32Extension()
}

func (m *TestPackedExtensionsReader) readPackedInt32Extension() []int32 {
	if m.parsedPackedInt32Extension {
		return m.dataPackedInt32Extension
	}
	wOffset := m.offsetPackedInt32Extension
	var wType = m.wireTypePackedInt32Extension
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadInt32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedInt32Extension = entry
	m.parsedPackedInt32Extension = true
	return entry
}

func (m *TestPackedExtensionsReader) GetPackedInt64Extension() []int64 {
	if m == nil {
		return nil
	}
	return m.readPackedInt64Extension()
}

func (m *TestPackedExtensionsReader) readPackedInt64Extension() []int64 {
	if m.parsedPackedInt64Extension {
		return m.dataPackedInt64Extension
	}
	wOffset := m.offsetPackedInt64Extension
	var wType = m.wireTypePackedInt64Extension
	
	var entry []int64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadInt64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int64
			if wOffset > 0 {
				listEntry = m.buf.ReadInt64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedInt64Extension = entry
	m.parsedPackedInt64Extension = true
	return entry
}

func (m *TestPackedExtensionsReader) GetPackedUint32Extension() []uint32 {
	if m == nil {
		return nil
	}
	return m.readPackedUint32Extension()
}

func (m *TestPackedExtensionsReader) readPackedUint32Extension() []uint32 {
	if m.parsedPackedUint32Extension {
		return m.dataPackedUint32Extension
	}
	wOffset := m.offsetPackedUint32Extension
	var wType = m.wireTypePackedUint32Extension
	
	var entry []uint32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadUint32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint32
			if wOffset > 0 {
				listEntry = m.buf.ReadUint32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedUint32Extension = entry
	m.parsedPackedUint32Extension = true
	return entry
}

func (m *TestPackedExtensionsReader) GetPackedUint64Extension() []uint64 {
	if m == nil {
		return nil
	}
	return m.readPackedUint64Extension()
}

func (m *TestPackedExtensionsReader) readPackedUint64Extension() []uint64 {
	if m.parsedPackedUint64Extension {
		return m.dataPackedUint64Extension
	}
	wOffset := m.offsetPackedUint64Extension
	var wType = m.wireTypePackedUint64Extension
	
	var entry []uint64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadUint64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint64
			if wOffset > 0 {
				listEntry = m.buf.ReadUint64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedUint64Extension = entry
	m.parsedPackedUint64Extension = true
	return entry
}

func (m *TestPackedExtensionsReader) GetPackedSint32Extension() []int32 {
	if m == nil {
		return nil
	}
	return m.readPackedSint32Extension()
}

func (m *TestPackedExtensionsReader) readPackedSint32Extension() []int32 {
	if m.parsedPackedSint32Extension {
		return m.dataPackedSint32Extension
	}
	wOffset := m.offsetPackedSint32Extension
	var wType = m.wireTypePackedSint32Extension
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSInt32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadSInt32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedSint32Extension = entry
	m.parsedPackedSint32Extension = true
	return entry
}

func (m *TestPackedExtensionsReader) GetPackedSint64Extension() []int64 {
	if m == nil {
		return nil
	}
	return m.readPackedSint64Extension()
}

func (m *TestPackedExtensionsReader) readPackedSint64Extension() []int64 {
	if m.parsedPackedSint64Extension {
		return m.dataPackedSint64Extension
	}
	wOffset := m.offsetPackedSint64Extension
	var wType = m.wireTypePackedSint64Extension
	
	var entry []int64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSInt64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int64
			if wOffset > 0 {
				listEntry = m.buf.ReadSInt64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedSint64Extension = entry
	m.parsedPackedSint64Extension = true
	return entry
}

func (m *TestPackedExtensionsReader) GetPackedFixed32Extension() []uint32 {
	if m == nil {
		return nil
	}
	return m.readPackedFixed32Extension()
}

func (m *TestPackedExtensionsReader) readPackedFixed32Extension() []uint32 {
	if m.parsedPackedFixed32Extension {
		return m.dataPackedFixed32Extension
	}
	wOffset := m.offsetPackedFixed32Extension
	var wType = m.wireTypePackedFixed32Extension
	
	var entry []uint32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFixed32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint32
			if wOffset > 0 {
				listEntry = m.buf.ReadFixed32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedFixed32Extension = entry
	m.parsedPackedFixed32Extension = true
	return entry
}

func (m *TestPackedExtensionsReader) GetPackedFixed64Extension() []uint64 {
	if m == nil {
		return nil
	}
	return m.readPackedFixed64Extension()
}

func (m *TestPackedExtensionsReader) readPackedFixed64Extension() []uint64 {
	if m.parsedPackedFixed64Extension {
		return m.dataPackedFixed64Extension
	}
	wOffset := m.offsetPackedFixed64Extension
	var wType = m.wireTypePackedFixed64Extension
	
	var entry []uint64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFixed64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint64
			if wOffset > 0 {
				listEntry = m.buf.ReadFixed64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedFixed64Extension = entry
	m.parsedPackedFixed64Extension = true
	return entry
}

func (m *TestPackedExtensionsReader) GetPackedSfixed32Extension() []int32 {
	if m == nil {
		return nil
	}
	return m.readPackedSfixed32Extension()
}

func (m *TestPackedExtensionsReader) readPackedSfixed32Extension() []int32 {
	if m.parsedPackedSfixed32Extension {
		return m.dataPackedSfixed32Extension
	}
	wOffset := m.offsetPackedSfixed32Extension
	var wType = m.wireTypePackedSfixed32Extension
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSFixed32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadSFixed32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedSfixed32Extension = entry
	m.parsedPackedSfixed32Extension = true
	return entry
}

func (m *TestPackedExtensionsReader) GetPackedSfixed64Extension() []int64 {
	if m == nil {
		return nil
	}
	return m.readPackedSfixed64Extension()
}

func (m *TestPackedExtensionsReader) readPackedSfixed64Extension() []int64 {
	if m.parsedPackedSfixed64Extension {
		return m.dataPackedSfixed64Extension
	}
	wOffset := m.offsetPackedSfixed64Extension
	var wType = m.wireTypePackedSfixed64Extension
	
	var entry []int64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSFixed64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int64
			if wOffset > 0 {
				listEntry = m.buf.ReadSFixed64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedSfixed64Extension = entry
	m.parsedPackedSfixed64Extension = true
	return entry
}

func (m *TestPackedExtensionsReader) GetPackedFloatExtension() []float32 {
	if m == nil {
		return nil
	}
	return m.readPackedFloatExtension()
}

func (m *TestPackedExtensionsReader) readPackedFloatExtension() []float32 {
	if m.parsedPackedFloatExtension {
		return m.dataPackedFloatExtension
	}
	wOffset := m.offsetPackedFloatExtension
	var wType = m.wireTypePackedFloatExtension
	
	var entry []float32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry float32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFloat32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry float32
			if wOffset > 0 {
				listEntry = m.buf.ReadFloat32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedFloatExtension = entry
	m.parsedPackedFloatExtension = true
	return entry
}

func (m *TestPackedExtensionsReader) GetPackedDoubleExtension() []float64 {
	if m == nil {
		return nil
	}
	return m.readPackedDoubleExtension()
}

func (m *TestPackedExtensionsReader) readPackedDoubleExtension() []float64 {
	if m.parsedPackedDoubleExtension {
		return m.dataPackedDoubleExtension
	}
	wOffset := m.offsetPackedDoubleExtension
	var wType = m.wireTypePackedDoubleExtension
	
	var entry []float64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry float64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFloat64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry float64
			if wOffset > 0 {
				listEntry = m.buf.ReadFloat64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedDoubleExtension = entry
	m.parsedPackedDoubleExtension = true
	return entry
}

func (m *TestPackedExtensionsReader) GetPackedBoolExtension() []bool {
	if m == nil {
		return nil
	}
	return m.readPackedBoolExtension()
}

func (m *TestPackedExtensionsReader) readPackedBoolExtension() []bool {
	if m.parsedPackedBoolExtension {
		return m.dataPackedBoolExtension
	}
	wOffset := m.offsetPackedBoolExtension
	var wType = m.wireTypePackedBoolExtension
	
	var entry []bool
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry bool
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadBool(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry bool
			if wOffset > 0 {
				listEntry = m.buf.ReadBool(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedBoolExtension = entry
	m.parsedPackedBoolExtension = true
	return entry
}

func (m *TestPackedExtensionsReader) GetPackedEnumExtension() []ForeignEnum {
	if m == nil {
		return nil
	}
	return m.readPackedEnumExtension()
}

func (m *TestPackedExtensionsReader) readPackedEnumExtension() []ForeignEnum {
	if m.parsedPackedEnumExtension {
		return m.dataPackedEnumExtension
	}
	wOffset := m.offsetPackedEnumExtension
	var wType = m.wireTypePackedEnumExtension
	
	var entry []ForeignEnum
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry ForeignEnum
				var listEntrySize int
				if wOffset > 0 {
					rawEntry, size := m.buf.SizedReadInt32(wOffset)
					listEntry = ForeignEnum(rawEntry)
					listEntrySize = size
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry ForeignEnum
			if wOffset > 0 {
				rawEntry := m.buf.ReadInt32(wOffset)
				listEntry = ForeignEnum(rawEntry)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedEnumExtension = entry
	m.parsedPackedEnumExtension = true
	return entry
}

func (m *TestPackedExtensionsReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestPackedExtensions_PackedInt32Extension:
			m.offsetPackedInt32Extension = append(m.offsetPackedInt32Extension, offset)
			m.wireTypePackedInt32Extension = append(m.wireTypePackedInt32Extension, wire)
		case wireTestPackedExtensions_PackedInt64Extension:
			m.offsetPackedInt64Extension = append(m.offsetPackedInt64Extension, offset)
			m.wireTypePackedInt64Extension = append(m.wireTypePackedInt64Extension, wire)
		case wireTestPackedExtensions_PackedUint32Extension:
			m.offsetPackedUint32Extension = append(m.offsetPackedUint32Extension, offset)
			m.wireTypePackedUint32Extension = append(m.wireTypePackedUint32Extension, wire)
		case wireTestPackedExtensions_PackedUint64Extension:
			m.offsetPackedUint64Extension = append(m.offsetPackedUint64Extension, offset)
			m.wireTypePackedUint64Extension = append(m.wireTypePackedUint64Extension, wire)
		case wireTestPackedExtensions_PackedSint32Extension:
			m.offsetPackedSint32Extension = append(m.offsetPackedSint32Extension, offset)
			m.wireTypePackedSint32Extension = append(m.wireTypePackedSint32Extension, wire)
		case wireTestPackedExtensions_PackedSint64Extension:
			m.offsetPackedSint64Extension = append(m.offsetPackedSint64Extension, offset)
			m.wireTypePackedSint64Extension = append(m.wireTypePackedSint64Extension, wire)
		case wireTestPackedExtensions_PackedFixed32Extension:
			m.offsetPackedFixed32Extension = append(m.offsetPackedFixed32Extension, offset)
			m.wireTypePackedFixed32Extension = append(m.wireTypePackedFixed32Extension, wire)
		case wireTestPackedExtensions_PackedFixed64Extension:
			m.offsetPackedFixed64Extension = append(m.offsetPackedFixed64Extension, offset)
			m.wireTypePackedFixed64Extension = append(m.wireTypePackedFixed64Extension, wire)
		case wireTestPackedExtensions_PackedSfixed32Extension:
			m.offsetPackedSfixed32Extension = append(m.offsetPackedSfixed32Extension, offset)
			m.wireTypePackedSfixed32Extension = append(m.wireTypePackedSfixed32Extension, wire)
		case wireTestPackedExtensions_PackedSfixed64Extension:
			m.offsetPackedSfixed64Extension = append(m.offsetPackedSfixed64Extension, offset)
			m.wireTypePackedSfixed64Extension = append(m.wireTypePackedSfixed64Extension, wire)
		case wireTestPackedExtensions_PackedFloatExtension:
			m.offsetPackedFloatExtension = append(m.offsetPackedFloatExtension, offset)
			m.wireTypePackedFloatExtension = append(m.wireTypePackedFloatExtension, wire)
		case wireTestPackedExtensions_PackedDoubleExtension:
			m.offsetPackedDoubleExtension = append(m.offsetPackedDoubleExtension, offset)
			m.wireTypePackedDoubleExtension = append(m.wireTypePackedDoubleExtension, wire)
		case wireTestPackedExtensions_PackedBoolExtension:
			m.offsetPackedBoolExtension = append(m.offsetPackedBoolExtension, offset)
			m.wireTypePackedBoolExtension = append(m.wireTypePackedBoolExtension, wire)
		case wireTestPackedExtensions_PackedEnumExtension:
			m.offsetPackedEnumExtension = append(m.offsetPackedEnumExtension, offset)
			m.wireTypePackedEnumExtension = append(m.wireTypePackedEnumExtension, wire)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestPackedExtensionsReader) ToStruct() *TestPackedExtensions {
	if m == nil {
		return nil
	}
	res := &TestPackedExtensions{}
	res.PackedInt32Extension = m.GetPackedInt32Extension()
	res.PackedInt64Extension = m.GetPackedInt64Extension()
	res.PackedUint32Extension = m.GetPackedUint32Extension()
	res.PackedUint64Extension = m.GetPackedUint64Extension()
	res.PackedSint32Extension = m.GetPackedSint32Extension()
	res.PackedSint64Extension = m.GetPackedSint64Extension()
	res.PackedFixed32Extension = m.GetPackedFixed32Extension()
	res.PackedFixed64Extension = m.GetPackedFixed64Extension()
	res.PackedSfixed32Extension = m.GetPackedSfixed32Extension()
	res.PackedSfixed64Extension = m.GetPackedSfixed64Extension()
	res.PackedFloatExtension = m.GetPackedFloatExtension()
	res.PackedDoubleExtension = m.GetPackedDoubleExtension()
	res.PackedBoolExtension = m.GetPackedBoolExtension()
	res.PackedEnumExtension = m.GetPackedEnumExtension()

	return res
}

func (s *TestPackedExtensionsReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestPackedExtensions struct {
	PackedInt32Extension	[]int32	`json:"packed_int32_extension,omitempty"`
	PackedInt64Extension	[]int64	`json:"packed_int64_extension,omitempty"`
	PackedUint32Extension	[]uint32	`json:"packed_uint32_extension,omitempty"`
	PackedUint64Extension	[]uint64	`json:"packed_uint64_extension,omitempty"`
	PackedSint32Extension	[]int32	`json:"packed_sint32_extension,omitempty"`
	PackedSint64Extension	[]int64	`json:"packed_sint64_extension,omitempty"`
	PackedFixed32Extension	[]uint32	`json:"packed_fixed32_extension,omitempty"`
	PackedFixed64Extension	[]uint64	`json:"packed_fixed64_extension,omitempty"`
	PackedSfixed32Extension	[]int32	`json:"packed_sfixed32_extension,omitempty"`
	PackedSfixed64Extension	[]int64	`json:"packed_sfixed64_extension,omitempty"`
	PackedFloatExtension	[]float32	`json:"packed_float_extension,omitempty"`
	PackedDoubleExtension	[]float64	`json:"packed_double_extension,omitempty"`
	PackedBoolExtension	[]bool	`json:"packed_bool_extension,omitempty"`
	PackedEnumExtension	[]ForeignEnum	`json:"packed_enum_extension,omitempty"`
}

func (s *TestPackedExtensions) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestPackedExtensions) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if len(s.PackedInt32Extension) > 0 {
		if len(s.PackedInt32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedInt32Extension {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedExtensions_PackedInt32Extension, listBytesSize)
			for _, entry := range s.PackedInt32Extension {
				res.AppendInt32WithoutTag(entry)
			}
		} else if len(s.PackedInt32Extension) == 1 {
			res.AppendInt32(wireTestPackedExtensions_PackedInt32Extension, s.PackedInt32Extension[0])
		}
	}
	if len(s.PackedInt64Extension) > 0 {
		if len(s.PackedInt64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedInt64Extension {
				var entrySize = 0
				entrySize = gremlin.SizeInt64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedExtensions_PackedInt64Extension, listBytesSize)
			for _, entry := range s.PackedInt64Extension {
				res.AppendInt64WithoutTag(entry)
			}
		} else if len(s.PackedInt64Extension) == 1 {
			res.AppendInt64(wireTestPackedExtensions_PackedInt64Extension, s.PackedInt64Extension[0])
		}
	}
	if len(s.PackedUint32Extension) > 0 {
		if len(s.PackedUint32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedUint32Extension {
				var entrySize = 0
				entrySize = gremlin.SizeUint32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedExtensions_PackedUint32Extension, listBytesSize)
			for _, entry := range s.PackedUint32Extension {
				res.AppendUint32WithoutTag(entry)
			}
		} else if len(s.PackedUint32Extension) == 1 {
			res.AppendUint32(wireTestPackedExtensions_PackedUint32Extension, s.PackedUint32Extension[0])
		}
	}
	if len(s.PackedUint64Extension) > 0 {
		if len(s.PackedUint64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedUint64Extension {
				var entrySize = 0
				entrySize = gremlin.SizeUint64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedExtensions_PackedUint64Extension, listBytesSize)
			for _, entry := range s.PackedUint64Extension {
				res.AppendUint64WithoutTag(entry)
			}
		} else if len(s.PackedUint64Extension) == 1 {
			res.AppendUint64(wireTestPackedExtensions_PackedUint64Extension, s.PackedUint64Extension[0])
		}
	}
	if len(s.PackedSint32Extension) > 0 {
		if len(s.PackedSint32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedSint32Extension {
				var entrySize = 0
				entrySize = gremlin.SizeSInt32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedExtensions_PackedSint32Extension, listBytesSize)
			for _, entry := range s.PackedSint32Extension {
				res.AppendSInt32WithoutTag(entry)
			}
		} else if len(s.PackedSint32Extension) == 1 {
			res.AppendSInt32(wireTestPackedExtensions_PackedSint32Extension, s.PackedSint32Extension[0])
		}
	}
	if len(s.PackedSint64Extension) > 0 {
		if len(s.PackedSint64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedSint64Extension {
				var entrySize = 0
				entrySize = gremlin.SizeSInt64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedExtensions_PackedSint64Extension, listBytesSize)
			for _, entry := range s.PackedSint64Extension {
				res.AppendSInt64WithoutTag(entry)
			}
		} else if len(s.PackedSint64Extension) == 1 {
			res.AppendSInt64(wireTestPackedExtensions_PackedSint64Extension, s.PackedSint64Extension[0])
		}
	}
	if len(s.PackedFixed32Extension) > 0 {
		if len(s.PackedFixed32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedFixed32Extension {
				var entrySize = 0
				entrySize = gremlin.SizeFixed32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedExtensions_PackedFixed32Extension, listBytesSize)
			for _, entry := range s.PackedFixed32Extension {
				res.AppendFixed32WithoutTag(entry)
			}
		} else if len(s.PackedFixed32Extension) == 1 {
			res.AppendFixed32(wireTestPackedExtensions_PackedFixed32Extension, s.PackedFixed32Extension[0])
		}
	}
	if len(s.PackedFixed64Extension) > 0 {
		if len(s.PackedFixed64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedFixed64Extension {
				var entrySize = 0
				entrySize = gremlin.SizeFixed64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedExtensions_PackedFixed64Extension, listBytesSize)
			for _, entry := range s.PackedFixed64Extension {
				res.AppendFixed64WithoutTag(entry)
			}
		} else if len(s.PackedFixed64Extension) == 1 {
			res.AppendFixed64(wireTestPackedExtensions_PackedFixed64Extension, s.PackedFixed64Extension[0])
		}
	}
	if len(s.PackedSfixed32Extension) > 0 {
		if len(s.PackedSfixed32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedSfixed32Extension {
				var entrySize = 0
				entrySize = gremlin.SizeSFixed32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedExtensions_PackedSfixed32Extension, listBytesSize)
			for _, entry := range s.PackedSfixed32Extension {
				res.AppendSFixed32WithoutTag(entry)
			}
		} else if len(s.PackedSfixed32Extension) == 1 {
			res.AppendSFixed32(wireTestPackedExtensions_PackedSfixed32Extension, s.PackedSfixed32Extension[0])
		}
	}
	if len(s.PackedSfixed64Extension) > 0 {
		if len(s.PackedSfixed64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedSfixed64Extension {
				var entrySize = 0
				entrySize = gremlin.SizeSFixed64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedExtensions_PackedSfixed64Extension, listBytesSize)
			for _, entry := range s.PackedSfixed64Extension {
				res.AppendSFixed64WithoutTag(entry)
			}
		} else if len(s.PackedSfixed64Extension) == 1 {
			res.AppendSFixed64(wireTestPackedExtensions_PackedSfixed64Extension, s.PackedSfixed64Extension[0])
		}
	}
	if len(s.PackedFloatExtension) > 0 {
		if len(s.PackedFloatExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedFloatExtension {
				var entrySize = 0
				entrySize = gremlin.SizeFloat32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedExtensions_PackedFloatExtension, listBytesSize)
			for _, entry := range s.PackedFloatExtension {
				res.AppendFloat32WithoutTag(entry)
			}
		} else if len(s.PackedFloatExtension) == 1 {
			res.AppendFloat32(wireTestPackedExtensions_PackedFloatExtension, s.PackedFloatExtension[0])
		}
	}
	if len(s.PackedDoubleExtension) > 0 {
		if len(s.PackedDoubleExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedDoubleExtension {
				var entrySize = 0
				entrySize = gremlin.SizeFloat64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedExtensions_PackedDoubleExtension, listBytesSize)
			for _, entry := range s.PackedDoubleExtension {
				res.AppendFloat64WithoutTag(entry)
			}
		} else if len(s.PackedDoubleExtension) == 1 {
			res.AppendFloat64(wireTestPackedExtensions_PackedDoubleExtension, s.PackedDoubleExtension[0])
		}
	}
	if len(s.PackedBoolExtension) > 0 {
		if len(s.PackedBoolExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedBoolExtension {
				var entrySize = 0
				entrySize = gremlin.SizeBool(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedExtensions_PackedBoolExtension, listBytesSize)
			for _, entry := range s.PackedBoolExtension {
				res.AppendBoolWithoutTag(entry)
			}
		} else if len(s.PackedBoolExtension) == 1 {
			res.AppendBool(wireTestPackedExtensions_PackedBoolExtension, s.PackedBoolExtension[0])
		}
	}
	if len(s.PackedEnumExtension) > 0 {
		if len(s.PackedEnumExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedEnumExtension {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(int32(entry))
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestPackedExtensions_PackedEnumExtension, listBytesSize)
			for _, entry := range s.PackedEnumExtension {
				res.AppendInt32WithoutTag(int32(entry))
			}
		} else if len(s.PackedEnumExtension) == 1 {
			res.AppendInt32(wireTestPackedExtensions_PackedEnumExtension, int32(s.PackedEnumExtension[0]))
		}
	}
}

func (s *TestPackedExtensions) Copy() *TestPackedExtensions {
	if s == nil {
		return nil
	}
	res := &TestPackedExtensions{}
	res.PackedInt32Extension = s.PackedInt32Extension
	res.PackedInt64Extension = s.PackedInt64Extension
	res.PackedUint32Extension = s.PackedUint32Extension
	res.PackedUint64Extension = s.PackedUint64Extension
	res.PackedSint32Extension = s.PackedSint32Extension
	res.PackedSint64Extension = s.PackedSint64Extension
	res.PackedFixed32Extension = s.PackedFixed32Extension
	res.PackedFixed64Extension = s.PackedFixed64Extension
	res.PackedSfixed32Extension = s.PackedSfixed32Extension
	res.PackedSfixed64Extension = s.PackedSfixed64Extension
	res.PackedFloatExtension = s.PackedFloatExtension
	res.PackedDoubleExtension = s.PackedDoubleExtension
	res.PackedBoolExtension = s.PackedBoolExtension
	res.PackedEnumExtension = s.PackedEnumExtension

	return res
}

func (s *TestPackedExtensions) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if len(s.PackedInt32Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedInt32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedInt32Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedExtensions_PackedInt32Extension) + listBytesSize
		} else if len(s.PackedInt32Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedExtensions_PackedInt32Extension) + gremlin.SizeInt32(s.PackedInt32Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedInt64Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedInt64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedInt64Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedExtensions_PackedInt64Extension) + listBytesSize
		} else if len(s.PackedInt64Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedExtensions_PackedInt64Extension) + gremlin.SizeInt64(s.PackedInt64Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedUint32Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedUint32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedUint32Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeUint32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedExtensions_PackedUint32Extension) + listBytesSize
		} else if len(s.PackedUint32Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedExtensions_PackedUint32Extension) + gremlin.SizeUint32(s.PackedUint32Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedUint64Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedUint64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedUint64Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeUint64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedExtensions_PackedUint64Extension) + listBytesSize
		} else if len(s.PackedUint64Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedExtensions_PackedUint64Extension) + gremlin.SizeUint64(s.PackedUint64Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedSint32Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedSint32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedSint32Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSInt32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedExtensions_PackedSint32Extension) + listBytesSize
		} else if len(s.PackedSint32Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedExtensions_PackedSint32Extension) + gremlin.SizeSInt32(s.PackedSint32Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedSint64Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedSint64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedSint64Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSInt64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedExtensions_PackedSint64Extension) + listBytesSize
		} else if len(s.PackedSint64Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedExtensions_PackedSint64Extension) + gremlin.SizeSInt64(s.PackedSint64Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedFixed32Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedFixed32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedFixed32Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFixed32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedExtensions_PackedFixed32Extension) + listBytesSize
		} else if len(s.PackedFixed32Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedExtensions_PackedFixed32Extension) + gremlin.SizeFixed32(s.PackedFixed32Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedFixed64Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedFixed64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedFixed64Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFixed64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedExtensions_PackedFixed64Extension) + listBytesSize
		} else if len(s.PackedFixed64Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedExtensions_PackedFixed64Extension) + gremlin.SizeFixed64(s.PackedFixed64Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedSfixed32Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedSfixed32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedSfixed32Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSFixed32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedExtensions_PackedSfixed32Extension) + listBytesSize
		} else if len(s.PackedSfixed32Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedExtensions_PackedSfixed32Extension) + gremlin.SizeSFixed32(s.PackedSfixed32Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedSfixed64Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedSfixed64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedSfixed64Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSFixed64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedExtensions_PackedSfixed64Extension) + listBytesSize
		} else if len(s.PackedSfixed64Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedExtensions_PackedSfixed64Extension) + gremlin.SizeSFixed64(s.PackedSfixed64Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedFloatExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedFloatExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedFloatExtension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFloat32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedExtensions_PackedFloatExtension) + listBytesSize
		} else if len(s.PackedFloatExtension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedExtensions_PackedFloatExtension) + gremlin.SizeFloat32(s.PackedFloatExtension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedDoubleExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedDoubleExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedDoubleExtension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFloat64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedExtensions_PackedDoubleExtension) + listBytesSize
		} else if len(s.PackedDoubleExtension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedExtensions_PackedDoubleExtension) + gremlin.SizeFloat64(s.PackedDoubleExtension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedBoolExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedBoolExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedBoolExtension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeBool(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedExtensions_PackedBoolExtension) + listBytesSize
		} else if len(s.PackedBoolExtension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedExtensions_PackedBoolExtension) + gremlin.SizeBool(s.PackedBoolExtension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedEnumExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedEnumExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedEnumExtension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(int32(entry))
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestPackedExtensions_PackedEnumExtension) + listBytesSize
		} else if len(s.PackedEnumExtension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestPackedExtensions_PackedEnumExtension) + gremlin.SizeInt32(int32(s.PackedEnumExtension[0]))
			entrySize += listEntrySize
		}
		size += entrySize
	}

	return size
}

const (
	wireTestUnpackedExtensions_UnpackedInt32Extension gremlin.ProtoWireNumber = 90
	wireTestUnpackedExtensions_UnpackedInt64Extension gremlin.ProtoWireNumber = 91
	wireTestUnpackedExtensions_UnpackedUint32Extension gremlin.ProtoWireNumber = 92
	wireTestUnpackedExtensions_UnpackedUint64Extension gremlin.ProtoWireNumber = 93
	wireTestUnpackedExtensions_UnpackedSint32Extension gremlin.ProtoWireNumber = 94
	wireTestUnpackedExtensions_UnpackedSint64Extension gremlin.ProtoWireNumber = 95
	wireTestUnpackedExtensions_UnpackedFixed32Extension gremlin.ProtoWireNumber = 96
	wireTestUnpackedExtensions_UnpackedFixed64Extension gremlin.ProtoWireNumber = 97
	wireTestUnpackedExtensions_UnpackedSfixed32Extension gremlin.ProtoWireNumber = 98
	wireTestUnpackedExtensions_UnpackedSfixed64Extension gremlin.ProtoWireNumber = 99
	wireTestUnpackedExtensions_UnpackedFloatExtension gremlin.ProtoWireNumber = 100
	wireTestUnpackedExtensions_UnpackedDoubleExtension gremlin.ProtoWireNumber = 101
	wireTestUnpackedExtensions_UnpackedBoolExtension gremlin.ProtoWireNumber = 102
	wireTestUnpackedExtensions_UnpackedEnumExtension gremlin.ProtoWireNumber = 103
)

type TestUnpackedExtensionsReader struct {
	buf *gremlin.Reader

	dataUnpackedInt32Extension     []int32
	dataUnpackedInt64Extension     []int64
	dataUnpackedUint32Extension     []uint32
	dataUnpackedUint64Extension     []uint64
	dataUnpackedSint32Extension     []int32
	dataUnpackedSint64Extension     []int64
	dataUnpackedFixed32Extension     []uint32
	dataUnpackedFixed64Extension     []uint64
	dataUnpackedSfixed32Extension     []int32
	dataUnpackedSfixed64Extension     []int64
	dataUnpackedFloatExtension     []float32
	dataUnpackedDoubleExtension     []float64
	dataUnpackedBoolExtension     []bool
	dataUnpackedEnumExtension     []ForeignEnum

	offsetUnpackedInt32Extension   []int
	wireTypeUnpackedInt32Extension []gremlin.ProtoWireType
	offsetUnpackedInt64Extension   []int
	wireTypeUnpackedInt64Extension []gremlin.ProtoWireType
	offsetUnpackedUint32Extension   []int
	wireTypeUnpackedUint32Extension []gremlin.ProtoWireType
	offsetUnpackedUint64Extension   []int
	wireTypeUnpackedUint64Extension []gremlin.ProtoWireType
	offsetUnpackedSint32Extension   []int
	wireTypeUnpackedSint32Extension []gremlin.ProtoWireType
	offsetUnpackedSint64Extension   []int
	wireTypeUnpackedSint64Extension []gremlin.ProtoWireType
	offsetUnpackedFixed32Extension   []int
	wireTypeUnpackedFixed32Extension []gremlin.ProtoWireType
	offsetUnpackedFixed64Extension   []int
	wireTypeUnpackedFixed64Extension []gremlin.ProtoWireType
	offsetUnpackedSfixed32Extension   []int
	wireTypeUnpackedSfixed32Extension []gremlin.ProtoWireType
	offsetUnpackedSfixed64Extension   []int
	wireTypeUnpackedSfixed64Extension []gremlin.ProtoWireType
	offsetUnpackedFloatExtension   []int
	wireTypeUnpackedFloatExtension []gremlin.ProtoWireType
	offsetUnpackedDoubleExtension   []int
	wireTypeUnpackedDoubleExtension []gremlin.ProtoWireType
	offsetUnpackedBoolExtension   []int
	wireTypeUnpackedBoolExtension []gremlin.ProtoWireType
	offsetUnpackedEnumExtension   []int
	wireTypeUnpackedEnumExtension []gremlin.ProtoWireType

	parsedUnpackedInt32Extension   bool
	parsedUnpackedInt64Extension   bool
	parsedUnpackedUint32Extension   bool
	parsedUnpackedUint64Extension   bool
	parsedUnpackedSint32Extension   bool
	parsedUnpackedSint64Extension   bool
	parsedUnpackedFixed32Extension   bool
	parsedUnpackedFixed64Extension   bool
	parsedUnpackedSfixed32Extension   bool
	parsedUnpackedSfixed64Extension   bool
	parsedUnpackedFloatExtension   bool
	parsedUnpackedDoubleExtension   bool
	parsedUnpackedBoolExtension   bool
	parsedUnpackedEnumExtension   bool
}

func NewTestUnpackedExtensionsReader() *TestUnpackedExtensionsReader {
	return &TestUnpackedExtensionsReader{}
}

func (m *TestUnpackedExtensionsReader) GetUnpackedInt32Extension() []int32 {
	if m == nil {
		return nil
	}
	return m.readUnpackedInt32Extension()
}

func (m *TestUnpackedExtensionsReader) readUnpackedInt32Extension() []int32 {
	if m.parsedUnpackedInt32Extension {
		return m.dataUnpackedInt32Extension
	}
	wOffset := m.offsetUnpackedInt32Extension
	var wType = m.wireTypeUnpackedInt32Extension
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadInt32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedInt32Extension = entry
	m.parsedUnpackedInt32Extension = true
	return entry
}

func (m *TestUnpackedExtensionsReader) GetUnpackedInt64Extension() []int64 {
	if m == nil {
		return nil
	}
	return m.readUnpackedInt64Extension()
}

func (m *TestUnpackedExtensionsReader) readUnpackedInt64Extension() []int64 {
	if m.parsedUnpackedInt64Extension {
		return m.dataUnpackedInt64Extension
	}
	wOffset := m.offsetUnpackedInt64Extension
	var wType = m.wireTypeUnpackedInt64Extension
	
	var entry []int64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadInt64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int64
			if wOffset > 0 {
				listEntry = m.buf.ReadInt64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedInt64Extension = entry
	m.parsedUnpackedInt64Extension = true
	return entry
}

func (m *TestUnpackedExtensionsReader) GetUnpackedUint32Extension() []uint32 {
	if m == nil {
		return nil
	}
	return m.readUnpackedUint32Extension()
}

func (m *TestUnpackedExtensionsReader) readUnpackedUint32Extension() []uint32 {
	if m.parsedUnpackedUint32Extension {
		return m.dataUnpackedUint32Extension
	}
	wOffset := m.offsetUnpackedUint32Extension
	var wType = m.wireTypeUnpackedUint32Extension
	
	var entry []uint32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadUint32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint32
			if wOffset > 0 {
				listEntry = m.buf.ReadUint32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedUint32Extension = entry
	m.parsedUnpackedUint32Extension = true
	return entry
}

func (m *TestUnpackedExtensionsReader) GetUnpackedUint64Extension() []uint64 {
	if m == nil {
		return nil
	}
	return m.readUnpackedUint64Extension()
}

func (m *TestUnpackedExtensionsReader) readUnpackedUint64Extension() []uint64 {
	if m.parsedUnpackedUint64Extension {
		return m.dataUnpackedUint64Extension
	}
	wOffset := m.offsetUnpackedUint64Extension
	var wType = m.wireTypeUnpackedUint64Extension
	
	var entry []uint64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadUint64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint64
			if wOffset > 0 {
				listEntry = m.buf.ReadUint64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedUint64Extension = entry
	m.parsedUnpackedUint64Extension = true
	return entry
}

func (m *TestUnpackedExtensionsReader) GetUnpackedSint32Extension() []int32 {
	if m == nil {
		return nil
	}
	return m.readUnpackedSint32Extension()
}

func (m *TestUnpackedExtensionsReader) readUnpackedSint32Extension() []int32 {
	if m.parsedUnpackedSint32Extension {
		return m.dataUnpackedSint32Extension
	}
	wOffset := m.offsetUnpackedSint32Extension
	var wType = m.wireTypeUnpackedSint32Extension
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSInt32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadSInt32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedSint32Extension = entry
	m.parsedUnpackedSint32Extension = true
	return entry
}

func (m *TestUnpackedExtensionsReader) GetUnpackedSint64Extension() []int64 {
	if m == nil {
		return nil
	}
	return m.readUnpackedSint64Extension()
}

func (m *TestUnpackedExtensionsReader) readUnpackedSint64Extension() []int64 {
	if m.parsedUnpackedSint64Extension {
		return m.dataUnpackedSint64Extension
	}
	wOffset := m.offsetUnpackedSint64Extension
	var wType = m.wireTypeUnpackedSint64Extension
	
	var entry []int64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSInt64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int64
			if wOffset > 0 {
				listEntry = m.buf.ReadSInt64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedSint64Extension = entry
	m.parsedUnpackedSint64Extension = true
	return entry
}

func (m *TestUnpackedExtensionsReader) GetUnpackedFixed32Extension() []uint32 {
	if m == nil {
		return nil
	}
	return m.readUnpackedFixed32Extension()
}

func (m *TestUnpackedExtensionsReader) readUnpackedFixed32Extension() []uint32 {
	if m.parsedUnpackedFixed32Extension {
		return m.dataUnpackedFixed32Extension
	}
	wOffset := m.offsetUnpackedFixed32Extension
	var wType = m.wireTypeUnpackedFixed32Extension
	
	var entry []uint32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFixed32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint32
			if wOffset > 0 {
				listEntry = m.buf.ReadFixed32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedFixed32Extension = entry
	m.parsedUnpackedFixed32Extension = true
	return entry
}

func (m *TestUnpackedExtensionsReader) GetUnpackedFixed64Extension() []uint64 {
	if m == nil {
		return nil
	}
	return m.readUnpackedFixed64Extension()
}

func (m *TestUnpackedExtensionsReader) readUnpackedFixed64Extension() []uint64 {
	if m.parsedUnpackedFixed64Extension {
		return m.dataUnpackedFixed64Extension
	}
	wOffset := m.offsetUnpackedFixed64Extension
	var wType = m.wireTypeUnpackedFixed64Extension
	
	var entry []uint64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFixed64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint64
			if wOffset > 0 {
				listEntry = m.buf.ReadFixed64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedFixed64Extension = entry
	m.parsedUnpackedFixed64Extension = true
	return entry
}

func (m *TestUnpackedExtensionsReader) GetUnpackedSfixed32Extension() []int32 {
	if m == nil {
		return nil
	}
	return m.readUnpackedSfixed32Extension()
}

func (m *TestUnpackedExtensionsReader) readUnpackedSfixed32Extension() []int32 {
	if m.parsedUnpackedSfixed32Extension {
		return m.dataUnpackedSfixed32Extension
	}
	wOffset := m.offsetUnpackedSfixed32Extension
	var wType = m.wireTypeUnpackedSfixed32Extension
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSFixed32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadSFixed32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedSfixed32Extension = entry
	m.parsedUnpackedSfixed32Extension = true
	return entry
}

func (m *TestUnpackedExtensionsReader) GetUnpackedSfixed64Extension() []int64 {
	if m == nil {
		return nil
	}
	return m.readUnpackedSfixed64Extension()
}

func (m *TestUnpackedExtensionsReader) readUnpackedSfixed64Extension() []int64 {
	if m.parsedUnpackedSfixed64Extension {
		return m.dataUnpackedSfixed64Extension
	}
	wOffset := m.offsetUnpackedSfixed64Extension
	var wType = m.wireTypeUnpackedSfixed64Extension
	
	var entry []int64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSFixed64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int64
			if wOffset > 0 {
				listEntry = m.buf.ReadSFixed64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedSfixed64Extension = entry
	m.parsedUnpackedSfixed64Extension = true
	return entry
}

func (m *TestUnpackedExtensionsReader) GetUnpackedFloatExtension() []float32 {
	if m == nil {
		return nil
	}
	return m.readUnpackedFloatExtension()
}

func (m *TestUnpackedExtensionsReader) readUnpackedFloatExtension() []float32 {
	if m.parsedUnpackedFloatExtension {
		return m.dataUnpackedFloatExtension
	}
	wOffset := m.offsetUnpackedFloatExtension
	var wType = m.wireTypeUnpackedFloatExtension
	
	var entry []float32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry float32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFloat32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry float32
			if wOffset > 0 {
				listEntry = m.buf.ReadFloat32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedFloatExtension = entry
	m.parsedUnpackedFloatExtension = true
	return entry
}

func (m *TestUnpackedExtensionsReader) GetUnpackedDoubleExtension() []float64 {
	if m == nil {
		return nil
	}
	return m.readUnpackedDoubleExtension()
}

func (m *TestUnpackedExtensionsReader) readUnpackedDoubleExtension() []float64 {
	if m.parsedUnpackedDoubleExtension {
		return m.dataUnpackedDoubleExtension
	}
	wOffset := m.offsetUnpackedDoubleExtension
	var wType = m.wireTypeUnpackedDoubleExtension
	
	var entry []float64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry float64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFloat64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry float64
			if wOffset > 0 {
				listEntry = m.buf.ReadFloat64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedDoubleExtension = entry
	m.parsedUnpackedDoubleExtension = true
	return entry
}

func (m *TestUnpackedExtensionsReader) GetUnpackedBoolExtension() []bool {
	if m == nil {
		return nil
	}
	return m.readUnpackedBoolExtension()
}

func (m *TestUnpackedExtensionsReader) readUnpackedBoolExtension() []bool {
	if m.parsedUnpackedBoolExtension {
		return m.dataUnpackedBoolExtension
	}
	wOffset := m.offsetUnpackedBoolExtension
	var wType = m.wireTypeUnpackedBoolExtension
	
	var entry []bool
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry bool
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadBool(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry bool
			if wOffset > 0 {
				listEntry = m.buf.ReadBool(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedBoolExtension = entry
	m.parsedUnpackedBoolExtension = true
	return entry
}

func (m *TestUnpackedExtensionsReader) GetUnpackedEnumExtension() []ForeignEnum {
	if m == nil {
		return nil
	}
	return m.readUnpackedEnumExtension()
}

func (m *TestUnpackedExtensionsReader) readUnpackedEnumExtension() []ForeignEnum {
	if m.parsedUnpackedEnumExtension {
		return m.dataUnpackedEnumExtension
	}
	wOffset := m.offsetUnpackedEnumExtension
	var wType = m.wireTypeUnpackedEnumExtension
	
	var entry []ForeignEnum
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry ForeignEnum
				var listEntrySize int
				if wOffset > 0 {
					rawEntry, size := m.buf.SizedReadInt32(wOffset)
					listEntry = ForeignEnum(rawEntry)
					listEntrySize = size
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry ForeignEnum
			if wOffset > 0 {
				rawEntry := m.buf.ReadInt32(wOffset)
				listEntry = ForeignEnum(rawEntry)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataUnpackedEnumExtension = entry
	m.parsedUnpackedEnumExtension = true
	return entry
}

func (m *TestUnpackedExtensionsReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestUnpackedExtensions_UnpackedInt32Extension:
			m.offsetUnpackedInt32Extension = append(m.offsetUnpackedInt32Extension, offset)
			m.wireTypeUnpackedInt32Extension = append(m.wireTypeUnpackedInt32Extension, wire)
		case wireTestUnpackedExtensions_UnpackedInt64Extension:
			m.offsetUnpackedInt64Extension = append(m.offsetUnpackedInt64Extension, offset)
			m.wireTypeUnpackedInt64Extension = append(m.wireTypeUnpackedInt64Extension, wire)
		case wireTestUnpackedExtensions_UnpackedUint32Extension:
			m.offsetUnpackedUint32Extension = append(m.offsetUnpackedUint32Extension, offset)
			m.wireTypeUnpackedUint32Extension = append(m.wireTypeUnpackedUint32Extension, wire)
		case wireTestUnpackedExtensions_UnpackedUint64Extension:
			m.offsetUnpackedUint64Extension = append(m.offsetUnpackedUint64Extension, offset)
			m.wireTypeUnpackedUint64Extension = append(m.wireTypeUnpackedUint64Extension, wire)
		case wireTestUnpackedExtensions_UnpackedSint32Extension:
			m.offsetUnpackedSint32Extension = append(m.offsetUnpackedSint32Extension, offset)
			m.wireTypeUnpackedSint32Extension = append(m.wireTypeUnpackedSint32Extension, wire)
		case wireTestUnpackedExtensions_UnpackedSint64Extension:
			m.offsetUnpackedSint64Extension = append(m.offsetUnpackedSint64Extension, offset)
			m.wireTypeUnpackedSint64Extension = append(m.wireTypeUnpackedSint64Extension, wire)
		case wireTestUnpackedExtensions_UnpackedFixed32Extension:
			m.offsetUnpackedFixed32Extension = append(m.offsetUnpackedFixed32Extension, offset)
			m.wireTypeUnpackedFixed32Extension = append(m.wireTypeUnpackedFixed32Extension, wire)
		case wireTestUnpackedExtensions_UnpackedFixed64Extension:
			m.offsetUnpackedFixed64Extension = append(m.offsetUnpackedFixed64Extension, offset)
			m.wireTypeUnpackedFixed64Extension = append(m.wireTypeUnpackedFixed64Extension, wire)
		case wireTestUnpackedExtensions_UnpackedSfixed32Extension:
			m.offsetUnpackedSfixed32Extension = append(m.offsetUnpackedSfixed32Extension, offset)
			m.wireTypeUnpackedSfixed32Extension = append(m.wireTypeUnpackedSfixed32Extension, wire)
		case wireTestUnpackedExtensions_UnpackedSfixed64Extension:
			m.offsetUnpackedSfixed64Extension = append(m.offsetUnpackedSfixed64Extension, offset)
			m.wireTypeUnpackedSfixed64Extension = append(m.wireTypeUnpackedSfixed64Extension, wire)
		case wireTestUnpackedExtensions_UnpackedFloatExtension:
			m.offsetUnpackedFloatExtension = append(m.offsetUnpackedFloatExtension, offset)
			m.wireTypeUnpackedFloatExtension = append(m.wireTypeUnpackedFloatExtension, wire)
		case wireTestUnpackedExtensions_UnpackedDoubleExtension:
			m.offsetUnpackedDoubleExtension = append(m.offsetUnpackedDoubleExtension, offset)
			m.wireTypeUnpackedDoubleExtension = append(m.wireTypeUnpackedDoubleExtension, wire)
		case wireTestUnpackedExtensions_UnpackedBoolExtension:
			m.offsetUnpackedBoolExtension = append(m.offsetUnpackedBoolExtension, offset)
			m.wireTypeUnpackedBoolExtension = append(m.wireTypeUnpackedBoolExtension, wire)
		case wireTestUnpackedExtensions_UnpackedEnumExtension:
			m.offsetUnpackedEnumExtension = append(m.offsetUnpackedEnumExtension, offset)
			m.wireTypeUnpackedEnumExtension = append(m.wireTypeUnpackedEnumExtension, wire)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestUnpackedExtensionsReader) ToStruct() *TestUnpackedExtensions {
	if m == nil {
		return nil
	}
	res := &TestUnpackedExtensions{}
	res.UnpackedInt32Extension = m.GetUnpackedInt32Extension()
	res.UnpackedInt64Extension = m.GetUnpackedInt64Extension()
	res.UnpackedUint32Extension = m.GetUnpackedUint32Extension()
	res.UnpackedUint64Extension = m.GetUnpackedUint64Extension()
	res.UnpackedSint32Extension = m.GetUnpackedSint32Extension()
	res.UnpackedSint64Extension = m.GetUnpackedSint64Extension()
	res.UnpackedFixed32Extension = m.GetUnpackedFixed32Extension()
	res.UnpackedFixed64Extension = m.GetUnpackedFixed64Extension()
	res.UnpackedSfixed32Extension = m.GetUnpackedSfixed32Extension()
	res.UnpackedSfixed64Extension = m.GetUnpackedSfixed64Extension()
	res.UnpackedFloatExtension = m.GetUnpackedFloatExtension()
	res.UnpackedDoubleExtension = m.GetUnpackedDoubleExtension()
	res.UnpackedBoolExtension = m.GetUnpackedBoolExtension()
	res.UnpackedEnumExtension = m.GetUnpackedEnumExtension()

	return res
}

func (s *TestUnpackedExtensionsReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestUnpackedExtensions struct {
	UnpackedInt32Extension	[]int32	`json:"unpacked_int32_extension,omitempty"`
	UnpackedInt64Extension	[]int64	`json:"unpacked_int64_extension,omitempty"`
	UnpackedUint32Extension	[]uint32	`json:"unpacked_uint32_extension,omitempty"`
	UnpackedUint64Extension	[]uint64	`json:"unpacked_uint64_extension,omitempty"`
	UnpackedSint32Extension	[]int32	`json:"unpacked_sint32_extension,omitempty"`
	UnpackedSint64Extension	[]int64	`json:"unpacked_sint64_extension,omitempty"`
	UnpackedFixed32Extension	[]uint32	`json:"unpacked_fixed32_extension,omitempty"`
	UnpackedFixed64Extension	[]uint64	`json:"unpacked_fixed64_extension,omitempty"`
	UnpackedSfixed32Extension	[]int32	`json:"unpacked_sfixed32_extension,omitempty"`
	UnpackedSfixed64Extension	[]int64	`json:"unpacked_sfixed64_extension,omitempty"`
	UnpackedFloatExtension	[]float32	`json:"unpacked_float_extension,omitempty"`
	UnpackedDoubleExtension	[]float64	`json:"unpacked_double_extension,omitempty"`
	UnpackedBoolExtension	[]bool	`json:"unpacked_bool_extension,omitempty"`
	UnpackedEnumExtension	[]ForeignEnum	`json:"unpacked_enum_extension,omitempty"`
}

func (s *TestUnpackedExtensions) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestUnpackedExtensions) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if len(s.UnpackedInt32Extension) > 0 {
		if len(s.UnpackedInt32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedInt32Extension {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedExtensions_UnpackedInt32Extension, listBytesSize)
			for _, entry := range s.UnpackedInt32Extension {
				res.AppendInt32WithoutTag(entry)
			}
		} else if len(s.UnpackedInt32Extension) == 1 {
			res.AppendInt32(wireTestUnpackedExtensions_UnpackedInt32Extension, s.UnpackedInt32Extension[0])
		}
	}
	if len(s.UnpackedInt64Extension) > 0 {
		if len(s.UnpackedInt64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedInt64Extension {
				var entrySize = 0
				entrySize = gremlin.SizeInt64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedExtensions_UnpackedInt64Extension, listBytesSize)
			for _, entry := range s.UnpackedInt64Extension {
				res.AppendInt64WithoutTag(entry)
			}
		} else if len(s.UnpackedInt64Extension) == 1 {
			res.AppendInt64(wireTestUnpackedExtensions_UnpackedInt64Extension, s.UnpackedInt64Extension[0])
		}
	}
	if len(s.UnpackedUint32Extension) > 0 {
		if len(s.UnpackedUint32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedUint32Extension {
				var entrySize = 0
				entrySize = gremlin.SizeUint32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedExtensions_UnpackedUint32Extension, listBytesSize)
			for _, entry := range s.UnpackedUint32Extension {
				res.AppendUint32WithoutTag(entry)
			}
		} else if len(s.UnpackedUint32Extension) == 1 {
			res.AppendUint32(wireTestUnpackedExtensions_UnpackedUint32Extension, s.UnpackedUint32Extension[0])
		}
	}
	if len(s.UnpackedUint64Extension) > 0 {
		if len(s.UnpackedUint64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedUint64Extension {
				var entrySize = 0
				entrySize = gremlin.SizeUint64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedExtensions_UnpackedUint64Extension, listBytesSize)
			for _, entry := range s.UnpackedUint64Extension {
				res.AppendUint64WithoutTag(entry)
			}
		} else if len(s.UnpackedUint64Extension) == 1 {
			res.AppendUint64(wireTestUnpackedExtensions_UnpackedUint64Extension, s.UnpackedUint64Extension[0])
		}
	}
	if len(s.UnpackedSint32Extension) > 0 {
		if len(s.UnpackedSint32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedSint32Extension {
				var entrySize = 0
				entrySize = gremlin.SizeSInt32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedExtensions_UnpackedSint32Extension, listBytesSize)
			for _, entry := range s.UnpackedSint32Extension {
				res.AppendSInt32WithoutTag(entry)
			}
		} else if len(s.UnpackedSint32Extension) == 1 {
			res.AppendSInt32(wireTestUnpackedExtensions_UnpackedSint32Extension, s.UnpackedSint32Extension[0])
		}
	}
	if len(s.UnpackedSint64Extension) > 0 {
		if len(s.UnpackedSint64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedSint64Extension {
				var entrySize = 0
				entrySize = gremlin.SizeSInt64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedExtensions_UnpackedSint64Extension, listBytesSize)
			for _, entry := range s.UnpackedSint64Extension {
				res.AppendSInt64WithoutTag(entry)
			}
		} else if len(s.UnpackedSint64Extension) == 1 {
			res.AppendSInt64(wireTestUnpackedExtensions_UnpackedSint64Extension, s.UnpackedSint64Extension[0])
		}
	}
	if len(s.UnpackedFixed32Extension) > 0 {
		if len(s.UnpackedFixed32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedFixed32Extension {
				var entrySize = 0
				entrySize = gremlin.SizeFixed32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedExtensions_UnpackedFixed32Extension, listBytesSize)
			for _, entry := range s.UnpackedFixed32Extension {
				res.AppendFixed32WithoutTag(entry)
			}
		} else if len(s.UnpackedFixed32Extension) == 1 {
			res.AppendFixed32(wireTestUnpackedExtensions_UnpackedFixed32Extension, s.UnpackedFixed32Extension[0])
		}
	}
	if len(s.UnpackedFixed64Extension) > 0 {
		if len(s.UnpackedFixed64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedFixed64Extension {
				var entrySize = 0
				entrySize = gremlin.SizeFixed64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedExtensions_UnpackedFixed64Extension, listBytesSize)
			for _, entry := range s.UnpackedFixed64Extension {
				res.AppendFixed64WithoutTag(entry)
			}
		} else if len(s.UnpackedFixed64Extension) == 1 {
			res.AppendFixed64(wireTestUnpackedExtensions_UnpackedFixed64Extension, s.UnpackedFixed64Extension[0])
		}
	}
	if len(s.UnpackedSfixed32Extension) > 0 {
		if len(s.UnpackedSfixed32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedSfixed32Extension {
				var entrySize = 0
				entrySize = gremlin.SizeSFixed32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedExtensions_UnpackedSfixed32Extension, listBytesSize)
			for _, entry := range s.UnpackedSfixed32Extension {
				res.AppendSFixed32WithoutTag(entry)
			}
		} else if len(s.UnpackedSfixed32Extension) == 1 {
			res.AppendSFixed32(wireTestUnpackedExtensions_UnpackedSfixed32Extension, s.UnpackedSfixed32Extension[0])
		}
	}
	if len(s.UnpackedSfixed64Extension) > 0 {
		if len(s.UnpackedSfixed64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedSfixed64Extension {
				var entrySize = 0
				entrySize = gremlin.SizeSFixed64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedExtensions_UnpackedSfixed64Extension, listBytesSize)
			for _, entry := range s.UnpackedSfixed64Extension {
				res.AppendSFixed64WithoutTag(entry)
			}
		} else if len(s.UnpackedSfixed64Extension) == 1 {
			res.AppendSFixed64(wireTestUnpackedExtensions_UnpackedSfixed64Extension, s.UnpackedSfixed64Extension[0])
		}
	}
	if len(s.UnpackedFloatExtension) > 0 {
		if len(s.UnpackedFloatExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedFloatExtension {
				var entrySize = 0
				entrySize = gremlin.SizeFloat32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedExtensions_UnpackedFloatExtension, listBytesSize)
			for _, entry := range s.UnpackedFloatExtension {
				res.AppendFloat32WithoutTag(entry)
			}
		} else if len(s.UnpackedFloatExtension) == 1 {
			res.AppendFloat32(wireTestUnpackedExtensions_UnpackedFloatExtension, s.UnpackedFloatExtension[0])
		}
	}
	if len(s.UnpackedDoubleExtension) > 0 {
		if len(s.UnpackedDoubleExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedDoubleExtension {
				var entrySize = 0
				entrySize = gremlin.SizeFloat64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedExtensions_UnpackedDoubleExtension, listBytesSize)
			for _, entry := range s.UnpackedDoubleExtension {
				res.AppendFloat64WithoutTag(entry)
			}
		} else if len(s.UnpackedDoubleExtension) == 1 {
			res.AppendFloat64(wireTestUnpackedExtensions_UnpackedDoubleExtension, s.UnpackedDoubleExtension[0])
		}
	}
	if len(s.UnpackedBoolExtension) > 0 {
		if len(s.UnpackedBoolExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedBoolExtension {
				var entrySize = 0
				entrySize = gremlin.SizeBool(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedExtensions_UnpackedBoolExtension, listBytesSize)
			for _, entry := range s.UnpackedBoolExtension {
				res.AppendBoolWithoutTag(entry)
			}
		} else if len(s.UnpackedBoolExtension) == 1 {
			res.AppendBool(wireTestUnpackedExtensions_UnpackedBoolExtension, s.UnpackedBoolExtension[0])
		}
	}
	if len(s.UnpackedEnumExtension) > 0 {
		if len(s.UnpackedEnumExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedEnumExtension {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(int32(entry))
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestUnpackedExtensions_UnpackedEnumExtension, listBytesSize)
			for _, entry := range s.UnpackedEnumExtension {
				res.AppendInt32WithoutTag(int32(entry))
			}
		} else if len(s.UnpackedEnumExtension) == 1 {
			res.AppendInt32(wireTestUnpackedExtensions_UnpackedEnumExtension, int32(s.UnpackedEnumExtension[0]))
		}
	}
}

func (s *TestUnpackedExtensions) Copy() *TestUnpackedExtensions {
	if s == nil {
		return nil
	}
	res := &TestUnpackedExtensions{}
	res.UnpackedInt32Extension = s.UnpackedInt32Extension
	res.UnpackedInt64Extension = s.UnpackedInt64Extension
	res.UnpackedUint32Extension = s.UnpackedUint32Extension
	res.UnpackedUint64Extension = s.UnpackedUint64Extension
	res.UnpackedSint32Extension = s.UnpackedSint32Extension
	res.UnpackedSint64Extension = s.UnpackedSint64Extension
	res.UnpackedFixed32Extension = s.UnpackedFixed32Extension
	res.UnpackedFixed64Extension = s.UnpackedFixed64Extension
	res.UnpackedSfixed32Extension = s.UnpackedSfixed32Extension
	res.UnpackedSfixed64Extension = s.UnpackedSfixed64Extension
	res.UnpackedFloatExtension = s.UnpackedFloatExtension
	res.UnpackedDoubleExtension = s.UnpackedDoubleExtension
	res.UnpackedBoolExtension = s.UnpackedBoolExtension
	res.UnpackedEnumExtension = s.UnpackedEnumExtension

	return res
}

func (s *TestUnpackedExtensions) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if len(s.UnpackedInt32Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedInt32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedInt32Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedInt32Extension) + listBytesSize
		} else if len(s.UnpackedInt32Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedInt32Extension) + gremlin.SizeInt32(s.UnpackedInt32Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedInt64Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedInt64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedInt64Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedInt64Extension) + listBytesSize
		} else if len(s.UnpackedInt64Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedInt64Extension) + gremlin.SizeInt64(s.UnpackedInt64Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedUint32Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedUint32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedUint32Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeUint32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedUint32Extension) + listBytesSize
		} else if len(s.UnpackedUint32Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedUint32Extension) + gremlin.SizeUint32(s.UnpackedUint32Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedUint64Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedUint64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedUint64Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeUint64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedUint64Extension) + listBytesSize
		} else if len(s.UnpackedUint64Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedUint64Extension) + gremlin.SizeUint64(s.UnpackedUint64Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedSint32Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedSint32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedSint32Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSInt32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedSint32Extension) + listBytesSize
		} else if len(s.UnpackedSint32Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedSint32Extension) + gremlin.SizeSInt32(s.UnpackedSint32Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedSint64Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedSint64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedSint64Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSInt64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedSint64Extension) + listBytesSize
		} else if len(s.UnpackedSint64Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedSint64Extension) + gremlin.SizeSInt64(s.UnpackedSint64Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedFixed32Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedFixed32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedFixed32Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFixed32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedFixed32Extension) + listBytesSize
		} else if len(s.UnpackedFixed32Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedFixed32Extension) + gremlin.SizeFixed32(s.UnpackedFixed32Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedFixed64Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedFixed64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedFixed64Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFixed64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedFixed64Extension) + listBytesSize
		} else if len(s.UnpackedFixed64Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedFixed64Extension) + gremlin.SizeFixed64(s.UnpackedFixed64Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedSfixed32Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedSfixed32Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedSfixed32Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSFixed32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedSfixed32Extension) + listBytesSize
		} else if len(s.UnpackedSfixed32Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedSfixed32Extension) + gremlin.SizeSFixed32(s.UnpackedSfixed32Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedSfixed64Extension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedSfixed64Extension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedSfixed64Extension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSFixed64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedSfixed64Extension) + listBytesSize
		} else if len(s.UnpackedSfixed64Extension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedSfixed64Extension) + gremlin.SizeSFixed64(s.UnpackedSfixed64Extension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedFloatExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedFloatExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedFloatExtension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFloat32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedFloatExtension) + listBytesSize
		} else if len(s.UnpackedFloatExtension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedFloatExtension) + gremlin.SizeFloat32(s.UnpackedFloatExtension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedDoubleExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedDoubleExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedDoubleExtension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFloat64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedDoubleExtension) + listBytesSize
		} else if len(s.UnpackedDoubleExtension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedDoubleExtension) + gremlin.SizeFloat64(s.UnpackedDoubleExtension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedBoolExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedBoolExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedBoolExtension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeBool(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedBoolExtension) + listBytesSize
		} else if len(s.UnpackedBoolExtension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedBoolExtension) + gremlin.SizeBool(s.UnpackedBoolExtension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.UnpackedEnumExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.UnpackedEnumExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.UnpackedEnumExtension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(int32(entry))
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedEnumExtension) + listBytesSize
		} else if len(s.UnpackedEnumExtension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestUnpackedExtensions_UnpackedEnumExtension) + gremlin.SizeInt32(int32(s.UnpackedEnumExtension[0]))
			entrySize += listEntrySize
		}
		size += entrySize
	}

	return size
}

const (
	wireTestDynamicExtensions_ScalarExtension gremlin.ProtoWireNumber = 2000
	wireTestDynamicExtensions_EnumExtension gremlin.ProtoWireNumber = 2001
	wireTestDynamicExtensions_DynamicEnumExtension gremlin.ProtoWireNumber = 2002
	wireTestDynamicExtensions_MessageExtension gremlin.ProtoWireNumber = 2003
	wireTestDynamicExtensions_DynamicMessageExtension gremlin.ProtoWireNumber = 2004
	wireTestDynamicExtensions_RepeatedExtension gremlin.ProtoWireNumber = 2005
	wireTestDynamicExtensions_PackedExtension gremlin.ProtoWireNumber = 2006
)

type TestDynamicExtensionsReader struct {
	buf *gremlin.Reader

	dataScalarExtension     uint32
	dataEnumExtension     ForeignEnum
	dataDynamicEnumExtension     TestDynamicExtensions_DynamicEnumType
	dataMessageExtension     *ForeignMessageReader
	dataDynamicMessageExtension     *TestDynamicExtensions_DynamicMessageTypeReader
	dataRepeatedExtension     []string
	dataPackedExtension     []int32

	offsetScalarExtension   int
	offsetEnumExtension   int
	offsetDynamicEnumExtension   int
	offsetMessageExtension   int
	offsetDynamicMessageExtension   int
	offsetRepeatedExtension   []int
	offsetPackedExtension   []int
	wireTypePackedExtension []gremlin.ProtoWireType

	parsedScalarExtension   bool
	parsedEnumExtension   bool
	parsedDynamicEnumExtension   bool
	parsedMessageExtension   bool
	parsedDynamicMessageExtension   bool
	parsedRepeatedExtension   bool
	parsedPackedExtension   bool
}

func NewTestDynamicExtensionsReader() *TestDynamicExtensionsReader {
	return &TestDynamicExtensionsReader{}
}

func (m *TestDynamicExtensionsReader) GetScalarExtension() uint32 {
	if m == nil {
		return 0
	}
	return m.readScalarExtension()
}

func (m *TestDynamicExtensionsReader) readScalarExtension() uint32 {
	if m.parsedScalarExtension {
		return m.dataScalarExtension
	}
	wOffset := m.offsetScalarExtension
	
	var entry uint32
	if wOffset > 0 {
		entry = m.buf.ReadFixed32(wOffset)
	}
	
	m.dataScalarExtension = entry
	m.parsedScalarExtension = true
	return entry
}

func (m *TestDynamicExtensionsReader) GetEnumExtension() ForeignEnum {
	if m == nil {
		return 0
	}
	return m.readEnumExtension()
}

func (m *TestDynamicExtensionsReader) readEnumExtension() ForeignEnum {
	if m.parsedEnumExtension {
		return m.dataEnumExtension
	}
	wOffset := m.offsetEnumExtension
	
	var entry ForeignEnum
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = ForeignEnum(rawEntry)
	} else {
		entry = 0
	}
	
	m.dataEnumExtension = entry
	m.parsedEnumExtension = true
	return entry
}

func (m *TestDynamicExtensionsReader) GetDynamicEnumExtension() TestDynamicExtensions_DynamicEnumType {
	if m == nil {
		return 0
	}
	return m.readDynamicEnumExtension()
}

func (m *TestDynamicExtensionsReader) readDynamicEnumExtension() TestDynamicExtensions_DynamicEnumType {
	if m.parsedDynamicEnumExtension {
		return m.dataDynamicEnumExtension
	}
	wOffset := m.offsetDynamicEnumExtension
	
	var entry TestDynamicExtensions_DynamicEnumType
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = TestDynamicExtensions_DynamicEnumType(rawEntry)
	} else {
		entry = 0
	}
	
	m.dataDynamicEnumExtension = entry
	m.parsedDynamicEnumExtension = true
	return entry
}

func (m *TestDynamicExtensionsReader) GetMessageExtension() *ForeignMessageReader {
	if m == nil {
		return nil
	}
	return m.readMessageExtension()
}

func (m *TestDynamicExtensionsReader) readMessageExtension() *ForeignMessageReader {
	if m.parsedMessageExtension {
		return m.dataMessageExtension
	}
	wOffset := m.offsetMessageExtension
	
	var entry *ForeignMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewForeignMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataMessageExtension = entry
	m.parsedMessageExtension = true
	return entry
}

func (m *TestDynamicExtensionsReader) GetDynamicMessageExtension() *TestDynamicExtensions_DynamicMessageTypeReader {
	if m == nil {
		return nil
	}
	return m.readDynamicMessageExtension()
}

func (m *TestDynamicExtensionsReader) readDynamicMessageExtension() *TestDynamicExtensions_DynamicMessageTypeReader {
	if m.parsedDynamicMessageExtension {
		return m.dataDynamicMessageExtension
	}
	wOffset := m.offsetDynamicMessageExtension
	
	var entry *TestDynamicExtensions_DynamicMessageTypeReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestDynamicExtensions_DynamicMessageTypeReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataDynamicMessageExtension = entry
	m.parsedDynamicMessageExtension = true
	return entry
}

func (m *TestDynamicExtensionsReader) GetRepeatedExtension() []string {
	if m == nil {
		return nil
	}
	return m.readRepeatedExtension()
}

func (m *TestDynamicExtensionsReader) readRepeatedExtension() []string {
	if m.parsedRepeatedExtension {
		return m.dataRepeatedExtension
	}
	wOffset := m.offsetRepeatedExtension
	
	var entry []string
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry string
		if wOffset > 0 {
			listEntry = m.buf.ReadString(wOffset)
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedExtension = entry
	m.parsedRepeatedExtension = true
	return entry
}

func (m *TestDynamicExtensionsReader) GetPackedExtension() []int32 {
	if m == nil {
		return nil
	}
	return m.readPackedExtension()
}

func (m *TestDynamicExtensionsReader) readPackedExtension() []int32 {
	if m.parsedPackedExtension {
		return m.dataPackedExtension
	}
	wOffset := m.offsetPackedExtension
	var wType = m.wireTypePackedExtension
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadSInt32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadSInt32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedExtension = entry
	m.parsedPackedExtension = true
	return entry
}

func (m *TestDynamicExtensionsReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestDynamicExtensions_ScalarExtension:
			m.offsetScalarExtension = offset
		case wireTestDynamicExtensions_EnumExtension:
			m.offsetEnumExtension = offset
		case wireTestDynamicExtensions_DynamicEnumExtension:
			m.offsetDynamicEnumExtension = offset
		case wireTestDynamicExtensions_MessageExtension:
			m.offsetMessageExtension = offset
		case wireTestDynamicExtensions_DynamicMessageExtension:
			m.offsetDynamicMessageExtension = offset
		case wireTestDynamicExtensions_RepeatedExtension:
			m.offsetRepeatedExtension = append(m.offsetRepeatedExtension, offset)
		case wireTestDynamicExtensions_PackedExtension:
			m.offsetPackedExtension = append(m.offsetPackedExtension, offset)
			m.wireTypePackedExtension = append(m.wireTypePackedExtension, wire)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestDynamicExtensionsReader) ToStruct() *TestDynamicExtensions {
	if m == nil {
		return nil
	}
	res := &TestDynamicExtensions{}
	res.ScalarExtension = m.GetScalarExtension()
	res.EnumExtension = m.GetEnumExtension()
	res.DynamicEnumExtension = m.GetDynamicEnumExtension()

	{
		var data = m.GetMessageExtension()
		var structData *ForeignMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.MessageExtension = structData
	}

	{
		var data = m.GetDynamicMessageExtension()
		var structData *TestDynamicExtensions_DynamicMessageType
		if data != nil {
			structData = data.ToStruct()
		}
		res.DynamicMessageExtension = structData
	}
	res.RepeatedExtension = m.GetRepeatedExtension()
	res.PackedExtension = m.GetPackedExtension()

	return res
}

func (s *TestDynamicExtensionsReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestDynamicExtensions struct {
	ScalarExtension	uint32	`json:"scalar_extension,omitempty"`
	EnumExtension	ForeignEnum	`json:"enum_extension,omitempty"`
	DynamicEnumExtension	TestDynamicExtensions_DynamicEnumType	`json:"dynamic_enum_extension,omitempty"`
	MessageExtension	*ForeignMessage	`json:"message_extension,omitempty"`
	DynamicMessageExtension	*TestDynamicExtensions_DynamicMessageType	`json:"dynamic_message_extension,omitempty"`
	RepeatedExtension	[]string	`json:"repeated_extension,omitempty"`
	PackedExtension	[]int32	`json:"packed_extension,omitempty"`
}

func (s *TestDynamicExtensions) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestDynamicExtensions) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.ScalarExtension != 0 {
		res.AppendFixed32(wireTestDynamicExtensions_ScalarExtension, s.ScalarExtension)
	}
	if s.EnumExtension != 0 {
		res.AppendInt32(wireTestDynamicExtensions_EnumExtension, int32(s.EnumExtension))
	}
	if s.DynamicEnumExtension != 0 {
		res.AppendInt32(wireTestDynamicExtensions_DynamicEnumExtension, int32(s.DynamicEnumExtension))
	}
	if s.MessageExtension != nil {
		structSize := s.MessageExtension.XXX_PbContentSize()
		res.AppendBytesTag(wireTestDynamicExtensions_MessageExtension, structSize)
		s.MessageExtension.MarshalTo(res)
	}
	if s.DynamicMessageExtension != nil {
		structSize := s.DynamicMessageExtension.XXX_PbContentSize()
		res.AppendBytesTag(wireTestDynamicExtensions_DynamicMessageExtension, structSize)
		s.DynamicMessageExtension.MarshalTo(res)
	}
	if len(s.RepeatedExtension) > 0 {
		for _, entry := range s.RepeatedExtension {
			res.AppendString(wireTestDynamicExtensions_RepeatedExtension, entry)
		}
	}
	if len(s.PackedExtension) > 0 {
		if len(s.PackedExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedExtension {
				var entrySize = 0
				entrySize = gremlin.SizeSInt32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestDynamicExtensions_PackedExtension, listBytesSize)
			for _, entry := range s.PackedExtension {
				res.AppendSInt32WithoutTag(entry)
			}
		} else if len(s.PackedExtension) == 1 {
			res.AppendSInt32(wireTestDynamicExtensions_PackedExtension, s.PackedExtension[0])
		}
	}
}

func (s *TestDynamicExtensions) Copy() *TestDynamicExtensions {
	if s == nil {
		return nil
	}
	res := &TestDynamicExtensions{}
	res.ScalarExtension = s.ScalarExtension
	res.EnumExtension = s.EnumExtension
	res.DynamicEnumExtension = s.DynamicEnumExtension
	if s.MessageExtension != nil {
		res.MessageExtension = s.MessageExtension.Copy()
	}
	if s.DynamicMessageExtension != nil {
		res.DynamicMessageExtension = s.DynamicMessageExtension.Copy()
	}
	res.RepeatedExtension = s.RepeatedExtension
	res.PackedExtension = s.PackedExtension

	return res
}

func (s *TestDynamicExtensions) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.ScalarExtension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestDynamicExtensions_ScalarExtension) + gremlin.SizeFixed32(s.ScalarExtension)
		size += entrySize
	}

	if s.EnumExtension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestDynamicExtensions_EnumExtension) + gremlin.SizeInt32(int32(s.EnumExtension))
		size += entrySize
	}

	if s.DynamicEnumExtension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestDynamicExtensions_DynamicEnumExtension) + gremlin.SizeInt32(int32(s.DynamicEnumExtension))
		size += entrySize
	}

	if s.MessageExtension != nil {
		var entrySize = 0
		entrySize = s.MessageExtension.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestDynamicExtensions_MessageExtension)
		
		size += entrySize
	}

	if s.DynamicMessageExtension != nil {
		var entrySize = 0
		entrySize = s.DynamicMessageExtension.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestDynamicExtensions_DynamicMessageExtension)
		
		size += entrySize
	}

	if len(s.RepeatedExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedExtension {
			var listEntrySize int
			listEntrySize = gremlin.SizeString(val)
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestDynamicExtensions_RepeatedExtension)
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedExtension) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedExtension) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedExtension {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeSInt32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestDynamicExtensions_PackedExtension) + listBytesSize
		} else if len(s.PackedExtension) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestDynamicExtensions_PackedExtension) + gremlin.SizeSInt32(s.PackedExtension[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	return size
}

const (
	wireTestDynamicExtensions_DynamicMessageType_DynamicField gremlin.ProtoWireNumber = 2100
)

type TestDynamicExtensions_DynamicMessageTypeReader struct {
	buf *gremlin.Reader

	dataDynamicField     int32

	offsetDynamicField   int

	parsedDynamicField   bool
}

func NewTestDynamicExtensions_DynamicMessageTypeReader() *TestDynamicExtensions_DynamicMessageTypeReader {
	return &TestDynamicExtensions_DynamicMessageTypeReader{}
}

func (m *TestDynamicExtensions_DynamicMessageTypeReader) GetDynamicField() int32 {
	if m == nil {
		return 0
	}
	return m.readDynamicField()
}

func (m *TestDynamicExtensions_DynamicMessageTypeReader) readDynamicField() int32 {
	if m.parsedDynamicField {
		return m.dataDynamicField
	}
	wOffset := m.offsetDynamicField
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataDynamicField = entry
	m.parsedDynamicField = true
	return entry
}

func (m *TestDynamicExtensions_DynamicMessageTypeReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestDynamicExtensions_DynamicMessageType_DynamicField:
			m.offsetDynamicField = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestDynamicExtensions_DynamicMessageTypeReader) ToStruct() *TestDynamicExtensions_DynamicMessageType {
	if m == nil {
		return nil
	}
	res := &TestDynamicExtensions_DynamicMessageType{}
	res.DynamicField = m.GetDynamicField()

	return res
}

func (s *TestDynamicExtensions_DynamicMessageTypeReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestDynamicExtensions_DynamicMessageType struct {
	DynamicField	int32	`json:"dynamic_field,omitempty"`
}

func (s *TestDynamicExtensions_DynamicMessageType) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestDynamicExtensions_DynamicMessageType) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.DynamicField != 0 {
		res.AppendInt32(wireTestDynamicExtensions_DynamicMessageType_DynamicField, s.DynamicField)
	}
}

func (s *TestDynamicExtensions_DynamicMessageType) Copy() *TestDynamicExtensions_DynamicMessageType {
	if s == nil {
		return nil
	}
	res := &TestDynamicExtensions_DynamicMessageType{}
	res.DynamicField = s.DynamicField

	return res
}

func (s *TestDynamicExtensions_DynamicMessageType) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.DynamicField != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestDynamicExtensions_DynamicMessageType_DynamicField) + gremlin.SizeInt32(s.DynamicField)
		size += entrySize
	}

	return size
}

const (
	wireTestRepeatedScalarDifferentTagSizes_RepeatedFixed32 gremlin.ProtoWireNumber = 12
	wireTestRepeatedScalarDifferentTagSizes_RepeatedInt32 gremlin.ProtoWireNumber = 13
	wireTestRepeatedScalarDifferentTagSizes_RepeatedFixed64 gremlin.ProtoWireNumber = 2046
	wireTestRepeatedScalarDifferentTagSizes_RepeatedInt64 gremlin.ProtoWireNumber = 2047
	wireTestRepeatedScalarDifferentTagSizes_RepeatedFloat gremlin.ProtoWireNumber = 262142
	wireTestRepeatedScalarDifferentTagSizes_RepeatedUint64 gremlin.ProtoWireNumber = 262143
)

type TestRepeatedScalarDifferentTagSizesReader struct {
	buf *gremlin.Reader

	dataRepeatedFixed32     []uint32
	dataRepeatedInt32     []int32
	dataRepeatedFixed64     []uint64
	dataRepeatedInt64     []int64
	dataRepeatedFloat     []float32
	dataRepeatedUint64     []uint64

	offsetRepeatedFixed32   []int
	wireTypeRepeatedFixed32 []gremlin.ProtoWireType
	offsetRepeatedInt32   []int
	wireTypeRepeatedInt32 []gremlin.ProtoWireType
	offsetRepeatedFixed64   []int
	wireTypeRepeatedFixed64 []gremlin.ProtoWireType
	offsetRepeatedInt64   []int
	wireTypeRepeatedInt64 []gremlin.ProtoWireType
	offsetRepeatedFloat   []int
	wireTypeRepeatedFloat []gremlin.ProtoWireType
	offsetRepeatedUint64   []int
	wireTypeRepeatedUint64 []gremlin.ProtoWireType

	parsedRepeatedFixed32   bool
	parsedRepeatedInt32   bool
	parsedRepeatedFixed64   bool
	parsedRepeatedInt64   bool
	parsedRepeatedFloat   bool
	parsedRepeatedUint64   bool
}

func NewTestRepeatedScalarDifferentTagSizesReader() *TestRepeatedScalarDifferentTagSizesReader {
	return &TestRepeatedScalarDifferentTagSizesReader{}
}

func (m *TestRepeatedScalarDifferentTagSizesReader) GetRepeatedFixed32() []uint32 {
	if m == nil {
		return nil
	}
	return m.readRepeatedFixed32()
}

func (m *TestRepeatedScalarDifferentTagSizesReader) readRepeatedFixed32() []uint32 {
	if m.parsedRepeatedFixed32 {
		return m.dataRepeatedFixed32
	}
	wOffset := m.offsetRepeatedFixed32
	var wType = m.wireTypeRepeatedFixed32
	
	var entry []uint32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFixed32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint32
			if wOffset > 0 {
				listEntry = m.buf.ReadFixed32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedFixed32 = entry
	m.parsedRepeatedFixed32 = true
	return entry
}

func (m *TestRepeatedScalarDifferentTagSizesReader) GetRepeatedInt32() []int32 {
	if m == nil {
		return nil
	}
	return m.readRepeatedInt32()
}

func (m *TestRepeatedScalarDifferentTagSizesReader) readRepeatedInt32() []int32 {
	if m.parsedRepeatedInt32 {
		return m.dataRepeatedInt32
	}
	wOffset := m.offsetRepeatedInt32
	var wType = m.wireTypeRepeatedInt32
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadInt32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedInt32 = entry
	m.parsedRepeatedInt32 = true
	return entry
}

func (m *TestRepeatedScalarDifferentTagSizesReader) GetRepeatedFixed64() []uint64 {
	if m == nil {
		return nil
	}
	return m.readRepeatedFixed64()
}

func (m *TestRepeatedScalarDifferentTagSizesReader) readRepeatedFixed64() []uint64 {
	if m.parsedRepeatedFixed64 {
		return m.dataRepeatedFixed64
	}
	wOffset := m.offsetRepeatedFixed64
	var wType = m.wireTypeRepeatedFixed64
	
	var entry []uint64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFixed64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint64
			if wOffset > 0 {
				listEntry = m.buf.ReadFixed64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedFixed64 = entry
	m.parsedRepeatedFixed64 = true
	return entry
}

func (m *TestRepeatedScalarDifferentTagSizesReader) GetRepeatedInt64() []int64 {
	if m == nil {
		return nil
	}
	return m.readRepeatedInt64()
}

func (m *TestRepeatedScalarDifferentTagSizesReader) readRepeatedInt64() []int64 {
	if m.parsedRepeatedInt64 {
		return m.dataRepeatedInt64
	}
	wOffset := m.offsetRepeatedInt64
	var wType = m.wireTypeRepeatedInt64
	
	var entry []int64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadInt64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int64
			if wOffset > 0 {
				listEntry = m.buf.ReadInt64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedInt64 = entry
	m.parsedRepeatedInt64 = true
	return entry
}

func (m *TestRepeatedScalarDifferentTagSizesReader) GetRepeatedFloat() []float32 {
	if m == nil {
		return nil
	}
	return m.readRepeatedFloat()
}

func (m *TestRepeatedScalarDifferentTagSizesReader) readRepeatedFloat() []float32 {
	if m.parsedRepeatedFloat {
		return m.dataRepeatedFloat
	}
	wOffset := m.offsetRepeatedFloat
	var wType = m.wireTypeRepeatedFloat
	
	var entry []float32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry float32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadFloat32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry float32
			if wOffset > 0 {
				listEntry = m.buf.ReadFloat32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedFloat = entry
	m.parsedRepeatedFloat = true
	return entry
}

func (m *TestRepeatedScalarDifferentTagSizesReader) GetRepeatedUint64() []uint64 {
	if m == nil {
		return nil
	}
	return m.readRepeatedUint64()
}

func (m *TestRepeatedScalarDifferentTagSizesReader) readRepeatedUint64() []uint64 {
	if m.parsedRepeatedUint64 {
		return m.dataRepeatedUint64
	}
	wOffset := m.offsetRepeatedUint64
	var wType = m.wireTypeRepeatedUint64
	
	var entry []uint64
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry uint64
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadUint64(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry uint64
			if wOffset > 0 {
				listEntry = m.buf.ReadUint64(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedUint64 = entry
	m.parsedRepeatedUint64 = true
	return entry
}

func (m *TestRepeatedScalarDifferentTagSizesReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestRepeatedScalarDifferentTagSizes_RepeatedFixed32:
			m.offsetRepeatedFixed32 = append(m.offsetRepeatedFixed32, offset)
			m.wireTypeRepeatedFixed32 = append(m.wireTypeRepeatedFixed32, wire)
		case wireTestRepeatedScalarDifferentTagSizes_RepeatedInt32:
			m.offsetRepeatedInt32 = append(m.offsetRepeatedInt32, offset)
			m.wireTypeRepeatedInt32 = append(m.wireTypeRepeatedInt32, wire)
		case wireTestRepeatedScalarDifferentTagSizes_RepeatedFixed64:
			m.offsetRepeatedFixed64 = append(m.offsetRepeatedFixed64, offset)
			m.wireTypeRepeatedFixed64 = append(m.wireTypeRepeatedFixed64, wire)
		case wireTestRepeatedScalarDifferentTagSizes_RepeatedInt64:
			m.offsetRepeatedInt64 = append(m.offsetRepeatedInt64, offset)
			m.wireTypeRepeatedInt64 = append(m.wireTypeRepeatedInt64, wire)
		case wireTestRepeatedScalarDifferentTagSizes_RepeatedFloat:
			m.offsetRepeatedFloat = append(m.offsetRepeatedFloat, offset)
			m.wireTypeRepeatedFloat = append(m.wireTypeRepeatedFloat, wire)
		case wireTestRepeatedScalarDifferentTagSizes_RepeatedUint64:
			m.offsetRepeatedUint64 = append(m.offsetRepeatedUint64, offset)
			m.wireTypeRepeatedUint64 = append(m.wireTypeRepeatedUint64, wire)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestRepeatedScalarDifferentTagSizesReader) ToStruct() *TestRepeatedScalarDifferentTagSizes {
	if m == nil {
		return nil
	}
	res := &TestRepeatedScalarDifferentTagSizes{}
	res.RepeatedFixed32 = m.GetRepeatedFixed32()
	res.RepeatedInt32 = m.GetRepeatedInt32()
	res.RepeatedFixed64 = m.GetRepeatedFixed64()
	res.RepeatedInt64 = m.GetRepeatedInt64()
	res.RepeatedFloat = m.GetRepeatedFloat()
	res.RepeatedUint64 = m.GetRepeatedUint64()

	return res
}

func (s *TestRepeatedScalarDifferentTagSizesReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestRepeatedScalarDifferentTagSizes struct {
	RepeatedFixed32	[]uint32	`json:"repeated_fixed32,omitempty"`
	RepeatedInt32	[]int32	`json:"repeated_int32,omitempty"`
	RepeatedFixed64	[]uint64	`json:"repeated_fixed64,omitempty"`
	RepeatedInt64	[]int64	`json:"repeated_int64,omitempty"`
	RepeatedFloat	[]float32	`json:"repeated_float,omitempty"`
	RepeatedUint64	[]uint64	`json:"repeated_uint64,omitempty"`
}

func (s *TestRepeatedScalarDifferentTagSizes) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestRepeatedScalarDifferentTagSizes) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if len(s.RepeatedFixed32) > 0 {
		if len(s.RepeatedFixed32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedFixed32 {
				var entrySize = 0
				entrySize = gremlin.SizeFixed32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestRepeatedScalarDifferentTagSizes_RepeatedFixed32, listBytesSize)
			for _, entry := range s.RepeatedFixed32 {
				res.AppendFixed32WithoutTag(entry)
			}
		} else if len(s.RepeatedFixed32) == 1 {
			res.AppendFixed32(wireTestRepeatedScalarDifferentTagSizes_RepeatedFixed32, s.RepeatedFixed32[0])
		}
	}
	if len(s.RepeatedInt32) > 0 {
		if len(s.RepeatedInt32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedInt32 {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestRepeatedScalarDifferentTagSizes_RepeatedInt32, listBytesSize)
			for _, entry := range s.RepeatedInt32 {
				res.AppendInt32WithoutTag(entry)
			}
		} else if len(s.RepeatedInt32) == 1 {
			res.AppendInt32(wireTestRepeatedScalarDifferentTagSizes_RepeatedInt32, s.RepeatedInt32[0])
		}
	}
	if len(s.RepeatedFixed64) > 0 {
		if len(s.RepeatedFixed64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedFixed64 {
				var entrySize = 0
				entrySize = gremlin.SizeFixed64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestRepeatedScalarDifferentTagSizes_RepeatedFixed64, listBytesSize)
			for _, entry := range s.RepeatedFixed64 {
				res.AppendFixed64WithoutTag(entry)
			}
		} else if len(s.RepeatedFixed64) == 1 {
			res.AppendFixed64(wireTestRepeatedScalarDifferentTagSizes_RepeatedFixed64, s.RepeatedFixed64[0])
		}
	}
	if len(s.RepeatedInt64) > 0 {
		if len(s.RepeatedInt64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedInt64 {
				var entrySize = 0
				entrySize = gremlin.SizeInt64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestRepeatedScalarDifferentTagSizes_RepeatedInt64, listBytesSize)
			for _, entry := range s.RepeatedInt64 {
				res.AppendInt64WithoutTag(entry)
			}
		} else if len(s.RepeatedInt64) == 1 {
			res.AppendInt64(wireTestRepeatedScalarDifferentTagSizes_RepeatedInt64, s.RepeatedInt64[0])
		}
	}
	if len(s.RepeatedFloat) > 0 {
		if len(s.RepeatedFloat) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedFloat {
				var entrySize = 0
				entrySize = gremlin.SizeFloat32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestRepeatedScalarDifferentTagSizes_RepeatedFloat, listBytesSize)
			for _, entry := range s.RepeatedFloat {
				res.AppendFloat32WithoutTag(entry)
			}
		} else if len(s.RepeatedFloat) == 1 {
			res.AppendFloat32(wireTestRepeatedScalarDifferentTagSizes_RepeatedFloat, s.RepeatedFloat[0])
		}
	}
	if len(s.RepeatedUint64) > 0 {
		if len(s.RepeatedUint64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedUint64 {
				var entrySize = 0
				entrySize = gremlin.SizeUint64(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestRepeatedScalarDifferentTagSizes_RepeatedUint64, listBytesSize)
			for _, entry := range s.RepeatedUint64 {
				res.AppendUint64WithoutTag(entry)
			}
		} else if len(s.RepeatedUint64) == 1 {
			res.AppendUint64(wireTestRepeatedScalarDifferentTagSizes_RepeatedUint64, s.RepeatedUint64[0])
		}
	}
}

func (s *TestRepeatedScalarDifferentTagSizes) Copy() *TestRepeatedScalarDifferentTagSizes {
	if s == nil {
		return nil
	}
	res := &TestRepeatedScalarDifferentTagSizes{}
	res.RepeatedFixed32 = s.RepeatedFixed32
	res.RepeatedInt32 = s.RepeatedInt32
	res.RepeatedFixed64 = s.RepeatedFixed64
	res.RepeatedInt64 = s.RepeatedInt64
	res.RepeatedFloat = s.RepeatedFloat
	res.RepeatedUint64 = s.RepeatedUint64

	return res
}

func (s *TestRepeatedScalarDifferentTagSizes) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if len(s.RepeatedFixed32) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedFixed32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedFixed32 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFixed32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestRepeatedScalarDifferentTagSizes_RepeatedFixed32) + listBytesSize
		} else if len(s.RepeatedFixed32) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestRepeatedScalarDifferentTagSizes_RepeatedFixed32) + gremlin.SizeFixed32(s.RepeatedFixed32[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedInt32) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedInt32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedInt32 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestRepeatedScalarDifferentTagSizes_RepeatedInt32) + listBytesSize
		} else if len(s.RepeatedInt32) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestRepeatedScalarDifferentTagSizes_RepeatedInt32) + gremlin.SizeInt32(s.RepeatedInt32[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedFixed64) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedFixed64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedFixed64 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFixed64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestRepeatedScalarDifferentTagSizes_RepeatedFixed64) + listBytesSize
		} else if len(s.RepeatedFixed64) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestRepeatedScalarDifferentTagSizes_RepeatedFixed64) + gremlin.SizeFixed64(s.RepeatedFixed64[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedInt64) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedInt64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedInt64 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestRepeatedScalarDifferentTagSizes_RepeatedInt64) + listBytesSize
		} else if len(s.RepeatedInt64) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestRepeatedScalarDifferentTagSizes_RepeatedInt64) + gremlin.SizeInt64(s.RepeatedInt64[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedFloat) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedFloat) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedFloat {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeFloat32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestRepeatedScalarDifferentTagSizes_RepeatedFloat) + listBytesSize
		} else if len(s.RepeatedFloat) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestRepeatedScalarDifferentTagSizes_RepeatedFloat) + gremlin.SizeFloat32(s.RepeatedFloat[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.RepeatedUint64) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedUint64) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedUint64 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeUint64(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestRepeatedScalarDifferentTagSizes_RepeatedUint64) + listBytesSize
		} else if len(s.RepeatedUint64) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestRepeatedScalarDifferentTagSizes_RepeatedUint64) + gremlin.SizeUint64(s.RepeatedUint64[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	return size
}

const (
	wireTestParsingMerge_RequiredAllTypes gremlin.ProtoWireNumber = 1
	wireTestParsingMerge_OptionalAllTypes gremlin.ProtoWireNumber = 2
	wireTestParsingMerge_RepeatedAllTypes gremlin.ProtoWireNumber = 3
)

type TestParsingMergeReader struct {
	buf *gremlin.Reader

	dataRequiredAllTypes     *TestAllTypesReader
	dataOptionalAllTypes     *TestAllTypesReader
	dataRepeatedAllTypes     []*TestAllTypesReader

	offsetRequiredAllTypes   int
	offsetOptionalAllTypes   int
	offsetRepeatedAllTypes   []int

	parsedRequiredAllTypes   bool
	parsedOptionalAllTypes   bool
	parsedRepeatedAllTypes   bool
}

func NewTestParsingMergeReader() *TestParsingMergeReader {
	return &TestParsingMergeReader{}
}

func (m *TestParsingMergeReader) GetRequiredAllTypes() *TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readRequiredAllTypes()
}

func (m *TestParsingMergeReader) readRequiredAllTypes() *TestAllTypesReader {
	if m.parsedRequiredAllTypes {
		return m.dataRequiredAllTypes
	}
	wOffset := m.offsetRequiredAllTypes
	
	var entry *TestAllTypesReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypesReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataRequiredAllTypes = entry
	m.parsedRequiredAllTypes = true
	return entry
}

func (m *TestParsingMergeReader) GetOptionalAllTypes() *TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readOptionalAllTypes()
}

func (m *TestParsingMergeReader) readOptionalAllTypes() *TestAllTypesReader {
	if m.parsedOptionalAllTypes {
		return m.dataOptionalAllTypes
	}
	wOffset := m.offsetOptionalAllTypes
	
	var entry *TestAllTypesReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypesReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalAllTypes = entry
	m.parsedOptionalAllTypes = true
	return entry
}

func (m *TestParsingMergeReader) GetRepeatedAllTypes() []*TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readRepeatedAllTypes()
}

func (m *TestParsingMergeReader) readRepeatedAllTypes() []*TestAllTypesReader {
	if m.parsedRepeatedAllTypes {
		return m.dataRepeatedAllTypes
	}
	wOffset := m.offsetRepeatedAllTypes
	
	var entry []*TestAllTypesReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *TestAllTypesReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewTestAllTypesReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedAllTypes = entry
	m.parsedRepeatedAllTypes = true
	return entry
}

func (m *TestParsingMergeReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestParsingMerge_RequiredAllTypes:
			m.offsetRequiredAllTypes = offset
		case wireTestParsingMerge_OptionalAllTypes:
			m.offsetOptionalAllTypes = offset
		case wireTestParsingMerge_RepeatedAllTypes:
			m.offsetRepeatedAllTypes = append(m.offsetRepeatedAllTypes, offset)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestParsingMergeReader) ToStruct() *TestParsingMerge {
	if m == nil {
		return nil
	}
	res := &TestParsingMerge{}

	{
		var data = m.GetRequiredAllTypes()
		var structData *TestAllTypes
		if data != nil {
			structData = data.ToStruct()
		}
		res.RequiredAllTypes = structData
	}

	{
		var data = m.GetOptionalAllTypes()
		var structData *TestAllTypes
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalAllTypes = structData
	}

	{
		var data = m.GetRepeatedAllTypes()
		var structData []*TestAllTypes
		if len(data) > 0 {
			structData = make([]*TestAllTypes, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.RepeatedAllTypes = structData
	}

	return res
}

func (s *TestParsingMergeReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestParsingMerge struct {
	RequiredAllTypes	*TestAllTypes	`json:"required_all_types,omitempty"`
	OptionalAllTypes	*TestAllTypes	`json:"optional_all_types,omitempty"`
	RepeatedAllTypes	[]*TestAllTypes	`json:"repeated_all_types,omitempty"`
}

func (s *TestParsingMerge) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestParsingMerge) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if true {
		structSize := s.RequiredAllTypes.XXX_PbContentSize()
		res.AppendBytesTag(wireTestParsingMerge_RequiredAllTypes, structSize)
		s.RequiredAllTypes.MarshalTo(res)
	}
	if s.OptionalAllTypes != nil {
		structSize := s.OptionalAllTypes.XXX_PbContentSize()
		res.AppendBytesTag(wireTestParsingMerge_OptionalAllTypes, structSize)
		s.OptionalAllTypes.MarshalTo(res)
	}
	if len(s.RepeatedAllTypes) > 0 {
		for _, entry := range s.RepeatedAllTypes {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireTestParsingMerge_RepeatedAllTypes, structSize)
			entry.MarshalTo(res)
		}
	}
}

func (s *TestParsingMerge) Copy() *TestParsingMerge {
	if s == nil {
		return nil
	}
	res := &TestParsingMerge{}
	if s.RequiredAllTypes != nil {
		res.RequiredAllTypes = s.RequiredAllTypes.Copy()
	}
	if s.OptionalAllTypes != nil {
		res.OptionalAllTypes = s.OptionalAllTypes.Copy()
	}
	res.RepeatedAllTypes = make([]*TestAllTypes, len(s.RepeatedAllTypes))
	for i := range s.RepeatedAllTypes {
		if s.RepeatedAllTypes[i] != nil {
			res.RepeatedAllTypes[i] = s.RepeatedAllTypes[i].Copy()
		}
	}

	return res
}

func (s *TestParsingMerge) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if true {
		var entrySize = 0
		entrySize = s.RequiredAllTypes.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestParsingMerge_RequiredAllTypes)
		
		size += entrySize
	}

	if s.OptionalAllTypes != nil {
		var entrySize = 0
		entrySize = s.OptionalAllTypes.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestParsingMerge_OptionalAllTypes)
		
		size += entrySize
	}

	if len(s.RepeatedAllTypes) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedAllTypes {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestParsingMerge_RepeatedAllTypes)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	return size
}

const (
	wireTestParsingMerge_RepeatedFieldsGenerator_Field1 gremlin.ProtoWireNumber = 1
	wireTestParsingMerge_RepeatedFieldsGenerator_Field2 gremlin.ProtoWireNumber = 2
	wireTestParsingMerge_RepeatedFieldsGenerator_Field3 gremlin.ProtoWireNumber = 3
	wireTestParsingMerge_RepeatedFieldsGenerator_Ext1 gremlin.ProtoWireNumber = 1000
	wireTestParsingMerge_RepeatedFieldsGenerator_Ext2 gremlin.ProtoWireNumber = 1001
)

type TestParsingMerge_RepeatedFieldsGeneratorReader struct {
	buf *gremlin.Reader

	dataField1     []*TestAllTypesReader
	dataField2     []*TestAllTypesReader
	dataField3     []*TestAllTypesReader
	dataExt1     []*TestAllTypesReader
	dataExt2     []*TestAllTypesReader

	offsetField1   []int
	offsetField2   []int
	offsetField3   []int
	offsetExt1   []int
	offsetExt2   []int

	parsedField1   bool
	parsedField2   bool
	parsedField3   bool
	parsedExt1   bool
	parsedExt2   bool
}

func NewTestParsingMerge_RepeatedFieldsGeneratorReader() *TestParsingMerge_RepeatedFieldsGeneratorReader {
	return &TestParsingMerge_RepeatedFieldsGeneratorReader{}
}

func (m *TestParsingMerge_RepeatedFieldsGeneratorReader) GetField1() []*TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readField1()
}

func (m *TestParsingMerge_RepeatedFieldsGeneratorReader) readField1() []*TestAllTypesReader {
	if m.parsedField1 {
		return m.dataField1
	}
	wOffset := m.offsetField1
	
	var entry []*TestAllTypesReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *TestAllTypesReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewTestAllTypesReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataField1 = entry
	m.parsedField1 = true
	return entry
}

func (m *TestParsingMerge_RepeatedFieldsGeneratorReader) GetField2() []*TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readField2()
}

func (m *TestParsingMerge_RepeatedFieldsGeneratorReader) readField2() []*TestAllTypesReader {
	if m.parsedField2 {
		return m.dataField2
	}
	wOffset := m.offsetField2
	
	var entry []*TestAllTypesReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *TestAllTypesReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewTestAllTypesReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataField2 = entry
	m.parsedField2 = true
	return entry
}

func (m *TestParsingMerge_RepeatedFieldsGeneratorReader) GetField3() []*TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readField3()
}

func (m *TestParsingMerge_RepeatedFieldsGeneratorReader) readField3() []*TestAllTypesReader {
	if m.parsedField3 {
		return m.dataField3
	}
	wOffset := m.offsetField3
	
	var entry []*TestAllTypesReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *TestAllTypesReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewTestAllTypesReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataField3 = entry
	m.parsedField3 = true
	return entry
}

func (m *TestParsingMerge_RepeatedFieldsGeneratorReader) GetExt1() []*TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readExt1()
}

func (m *TestParsingMerge_RepeatedFieldsGeneratorReader) readExt1() []*TestAllTypesReader {
	if m.parsedExt1 {
		return m.dataExt1
	}
	wOffset := m.offsetExt1
	
	var entry []*TestAllTypesReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *TestAllTypesReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewTestAllTypesReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataExt1 = entry
	m.parsedExt1 = true
	return entry
}

func (m *TestParsingMerge_RepeatedFieldsGeneratorReader) GetExt2() []*TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readExt2()
}

func (m *TestParsingMerge_RepeatedFieldsGeneratorReader) readExt2() []*TestAllTypesReader {
	if m.parsedExt2 {
		return m.dataExt2
	}
	wOffset := m.offsetExt2
	
	var entry []*TestAllTypesReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *TestAllTypesReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewTestAllTypesReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataExt2 = entry
	m.parsedExt2 = true
	return entry
}

func (m *TestParsingMerge_RepeatedFieldsGeneratorReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestParsingMerge_RepeatedFieldsGenerator_Field1:
			m.offsetField1 = append(m.offsetField1, offset)
		case wireTestParsingMerge_RepeatedFieldsGenerator_Field2:
			m.offsetField2 = append(m.offsetField2, offset)
		case wireTestParsingMerge_RepeatedFieldsGenerator_Field3:
			m.offsetField3 = append(m.offsetField3, offset)
		case wireTestParsingMerge_RepeatedFieldsGenerator_Ext1:
			m.offsetExt1 = append(m.offsetExt1, offset)
		case wireTestParsingMerge_RepeatedFieldsGenerator_Ext2:
			m.offsetExt2 = append(m.offsetExt2, offset)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestParsingMerge_RepeatedFieldsGeneratorReader) ToStruct() *TestParsingMerge_RepeatedFieldsGenerator {
	if m == nil {
		return nil
	}
	res := &TestParsingMerge_RepeatedFieldsGenerator{}

	{
		var data = m.GetField1()
		var structData []*TestAllTypes
		if len(data) > 0 {
			structData = make([]*TestAllTypes, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.Field1 = structData
	}

	{
		var data = m.GetField2()
		var structData []*TestAllTypes
		if len(data) > 0 {
			structData = make([]*TestAllTypes, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.Field2 = structData
	}

	{
		var data = m.GetField3()
		var structData []*TestAllTypes
		if len(data) > 0 {
			structData = make([]*TestAllTypes, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.Field3 = structData
	}

	{
		var data = m.GetExt1()
		var structData []*TestAllTypes
		if len(data) > 0 {
			structData = make([]*TestAllTypes, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.Ext1 = structData
	}

	{
		var data = m.GetExt2()
		var structData []*TestAllTypes
		if len(data) > 0 {
			structData = make([]*TestAllTypes, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.Ext2 = structData
	}

	return res
}

func (s *TestParsingMerge_RepeatedFieldsGeneratorReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestParsingMerge_RepeatedFieldsGenerator struct {
	Field1	[]*TestAllTypes	`json:"field1,omitempty"`
	Field2	[]*TestAllTypes	`json:"field2,omitempty"`
	Field3	[]*TestAllTypes	`json:"field3,omitempty"`
	Ext1	[]*TestAllTypes	`json:"ext1,omitempty"`
	Ext2	[]*TestAllTypes	`json:"ext2,omitempty"`
}

func (s *TestParsingMerge_RepeatedFieldsGenerator) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestParsingMerge_RepeatedFieldsGenerator) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if len(s.Field1) > 0 {
		for _, entry := range s.Field1 {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireTestParsingMerge_RepeatedFieldsGenerator_Field1, structSize)
			entry.MarshalTo(res)
		}
	}
	if len(s.Field2) > 0 {
		for _, entry := range s.Field2 {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireTestParsingMerge_RepeatedFieldsGenerator_Field2, structSize)
			entry.MarshalTo(res)
		}
	}
	if len(s.Field3) > 0 {
		for _, entry := range s.Field3 {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireTestParsingMerge_RepeatedFieldsGenerator_Field3, structSize)
			entry.MarshalTo(res)
		}
	}
	if len(s.Ext1) > 0 {
		for _, entry := range s.Ext1 {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireTestParsingMerge_RepeatedFieldsGenerator_Ext1, structSize)
			entry.MarshalTo(res)
		}
	}
	if len(s.Ext2) > 0 {
		for _, entry := range s.Ext2 {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireTestParsingMerge_RepeatedFieldsGenerator_Ext2, structSize)
			entry.MarshalTo(res)
		}
	}
}

func (s *TestParsingMerge_RepeatedFieldsGenerator) Copy() *TestParsingMerge_RepeatedFieldsGenerator {
	if s == nil {
		return nil
	}
	res := &TestParsingMerge_RepeatedFieldsGenerator{}
	res.Field1 = make([]*TestAllTypes, len(s.Field1))
	for i := range s.Field1 {
		if s.Field1[i] != nil {
			res.Field1[i] = s.Field1[i].Copy()
		}
	}
	res.Field2 = make([]*TestAllTypes, len(s.Field2))
	for i := range s.Field2 {
		if s.Field2[i] != nil {
			res.Field2[i] = s.Field2[i].Copy()
		}
	}
	res.Field3 = make([]*TestAllTypes, len(s.Field3))
	for i := range s.Field3 {
		if s.Field3[i] != nil {
			res.Field3[i] = s.Field3[i].Copy()
		}
	}
	res.Ext1 = make([]*TestAllTypes, len(s.Ext1))
	for i := range s.Ext1 {
		if s.Ext1[i] != nil {
			res.Ext1[i] = s.Ext1[i].Copy()
		}
	}
	res.Ext2 = make([]*TestAllTypes, len(s.Ext2))
	for i := range s.Ext2 {
		if s.Ext2[i] != nil {
			res.Ext2[i] = s.Ext2[i].Copy()
		}
	}

	return res
}

func (s *TestParsingMerge_RepeatedFieldsGenerator) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if len(s.Field1) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.Field1 {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestParsingMerge_RepeatedFieldsGenerator_Field1)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.Field2) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.Field2 {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestParsingMerge_RepeatedFieldsGenerator_Field2)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.Field3) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.Field3 {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestParsingMerge_RepeatedFieldsGenerator_Field3)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.Ext1) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.Ext1 {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestParsingMerge_RepeatedFieldsGenerator_Ext1)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.Ext2) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.Ext2 {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestParsingMerge_RepeatedFieldsGenerator_Ext2)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	return size
}

const (
	wireTestParsingMerge_TestParsingMerge_OptionalExt gremlin.ProtoWireNumber = 1000
	wireTestParsingMerge_TestParsingMerge_RepeatedExt gremlin.ProtoWireNumber = 1001
	wireTestParsingMerge_TestParsingMerge_RequiredAllTypes gremlin.ProtoWireNumber = 1
	wireTestParsingMerge_TestParsingMerge_OptionalAllTypes gremlin.ProtoWireNumber = 2
	wireTestParsingMerge_TestParsingMerge_RepeatedAllTypes gremlin.ProtoWireNumber = 3
)

type TestParsingMerge_TestParsingMergeReader struct {
	buf *gremlin.Reader

	dataOptionalExt     *TestAllTypesReader
	dataRepeatedExt     []*TestAllTypesReader
	dataRequiredAllTypes     *TestAllTypesReader
	dataOptionalAllTypes     *TestAllTypesReader
	dataRepeatedAllTypes     []*TestAllTypesReader

	offsetOptionalExt   int
	offsetRepeatedExt   []int
	offsetRequiredAllTypes   int
	offsetOptionalAllTypes   int
	offsetRepeatedAllTypes   []int

	parsedOptionalExt   bool
	parsedRepeatedExt   bool
	parsedRequiredAllTypes   bool
	parsedOptionalAllTypes   bool
	parsedRepeatedAllTypes   bool
}

func NewTestParsingMerge_TestParsingMergeReader() *TestParsingMerge_TestParsingMergeReader {
	return &TestParsingMerge_TestParsingMergeReader{}
}

func (m *TestParsingMerge_TestParsingMergeReader) GetOptionalExt() *TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readOptionalExt()
}

func (m *TestParsingMerge_TestParsingMergeReader) readOptionalExt() *TestAllTypesReader {
	if m.parsedOptionalExt {
		return m.dataOptionalExt
	}
	wOffset := m.offsetOptionalExt
	
	var entry *TestAllTypesReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypesReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalExt = entry
	m.parsedOptionalExt = true
	return entry
}

func (m *TestParsingMerge_TestParsingMergeReader) GetRepeatedExt() []*TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readRepeatedExt()
}

func (m *TestParsingMerge_TestParsingMergeReader) readRepeatedExt() []*TestAllTypesReader {
	if m.parsedRepeatedExt {
		return m.dataRepeatedExt
	}
	wOffset := m.offsetRepeatedExt
	
	var entry []*TestAllTypesReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *TestAllTypesReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewTestAllTypesReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedExt = entry
	m.parsedRepeatedExt = true
	return entry
}

func (m *TestParsingMerge_TestParsingMergeReader) GetRequiredAllTypes() *TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readRequiredAllTypes()
}

func (m *TestParsingMerge_TestParsingMergeReader) readRequiredAllTypes() *TestAllTypesReader {
	if m.parsedRequiredAllTypes {
		return m.dataRequiredAllTypes
	}
	wOffset := m.offsetRequiredAllTypes
	
	var entry *TestAllTypesReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypesReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataRequiredAllTypes = entry
	m.parsedRequiredAllTypes = true
	return entry
}

func (m *TestParsingMerge_TestParsingMergeReader) GetOptionalAllTypes() *TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readOptionalAllTypes()
}

func (m *TestParsingMerge_TestParsingMergeReader) readOptionalAllTypes() *TestAllTypesReader {
	if m.parsedOptionalAllTypes {
		return m.dataOptionalAllTypes
	}
	wOffset := m.offsetOptionalAllTypes
	
	var entry *TestAllTypesReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypesReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalAllTypes = entry
	m.parsedOptionalAllTypes = true
	return entry
}

func (m *TestParsingMerge_TestParsingMergeReader) GetRepeatedAllTypes() []*TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readRepeatedAllTypes()
}

func (m *TestParsingMerge_TestParsingMergeReader) readRepeatedAllTypes() []*TestAllTypesReader {
	if m.parsedRepeatedAllTypes {
		return m.dataRepeatedAllTypes
	}
	wOffset := m.offsetRepeatedAllTypes
	
	var entry []*TestAllTypesReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *TestAllTypesReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewTestAllTypesReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataRepeatedAllTypes = entry
	m.parsedRepeatedAllTypes = true
	return entry
}

func (m *TestParsingMerge_TestParsingMergeReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestParsingMerge_TestParsingMerge_OptionalExt:
			m.offsetOptionalExt = offset
		case wireTestParsingMerge_TestParsingMerge_RepeatedExt:
			m.offsetRepeatedExt = append(m.offsetRepeatedExt, offset)
		case wireTestParsingMerge_TestParsingMerge_RequiredAllTypes:
			m.offsetRequiredAllTypes = offset
		case wireTestParsingMerge_TestParsingMerge_OptionalAllTypes:
			m.offsetOptionalAllTypes = offset
		case wireTestParsingMerge_TestParsingMerge_RepeatedAllTypes:
			m.offsetRepeatedAllTypes = append(m.offsetRepeatedAllTypes, offset)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestParsingMerge_TestParsingMergeReader) ToStruct() *TestParsingMerge_TestParsingMerge {
	if m == nil {
		return nil
	}
	res := &TestParsingMerge_TestParsingMerge{}

	{
		var data = m.GetOptionalExt()
		var structData *TestAllTypes
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalExt = structData
	}

	{
		var data = m.GetRepeatedExt()
		var structData []*TestAllTypes
		if len(data) > 0 {
			structData = make([]*TestAllTypes, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.RepeatedExt = structData
	}

	{
		var data = m.GetRequiredAllTypes()
		var structData *TestAllTypes
		if data != nil {
			structData = data.ToStruct()
		}
		res.RequiredAllTypes = structData
	}

	{
		var data = m.GetOptionalAllTypes()
		var structData *TestAllTypes
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalAllTypes = structData
	}

	{
		var data = m.GetRepeatedAllTypes()
		var structData []*TestAllTypes
		if len(data) > 0 {
			structData = make([]*TestAllTypes, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.RepeatedAllTypes = structData
	}

	return res
}

func (s *TestParsingMerge_TestParsingMergeReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestParsingMerge_TestParsingMerge struct {
	OptionalExt	*TestAllTypes	`json:"optional_ext,omitempty"`
	RepeatedExt	[]*TestAllTypes	`json:"repeated_ext,omitempty"`
	RequiredAllTypes	*TestAllTypes	`json:"required_all_types,omitempty"`
	OptionalAllTypes	*TestAllTypes	`json:"optional_all_types,omitempty"`
	RepeatedAllTypes	[]*TestAllTypes	`json:"repeated_all_types,omitempty"`
}

func (s *TestParsingMerge_TestParsingMerge) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestParsingMerge_TestParsingMerge) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.OptionalExt != nil {
		structSize := s.OptionalExt.XXX_PbContentSize()
		res.AppendBytesTag(wireTestParsingMerge_TestParsingMerge_OptionalExt, structSize)
		s.OptionalExt.MarshalTo(res)
	}
	if len(s.RepeatedExt) > 0 {
		for _, entry := range s.RepeatedExt {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireTestParsingMerge_TestParsingMerge_RepeatedExt, structSize)
			entry.MarshalTo(res)
		}
	}
	if true {
		structSize := s.RequiredAllTypes.XXX_PbContentSize()
		res.AppendBytesTag(wireTestParsingMerge_TestParsingMerge_RequiredAllTypes, structSize)
		s.RequiredAllTypes.MarshalTo(res)
	}
	if s.OptionalAllTypes != nil {
		structSize := s.OptionalAllTypes.XXX_PbContentSize()
		res.AppendBytesTag(wireTestParsingMerge_TestParsingMerge_OptionalAllTypes, structSize)
		s.OptionalAllTypes.MarshalTo(res)
	}
	if len(s.RepeatedAllTypes) > 0 {
		for _, entry := range s.RepeatedAllTypes {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireTestParsingMerge_TestParsingMerge_RepeatedAllTypes, structSize)
			entry.MarshalTo(res)
		}
	}
}

func (s *TestParsingMerge_TestParsingMerge) Copy() *TestParsingMerge_TestParsingMerge {
	if s == nil {
		return nil
	}
	res := &TestParsingMerge_TestParsingMerge{}
	if s.OptionalExt != nil {
		res.OptionalExt = s.OptionalExt.Copy()
	}
	res.RepeatedExt = make([]*TestAllTypes, len(s.RepeatedExt))
	for i := range s.RepeatedExt {
		if s.RepeatedExt[i] != nil {
			res.RepeatedExt[i] = s.RepeatedExt[i].Copy()
		}
	}
	if s.RequiredAllTypes != nil {
		res.RequiredAllTypes = s.RequiredAllTypes.Copy()
	}
	if s.OptionalAllTypes != nil {
		res.OptionalAllTypes = s.OptionalAllTypes.Copy()
	}
	res.RepeatedAllTypes = make([]*TestAllTypes, len(s.RepeatedAllTypes))
	for i := range s.RepeatedAllTypes {
		if s.RepeatedAllTypes[i] != nil {
			res.RepeatedAllTypes[i] = s.RepeatedAllTypes[i].Copy()
		}
	}

	return res
}

func (s *TestParsingMerge_TestParsingMerge) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.OptionalExt != nil {
		var entrySize = 0
		entrySize = s.OptionalExt.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestParsingMerge_TestParsingMerge_OptionalExt)
		
		size += entrySize
	}

	if len(s.RepeatedExt) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedExt {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestParsingMerge_TestParsingMerge_RepeatedExt)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if true {
		var entrySize = 0
		entrySize = s.RequiredAllTypes.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestParsingMerge_TestParsingMerge_RequiredAllTypes)
		
		size += entrySize
	}

	if s.OptionalAllTypes != nil {
		var entrySize = 0
		entrySize = s.OptionalAllTypes.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestParsingMerge_TestParsingMerge_OptionalAllTypes)
		
		size += entrySize
	}

	if len(s.RepeatedAllTypes) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.RepeatedAllTypes {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireTestParsingMerge_TestParsingMerge_RepeatedAllTypes)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	return size
}

const (
	wireTestMergeException_AllExtensions gremlin.ProtoWireNumber = 1
)

type TestMergeExceptionReader struct {
	buf *gremlin.Reader

	dataAllExtensions     *TestAllExtensionsReader

	offsetAllExtensions   int

	parsedAllExtensions   bool
}

func NewTestMergeExceptionReader() *TestMergeExceptionReader {
	return &TestMergeExceptionReader{}
}

func (m *TestMergeExceptionReader) GetAllExtensions() *TestAllExtensionsReader {
	if m == nil {
		return nil
	}
	return m.readAllExtensions()
}

func (m *TestMergeExceptionReader) readAllExtensions() *TestAllExtensionsReader {
	if m.parsedAllExtensions {
		return m.dataAllExtensions
	}
	wOffset := m.offsetAllExtensions
	
	var entry *TestAllExtensionsReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllExtensionsReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataAllExtensions = entry
	m.parsedAllExtensions = true
	return entry
}

func (m *TestMergeExceptionReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestMergeException_AllExtensions:
			m.offsetAllExtensions = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestMergeExceptionReader) ToStruct() *TestMergeException {
	if m == nil {
		return nil
	}
	res := &TestMergeException{}

	{
		var data = m.GetAllExtensions()
		var structData *TestAllExtensions
		if data != nil {
			structData = data.ToStruct()
		}
		res.AllExtensions = structData
	}

	return res
}

func (s *TestMergeExceptionReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestMergeException struct {
	AllExtensions	*TestAllExtensions	`json:"all_extensions,omitempty"`
}

func (s *TestMergeException) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestMergeException) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.AllExtensions != nil {
		structSize := s.AllExtensions.XXX_PbContentSize()
		res.AppendBytesTag(wireTestMergeException_AllExtensions, structSize)
		s.AllExtensions.MarshalTo(res)
	}
}

func (s *TestMergeException) Copy() *TestMergeException {
	if s == nil {
		return nil
	}
	res := &TestMergeException{}
	if s.AllExtensions != nil {
		res.AllExtensions = s.AllExtensions.Copy()
	}

	return res
}

func (s *TestMergeException) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.AllExtensions != nil {
		var entrySize = 0
		entrySize = s.AllExtensions.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestMergeException_AllExtensions)
		
		size += entrySize
	}

	return size
}

const (
	wireTestCommentInjectionMessage_A gremlin.ProtoWireNumber = 1
)

type TestCommentInjectionMessageReader struct {
	buf *gremlin.Reader

	dataA     string

	offsetA   int

	parsedA   bool
}

func NewTestCommentInjectionMessageReader() *TestCommentInjectionMessageReader {
	return &TestCommentInjectionMessageReader{}
}

func (m *TestCommentInjectionMessageReader) GetA() string {
	if m == nil {
		return "*/ <- Neither should this."
	}
	return m.readA()
}

func (m *TestCommentInjectionMessageReader) readA() string {
	if m.parsedA {
		return m.dataA
	}
	wOffset := m.offsetA
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	} else {
		entry = "*/ <- Neither should this."
	}
	
	m.dataA = entry
	m.parsedA = true
	return entry
}

func (m *TestCommentInjectionMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestCommentInjectionMessage_A:
			m.offsetA = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestCommentInjectionMessageReader) ToStruct() *TestCommentInjectionMessage {
	if m == nil {
		return nil
	}
	res := &TestCommentInjectionMessage{}
	res.A = m.GetA()

	return res
}

func (s *TestCommentInjectionMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestCommentInjectionMessage struct {
	A	string	`json:"a,omitempty"`
}

func (s *TestCommentInjectionMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestCommentInjectionMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.A != "*/ <- Neither should this." {
		res.AppendString(wireTestCommentInjectionMessage_A, s.A)
	}
}

func (s *TestCommentInjectionMessage) Copy() *TestCommentInjectionMessage {
	if s == nil {
		return nil
	}
	res := &TestCommentInjectionMessage{}
	res.A = s.A

	return res
}

func (s *TestCommentInjectionMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.A != "*/ <- Neither should this." {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.A)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestCommentInjectionMessage_A)
		size += entrySize
	}

	return size
}

const (
	wireTestMessageSize_M1 gremlin.ProtoWireNumber = 1
	wireTestMessageSize_M2 gremlin.ProtoWireNumber = 2
	wireTestMessageSize_M3 gremlin.ProtoWireNumber = 3
	wireTestMessageSize_M4 gremlin.ProtoWireNumber = 4
	wireTestMessageSize_M5 gremlin.ProtoWireNumber = 5
	wireTestMessageSize_M6 gremlin.ProtoWireNumber = 6
)

type TestMessageSizeReader struct {
	buf *gremlin.Reader

	dataM1     bool
	dataM2     int64
	dataM3     bool
	dataM4     string
	dataM5     int32
	dataM6     int64

	offsetM1   int
	offsetM2   int
	offsetM3   int
	offsetM4   int
	offsetM5   int
	offsetM6   int

	parsedM1   bool
	parsedM2   bool
	parsedM3   bool
	parsedM4   bool
	parsedM5   bool
	parsedM6   bool
}

func NewTestMessageSizeReader() *TestMessageSizeReader {
	return &TestMessageSizeReader{}
}

func (m *TestMessageSizeReader) GetM1() bool {
	if m == nil {
		return false
	}
	return m.readM1()
}

func (m *TestMessageSizeReader) readM1() bool {
	if m.parsedM1 {
		return m.dataM1
	}
	wOffset := m.offsetM1
	
	var entry bool
	if wOffset > 0 {
		entry = m.buf.ReadBool(wOffset)
	}
	
	m.dataM1 = entry
	m.parsedM1 = true
	return entry
}

func (m *TestMessageSizeReader) GetM2() int64 {
	if m == nil {
		return 0
	}
	return m.readM2()
}

func (m *TestMessageSizeReader) readM2() int64 {
	if m.parsedM2 {
		return m.dataM2
	}
	wOffset := m.offsetM2
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadInt64(wOffset)
	}
	
	m.dataM2 = entry
	m.parsedM2 = true
	return entry
}

func (m *TestMessageSizeReader) GetM3() bool {
	if m == nil {
		return false
	}
	return m.readM3()
}

func (m *TestMessageSizeReader) readM3() bool {
	if m.parsedM3 {
		return m.dataM3
	}
	wOffset := m.offsetM3
	
	var entry bool
	if wOffset > 0 {
		entry = m.buf.ReadBool(wOffset)
	}
	
	m.dataM3 = entry
	m.parsedM3 = true
	return entry
}

func (m *TestMessageSizeReader) GetM4() string {
	if m == nil {
		return ""
	}
	return m.readM4()
}

func (m *TestMessageSizeReader) readM4() string {
	if m.parsedM4 {
		return m.dataM4
	}
	wOffset := m.offsetM4
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataM4 = entry
	m.parsedM4 = true
	return entry
}

func (m *TestMessageSizeReader) GetM5() int32 {
	if m == nil {
		return 0
	}
	return m.readM5()
}

func (m *TestMessageSizeReader) readM5() int32 {
	if m.parsedM5 {
		return m.dataM5
	}
	wOffset := m.offsetM5
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataM5 = entry
	m.parsedM5 = true
	return entry
}

func (m *TestMessageSizeReader) GetM6() int64 {
	if m == nil {
		return 0
	}
	return m.readM6()
}

func (m *TestMessageSizeReader) readM6() int64 {
	if m.parsedM6 {
		return m.dataM6
	}
	wOffset := m.offsetM6
	
	var entry int64
	if wOffset > 0 {
		entry = m.buf.ReadInt64(wOffset)
	}
	
	m.dataM6 = entry
	m.parsedM6 = true
	return entry
}

func (m *TestMessageSizeReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestMessageSize_M1:
			m.offsetM1 = offset
		case wireTestMessageSize_M2:
			m.offsetM2 = offset
		case wireTestMessageSize_M3:
			m.offsetM3 = offset
		case wireTestMessageSize_M4:
			m.offsetM4 = offset
		case wireTestMessageSize_M5:
			m.offsetM5 = offset
		case wireTestMessageSize_M6:
			m.offsetM6 = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestMessageSizeReader) ToStruct() *TestMessageSize {
	if m == nil {
		return nil
	}
	res := &TestMessageSize{}
	res.M1 = m.GetM1()
	res.M2 = m.GetM2()
	res.M3 = m.GetM3()
	res.M4 = m.GetM4()
	res.M5 = m.GetM5()
	res.M6 = m.GetM6()

	return res
}

func (s *TestMessageSizeReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestMessageSize struct {
	M1	bool	`json:"m1,omitempty"`
	M2	int64	`json:"m2,omitempty"`
	M3	bool	`json:"m3,omitempty"`
	M4	string	`json:"m4,omitempty"`
	M5	int32	`json:"m5,omitempty"`
	M6	int64	`json:"m6,omitempty"`
}

func (s *TestMessageSize) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestMessageSize) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.M1 {
		res.AppendBool(wireTestMessageSize_M1, s.M1)
	}
	if s.M2 != 0 {
		res.AppendInt64(wireTestMessageSize_M2, s.M2)
	}
	if s.M3 {
		res.AppendBool(wireTestMessageSize_M3, s.M3)
	}
	if s.M4 != "" {
		res.AppendString(wireTestMessageSize_M4, s.M4)
	}
	if s.M5 != 0 {
		res.AppendInt32(wireTestMessageSize_M5, s.M5)
	}
	if s.M6 != 0 {
		res.AppendInt64(wireTestMessageSize_M6, s.M6)
	}
}

func (s *TestMessageSize) Copy() *TestMessageSize {
	if s == nil {
		return nil
	}
	res := &TestMessageSize{}
	res.M1 = s.M1
	res.M2 = s.M2
	res.M3 = s.M3
	res.M4 = s.M4
	res.M5 = s.M5
	res.M6 = s.M6

	return res
}

func (s *TestMessageSize) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.M1 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestMessageSize_M1) + gremlin.SizeBool(s.M1)
		size += entrySize
	}

	if s.M2 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestMessageSize_M2) + gremlin.SizeInt64(s.M2)
		size += entrySize
	}

	if s.M3 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestMessageSize_M3) + gremlin.SizeBool(s.M3)
		size += entrySize
	}

	if s.M4 != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.M4)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestMessageSize_M4)
		size += entrySize
	}

	if s.M5 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestMessageSize_M5) + gremlin.SizeInt32(s.M5)
		size += entrySize
	}

	if s.M6 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestMessageSize_M6) + gremlin.SizeInt64(s.M6)
		size += entrySize
	}

	return size
}

const (
)

type FooRequestReader struct {
	buf *gremlin.Reader



}

func NewFooRequestReader() *FooRequestReader {
	return &FooRequestReader{}
}

func (m *FooRequestReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *FooRequestReader) ToStruct() *FooRequest {
	if m == nil {
		return nil
	}
	res := &FooRequest{}

	return res
}

func (s *FooRequestReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type FooRequest struct {
}

func (s *FooRequest) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *FooRequest) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

}

func (s *FooRequest) Copy() *FooRequest {
	if s == nil {
		return nil
	}
	res := &FooRequest{}

	return res
}

func (s *FooRequest) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	return size
}

const (
)

type FooResponseReader struct {
	buf *gremlin.Reader



}

func NewFooResponseReader() *FooResponseReader {
	return &FooResponseReader{}
}

func (m *FooResponseReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *FooResponseReader) ToStruct() *FooResponse {
	if m == nil {
		return nil
	}
	res := &FooResponse{}

	return res
}

func (s *FooResponseReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type FooResponse struct {
}

func (s *FooResponse) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *FooResponse) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

}

func (s *FooResponse) Copy() *FooResponse {
	if s == nil {
		return nil
	}
	res := &FooResponse{}

	return res
}

func (s *FooResponse) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	return size
}

const (
)

type FooClientMessageReader struct {
	buf *gremlin.Reader



}

func NewFooClientMessageReader() *FooClientMessageReader {
	return &FooClientMessageReader{}
}

func (m *FooClientMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *FooClientMessageReader) ToStruct() *FooClientMessage {
	if m == nil {
		return nil
	}
	res := &FooClientMessage{}

	return res
}

func (s *FooClientMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type FooClientMessage struct {
}

func (s *FooClientMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *FooClientMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

}

func (s *FooClientMessage) Copy() *FooClientMessage {
	if s == nil {
		return nil
	}
	res := &FooClientMessage{}

	return res
}

func (s *FooClientMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	return size
}

const (
)

type FooServerMessageReader struct {
	buf *gremlin.Reader



}

func NewFooServerMessageReader() *FooServerMessageReader {
	return &FooServerMessageReader{}
}

func (m *FooServerMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *FooServerMessageReader) ToStruct() *FooServerMessage {
	if m == nil {
		return nil
	}
	res := &FooServerMessage{}

	return res
}

func (s *FooServerMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type FooServerMessage struct {
}

func (s *FooServerMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *FooServerMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

}

func (s *FooServerMessage) Copy() *FooServerMessage {
	if s == nil {
		return nil
	}
	res := &FooServerMessage{}

	return res
}

func (s *FooServerMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	return size
}

const (
)

type BarRequestReader struct {
	buf *gremlin.Reader



}

func NewBarRequestReader() *BarRequestReader {
	return &BarRequestReader{}
}

func (m *BarRequestReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *BarRequestReader) ToStruct() *BarRequest {
	if m == nil {
		return nil
	}
	res := &BarRequest{}

	return res
}

func (s *BarRequestReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type BarRequest struct {
}

func (s *BarRequest) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *BarRequest) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

}

func (s *BarRequest) Copy() *BarRequest {
	if s == nil {
		return nil
	}
	res := &BarRequest{}

	return res
}

func (s *BarRequest) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	return size
}

const (
)

type BarResponseReader struct {
	buf *gremlin.Reader



}

func NewBarResponseReader() *BarResponseReader {
	return &BarResponseReader{}
}

func (m *BarResponseReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *BarResponseReader) ToStruct() *BarResponse {
	if m == nil {
		return nil
	}
	res := &BarResponse{}

	return res
}

func (s *BarResponseReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type BarResponse struct {
}

func (s *BarResponse) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *BarResponse) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

}

func (s *BarResponse) Copy() *BarResponse {
	if s == nil {
		return nil
	}
	res := &BarResponse{}

	return res
}

func (s *BarResponse) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	return size
}

const (
	wireTestJsonName_FieldName1 gremlin.ProtoWireNumber = 1
	wireTestJsonName_FieldName2 gremlin.ProtoWireNumber = 2
	wireTestJsonName_FieldName3 gremlin.ProtoWireNumber = 3
	wireTestJsonName_FieldName4 gremlin.ProtoWireNumber = 4
	wireTestJsonName_FIELDNAME5 gremlin.ProtoWireNumber = 5
	wireTestJsonName_FieldName6 gremlin.ProtoWireNumber = 6
	wireTestJsonName_Fieldname7 gremlin.ProtoWireNumber = 7
)

type TestJsonNameReader struct {
	buf *gremlin.Reader

	dataFieldName1     int32
	dataFieldName2     int32
	dataFieldName3     int32
	dataFieldName4     int32
	dataFIELDNAME5     int32
	dataFieldName6     int32
	dataFieldname7     int32

	offsetFieldName1   int
	offsetFieldName2   int
	offsetFieldName3   int
	offsetFieldName4   int
	offsetFIELDNAME5   int
	offsetFieldName6   int
	offsetFieldname7   int

	parsedFieldName1   bool
	parsedFieldName2   bool
	parsedFieldName3   bool
	parsedFieldName4   bool
	parsedFIELDNAME5   bool
	parsedFieldName6   bool
	parsedFieldname7   bool
}

func NewTestJsonNameReader() *TestJsonNameReader {
	return &TestJsonNameReader{}
}

func (m *TestJsonNameReader) GetFieldName1() int32 {
	if m == nil {
		return 0
	}
	return m.readFieldName1()
}

func (m *TestJsonNameReader) readFieldName1() int32 {
	if m.parsedFieldName1 {
		return m.dataFieldName1
	}
	wOffset := m.offsetFieldName1
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataFieldName1 = entry
	m.parsedFieldName1 = true
	return entry
}

func (m *TestJsonNameReader) GetFieldName2() int32 {
	if m == nil {
		return 0
	}
	return m.readFieldName2()
}

func (m *TestJsonNameReader) readFieldName2() int32 {
	if m.parsedFieldName2 {
		return m.dataFieldName2
	}
	wOffset := m.offsetFieldName2
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataFieldName2 = entry
	m.parsedFieldName2 = true
	return entry
}

func (m *TestJsonNameReader) GetFieldName3() int32 {
	if m == nil {
		return 0
	}
	return m.readFieldName3()
}

func (m *TestJsonNameReader) readFieldName3() int32 {
	if m.parsedFieldName3 {
		return m.dataFieldName3
	}
	wOffset := m.offsetFieldName3
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataFieldName3 = entry
	m.parsedFieldName3 = true
	return entry
}

func (m *TestJsonNameReader) GetFieldName4() int32 {
	if m == nil {
		return 0
	}
	return m.readFieldName4()
}

func (m *TestJsonNameReader) readFieldName4() int32 {
	if m.parsedFieldName4 {
		return m.dataFieldName4
	}
	wOffset := m.offsetFieldName4
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataFieldName4 = entry
	m.parsedFieldName4 = true
	return entry
}

func (m *TestJsonNameReader) GetFIELDNAME5() int32 {
	if m == nil {
		return 0
	}
	return m.readFIELDNAME5()
}

func (m *TestJsonNameReader) readFIELDNAME5() int32 {
	if m.parsedFIELDNAME5 {
		return m.dataFIELDNAME5
	}
	wOffset := m.offsetFIELDNAME5
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataFIELDNAME5 = entry
	m.parsedFIELDNAME5 = true
	return entry
}

func (m *TestJsonNameReader) GetFieldName6() int32 {
	if m == nil {
		return 0
	}
	return m.readFieldName6()
}

func (m *TestJsonNameReader) readFieldName6() int32 {
	if m.parsedFieldName6 {
		return m.dataFieldName6
	}
	wOffset := m.offsetFieldName6
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataFieldName6 = entry
	m.parsedFieldName6 = true
	return entry
}

func (m *TestJsonNameReader) GetFieldname7() int32 {
	if m == nil {
		return 0
	}
	return m.readFieldname7()
}

func (m *TestJsonNameReader) readFieldname7() int32 {
	if m.parsedFieldname7 {
		return m.dataFieldname7
	}
	wOffset := m.offsetFieldname7
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataFieldname7 = entry
	m.parsedFieldname7 = true
	return entry
}

func (m *TestJsonNameReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestJsonName_FieldName1:
			m.offsetFieldName1 = offset
		case wireTestJsonName_FieldName2:
			m.offsetFieldName2 = offset
		case wireTestJsonName_FieldName3:
			m.offsetFieldName3 = offset
		case wireTestJsonName_FieldName4:
			m.offsetFieldName4 = offset
		case wireTestJsonName_FIELDNAME5:
			m.offsetFIELDNAME5 = offset
		case wireTestJsonName_FieldName6:
			m.offsetFieldName6 = offset
		case wireTestJsonName_Fieldname7:
			m.offsetFieldname7 = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestJsonNameReader) ToStruct() *TestJsonName {
	if m == nil {
		return nil
	}
	res := &TestJsonName{}
	res.FieldName1 = m.GetFieldName1()
	res.FieldName2 = m.GetFieldName2()
	res.FieldName3 = m.GetFieldName3()
	res.FieldName4 = m.GetFieldName4()
	res.FIELDNAME5 = m.GetFIELDNAME5()
	res.FieldName6 = m.GetFieldName6()
	res.Fieldname7 = m.GetFieldname7()

	return res
}

func (s *TestJsonNameReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestJsonName struct {
	FieldName1	int32	`json:"field_name1,omitempty"`
	FieldName2	int32	`json:"fieldName2,omitempty"`
	FieldName3	int32	`json:"FieldName3,omitempty"`
	FieldName4	int32	`json:"_field_name4,omitempty"`
	FIELDNAME5	int32	`json:"FIELD_NAME5,omitempty"`
	FieldName6	int32	`json:"field_name6,omitempty"`
	Fieldname7	int32	`json:"fieldname7,omitempty"`
}

func (s *TestJsonName) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestJsonName) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.FieldName1 != 0 {
		res.AppendInt32(wireTestJsonName_FieldName1, s.FieldName1)
	}
	if s.FieldName2 != 0 {
		res.AppendInt32(wireTestJsonName_FieldName2, s.FieldName2)
	}
	if s.FieldName3 != 0 {
		res.AppendInt32(wireTestJsonName_FieldName3, s.FieldName3)
	}
	if s.FieldName4 != 0 {
		res.AppendInt32(wireTestJsonName_FieldName4, s.FieldName4)
	}
	if s.FIELDNAME5 != 0 {
		res.AppendInt32(wireTestJsonName_FIELDNAME5, s.FIELDNAME5)
	}
	if s.FieldName6 != 0 {
		res.AppendInt32(wireTestJsonName_FieldName6, s.FieldName6)
	}
	if s.Fieldname7 != 0 {
		res.AppendInt32(wireTestJsonName_Fieldname7, s.Fieldname7)
	}
}

func (s *TestJsonName) Copy() *TestJsonName {
	if s == nil {
		return nil
	}
	res := &TestJsonName{}
	res.FieldName1 = s.FieldName1
	res.FieldName2 = s.FieldName2
	res.FieldName3 = s.FieldName3
	res.FieldName4 = s.FieldName4
	res.FIELDNAME5 = s.FIELDNAME5
	res.FieldName6 = s.FieldName6
	res.Fieldname7 = s.Fieldname7

	return res
}

func (s *TestJsonName) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.FieldName1 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestJsonName_FieldName1) + gremlin.SizeInt32(s.FieldName1)
		size += entrySize
	}

	if s.FieldName2 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestJsonName_FieldName2) + gremlin.SizeInt32(s.FieldName2)
		size += entrySize
	}

	if s.FieldName3 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestJsonName_FieldName3) + gremlin.SizeInt32(s.FieldName3)
		size += entrySize
	}

	if s.FieldName4 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestJsonName_FieldName4) + gremlin.SizeInt32(s.FieldName4)
		size += entrySize
	}

	if s.FIELDNAME5 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestJsonName_FIELDNAME5) + gremlin.SizeInt32(s.FIELDNAME5)
		size += entrySize
	}

	if s.FieldName6 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestJsonName_FieldName6) + gremlin.SizeInt32(s.FieldName6)
		size += entrySize
	}

	if s.Fieldname7 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestJsonName_Fieldname7) + gremlin.SizeInt32(s.Fieldname7)
		size += entrySize
	}

	return size
}

const (
	wireTestHugeFieldNumbers_TestAllTypes gremlin.ProtoWireNumber = 536860000
	wireTestHugeFieldNumbers_OptionalInt32 gremlin.ProtoWireNumber = 536870000
	wireTestHugeFieldNumbers_Fixed32 gremlin.ProtoWireNumber = 536870001
	wireTestHugeFieldNumbers_RepeatedInt32 gremlin.ProtoWireNumber = 536870002
	wireTestHugeFieldNumbers_PackedInt32 gremlin.ProtoWireNumber = 536870003
	wireTestHugeFieldNumbers_OptionalEnum gremlin.ProtoWireNumber = 536870004
	wireTestHugeFieldNumbers_OptionalString gremlin.ProtoWireNumber = 536870005
	wireTestHugeFieldNumbers_OptionalBytes gremlin.ProtoWireNumber = 536870006
	wireTestHugeFieldNumbers_OptionalMessage gremlin.ProtoWireNumber = 536870007
	wireTestHugeFieldNumbers_StringStringMap gremlin.ProtoWireNumber = 536870010
	wireTestHugeFieldNumbers_OneofUint32 gremlin.ProtoWireNumber = 536870011
	wireTestHugeFieldNumbers_OneofTestAllTypes gremlin.ProtoWireNumber = 536870012
	wireTestHugeFieldNumbers_OneofString gremlin.ProtoWireNumber = 536870013
	wireTestHugeFieldNumbers_OneofBytes gremlin.ProtoWireNumber = 536870014
)

type TestHugeFieldNumbersReader struct {
	buf *gremlin.Reader

	dataTestAllTypes     *TestAllTypesReader
	dataOptionalInt32     int32
	dataFixed32     int32
	dataRepeatedInt32     []int32
	dataPackedInt32     []int32
	dataOptionalEnum     ForeignEnum
	dataOptionalString     string
	dataOptionalBytes     []byte
	dataOptionalMessage     *ForeignMessageReader
	dataStringStringMap     map[string]string
	dataOneofUint32     uint32
	dataOneofTestAllTypes     *TestAllTypesReader
	dataOneofString     string
	dataOneofBytes     []byte

	offsetTestAllTypes   int
	offsetOptionalInt32   int
	offsetFixed32   int
	offsetRepeatedInt32   []int
	wireTypeRepeatedInt32 []gremlin.ProtoWireType
	offsetPackedInt32   []int
	wireTypePackedInt32 []gremlin.ProtoWireType
	offsetOptionalEnum   int
	offsetOptionalString   int
	offsetOptionalBytes   int
	offsetOptionalMessage   int
	offsetStringStringMap   []int
	offsetOneofUint32   int
	offsetOneofTestAllTypes   int
	offsetOneofString   int
	offsetOneofBytes   int

	parsedTestAllTypes   bool
	parsedOptionalInt32   bool
	parsedFixed32   bool
	parsedRepeatedInt32   bool
	parsedPackedInt32   bool
	parsedOptionalEnum   bool
	parsedOptionalString   bool
	parsedOptionalBytes   bool
	parsedOptionalMessage   bool
	parsedStringStringMap   bool
	parsedOneofUint32   bool
	parsedOneofTestAllTypes   bool
	parsedOneofString   bool
	parsedOneofBytes   bool
}

func NewTestHugeFieldNumbersReader() *TestHugeFieldNumbersReader {
	return &TestHugeFieldNumbersReader{}
}

func (m *TestHugeFieldNumbersReader) GetTestAllTypes() *TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readTestAllTypes()
}

func (m *TestHugeFieldNumbersReader) readTestAllTypes() *TestAllTypesReader {
	if m.parsedTestAllTypes {
		return m.dataTestAllTypes
	}
	wOffset := m.offsetTestAllTypes
	
	var entry *TestAllTypesReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypesReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataTestAllTypes = entry
	m.parsedTestAllTypes = true
	return entry
}

func (m *TestHugeFieldNumbersReader) GetOptionalInt32() int32 {
	if m == nil {
		return 0
	}
	return m.readOptionalInt32()
}

func (m *TestHugeFieldNumbersReader) readOptionalInt32() int32 {
	if m.parsedOptionalInt32 {
		return m.dataOptionalInt32
	}
	wOffset := m.offsetOptionalInt32
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataOptionalInt32 = entry
	m.parsedOptionalInt32 = true
	return entry
}

func (m *TestHugeFieldNumbersReader) GetFixed32() int32 {
	if m == nil {
		return 0
	}
	return m.readFixed32()
}

func (m *TestHugeFieldNumbersReader) readFixed32() int32 {
	if m.parsedFixed32 {
		return m.dataFixed32
	}
	wOffset := m.offsetFixed32
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataFixed32 = entry
	m.parsedFixed32 = true
	return entry
}

func (m *TestHugeFieldNumbersReader) GetRepeatedInt32() []int32 {
	if m == nil {
		return nil
	}
	return m.readRepeatedInt32()
}

func (m *TestHugeFieldNumbersReader) readRepeatedInt32() []int32 {
	if m.parsedRepeatedInt32 {
		return m.dataRepeatedInt32
	}
	wOffset := m.offsetRepeatedInt32
	var wType = m.wireTypeRepeatedInt32
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadInt32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataRepeatedInt32 = entry
	m.parsedRepeatedInt32 = true
	return entry
}

func (m *TestHugeFieldNumbersReader) GetPackedInt32() []int32 {
	if m == nil {
		return nil
	}
	return m.readPackedInt32()
}

func (m *TestHugeFieldNumbersReader) readPackedInt32() []int32 {
	if m.parsedPackedInt32 {
		return m.dataPackedInt32
	}
	wOffset := m.offsetPackedInt32
	var wType = m.wireTypePackedInt32
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadInt32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataPackedInt32 = entry
	m.parsedPackedInt32 = true
	return entry
}

func (m *TestHugeFieldNumbersReader) GetOptionalEnum() ForeignEnum {
	if m == nil {
		return 0
	}
	return m.readOptionalEnum()
}

func (m *TestHugeFieldNumbersReader) readOptionalEnum() ForeignEnum {
	if m.parsedOptionalEnum {
		return m.dataOptionalEnum
	}
	wOffset := m.offsetOptionalEnum
	
	var entry ForeignEnum
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = ForeignEnum(rawEntry)
	} else {
		entry = 0
	}
	
	m.dataOptionalEnum = entry
	m.parsedOptionalEnum = true
	return entry
}

func (m *TestHugeFieldNumbersReader) GetOptionalString() string {
	if m == nil {
		return ""
	}
	return m.readOptionalString()
}

func (m *TestHugeFieldNumbersReader) readOptionalString() string {
	if m.parsedOptionalString {
		return m.dataOptionalString
	}
	wOffset := m.offsetOptionalString
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataOptionalString = entry
	m.parsedOptionalString = true
	return entry
}

func (m *TestHugeFieldNumbersReader) GetOptionalBytes() []byte {
	if m == nil {
		return nil
	}
	return m.readOptionalBytes()
}

func (m *TestHugeFieldNumbersReader) readOptionalBytes() []byte {
	if m.parsedOptionalBytes {
		return m.dataOptionalBytes
	}
	wOffset := m.offsetOptionalBytes
	
	var entry []byte
	if wOffset > 0 {
		entry = m.buf.ReadBytes(wOffset)
	}
	
	m.dataOptionalBytes = entry
	m.parsedOptionalBytes = true
	return entry
}

func (m *TestHugeFieldNumbersReader) GetOptionalMessage() *ForeignMessageReader {
	if m == nil {
		return nil
	}
	return m.readOptionalMessage()
}

func (m *TestHugeFieldNumbersReader) readOptionalMessage() *ForeignMessageReader {
	if m.parsedOptionalMessage {
		return m.dataOptionalMessage
	}
	wOffset := m.offsetOptionalMessage
	
	var entry *ForeignMessageReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewForeignMessageReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOptionalMessage = entry
	m.parsedOptionalMessage = true
	return entry
}

func (m *TestHugeFieldNumbersReader) GetStringStringMap() map[string]string {
	if m == nil {
		return nil
	}
	return m.readStringStringMap()
}

func (m *TestHugeFieldNumbersReader) readStringStringMap() map[string]string {
	if m.parsedStringStringMap {
		return m.dataStringStringMap
	}
	wOffset := m.offsetStringStringMap
	
	var entry = map[string]string{}
	for i := range wOffset {
		wOffset := wOffset[i]
	
		entrySize, entrySizeSize := m.buf.SizedReadVarInt(wOffset)
		endOffset := wOffset + entrySizeSize + int(entrySize)
		wOffset += entrySizeSize
		
		var keyData string
		var valueData string
		for wOffset < endOffset {
			tag, wireType, tagSize, _ := m.buf.ReadTagAt(wOffset)
			wOffset += tagSize
			if tag == 1 {
				
				var keyEntry string
				var keyEntrySize int
				if wOffset > 0 {
					keyEntry, keyEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += keyEntrySize
				keyData = keyEntry
			} else if tag == 2 {
				
				var valueEntry string
				var valueEntrySize int
				if wOffset > 0 {
					valueEntry, valueEntrySize = m.buf.SizedReadString(wOffset)
				}
				
				wOffset += valueEntrySize
				valueData = valueEntry
			} else {
				wOffset, _ = m.buf.SkipData(wOffset, wireType)
			}
		}
		entry[keyData] = valueData
	}
	
	m.dataStringStringMap = entry
	m.parsedStringStringMap = true
	return entry
}

func (m *TestHugeFieldNumbersReader) GetOneofUint32() uint32 {
	if m == nil {
		return 0
	}
	return m.readOneofUint32()
}

func (m *TestHugeFieldNumbersReader) readOneofUint32() uint32 {
	if m.parsedOneofUint32 {
		return m.dataOneofUint32
	}
	wOffset := m.offsetOneofUint32
	
	var entry uint32
	if wOffset > 0 {
		entry = m.buf.ReadUint32(wOffset)
	}
	
	m.dataOneofUint32 = entry
	m.parsedOneofUint32 = true
	return entry
}

func (m *TestHugeFieldNumbersReader) GetOneofTestAllTypes() *TestAllTypesReader {
	if m == nil {
		return nil
	}
	return m.readOneofTestAllTypes()
}

func (m *TestHugeFieldNumbersReader) readOneofTestAllTypes() *TestAllTypesReader {
	if m.parsedOneofTestAllTypes {
		return m.dataOneofTestAllTypes
	}
	wOffset := m.offsetOneofTestAllTypes
	
	var entry *TestAllTypesReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewTestAllTypesReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOneofTestAllTypes = entry
	m.parsedOneofTestAllTypes = true
	return entry
}

func (m *TestHugeFieldNumbersReader) GetOneofString() string {
	if m == nil {
		return ""
	}
	return m.readOneofString()
}

func (m *TestHugeFieldNumbersReader) readOneofString() string {
	if m.parsedOneofString {
		return m.dataOneofString
	}
	wOffset := m.offsetOneofString
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataOneofString = entry
	m.parsedOneofString = true
	return entry
}

func (m *TestHugeFieldNumbersReader) GetOneofBytes() []byte {
	if m == nil {
		return nil
	}
	return m.readOneofBytes()
}

func (m *TestHugeFieldNumbersReader) readOneofBytes() []byte {
	if m.parsedOneofBytes {
		return m.dataOneofBytes
	}
	wOffset := m.offsetOneofBytes
	
	var entry []byte
	if wOffset > 0 {
		entry = m.buf.ReadBytes(wOffset)
	}
	
	m.dataOneofBytes = entry
	m.parsedOneofBytes = true
	return entry
}

func (m *TestHugeFieldNumbersReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestHugeFieldNumbers_TestAllTypes:
			m.offsetTestAllTypes = offset
		case wireTestHugeFieldNumbers_OptionalInt32:
			m.offsetOptionalInt32 = offset
		case wireTestHugeFieldNumbers_Fixed32:
			m.offsetFixed32 = offset
		case wireTestHugeFieldNumbers_RepeatedInt32:
			m.offsetRepeatedInt32 = append(m.offsetRepeatedInt32, offset)
			m.wireTypeRepeatedInt32 = append(m.wireTypeRepeatedInt32, wire)
		case wireTestHugeFieldNumbers_PackedInt32:
			m.offsetPackedInt32 = append(m.offsetPackedInt32, offset)
			m.wireTypePackedInt32 = append(m.wireTypePackedInt32, wire)
		case wireTestHugeFieldNumbers_OptionalEnum:
			m.offsetOptionalEnum = offset
		case wireTestHugeFieldNumbers_OptionalString:
			m.offsetOptionalString = offset
		case wireTestHugeFieldNumbers_OptionalBytes:
			m.offsetOptionalBytes = offset
		case wireTestHugeFieldNumbers_OptionalMessage:
			m.offsetOptionalMessage = offset
		case wireTestHugeFieldNumbers_StringStringMap:
			m.offsetStringStringMap = append(m.offsetStringStringMap, offset)
		case wireTestHugeFieldNumbers_OneofUint32:
			m.offsetOneofUint32 = offset
		case wireTestHugeFieldNumbers_OneofTestAllTypes:
			m.offsetOneofTestAllTypes = offset
		case wireTestHugeFieldNumbers_OneofString:
			m.offsetOneofString = offset
		case wireTestHugeFieldNumbers_OneofBytes:
			m.offsetOneofBytes = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestHugeFieldNumbersReader) ToStruct() *TestHugeFieldNumbers {
	if m == nil {
		return nil
	}
	res := &TestHugeFieldNumbers{}

	{
		var data = m.GetTestAllTypes()
		var structData *TestAllTypes
		if data != nil {
			structData = data.ToStruct()
		}
		res.TestAllTypes = structData
	}
	res.OptionalInt32 = m.GetOptionalInt32()
	res.Fixed32 = m.GetFixed32()
	res.RepeatedInt32 = m.GetRepeatedInt32()
	res.PackedInt32 = m.GetPackedInt32()
	res.OptionalEnum = m.GetOptionalEnum()
	res.OptionalString = m.GetOptionalString()
	res.OptionalBytes = m.GetOptionalBytes()

	{
		var data = m.GetOptionalMessage()
		var structData *ForeignMessage
		if data != nil {
			structData = data.ToStruct()
		}
		res.OptionalMessage = structData
	}
	res.StringStringMap = m.GetStringStringMap()
	res.OneofUint32 = m.GetOneofUint32()

	{
		var data = m.GetOneofTestAllTypes()
		var structData *TestAllTypes
		if data != nil {
			structData = data.ToStruct()
		}
		res.OneofTestAllTypes = structData
	}
	res.OneofString = m.GetOneofString()
	res.OneofBytes = m.GetOneofBytes()

	return res
}

func (s *TestHugeFieldNumbersReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestHugeFieldNumbers struct {
	TestAllTypes	*TestAllTypes	`json:"test_all_types,omitempty"`
	OptionalInt32	int32	`json:"optional_int32,omitempty"`
	Fixed32	int32	`json:"fixed_32,omitempty"`
	RepeatedInt32	[]int32	`json:"repeated_int32,omitempty"`
	PackedInt32	[]int32	`json:"packed_int32,omitempty"`
	OptionalEnum	ForeignEnum	`json:"optional_enum,omitempty"`
	OptionalString	string	`json:"optional_string,omitempty"`
	OptionalBytes	[]byte	`json:"optional_bytes,omitempty"`
	OptionalMessage	*ForeignMessage	`json:"optional_message,omitempty"`
	StringStringMap	map[string]string	`json:"string_string_map,omitempty"`
	OneofUint32	uint32	`json:"oneof_uint32,omitempty"`
	OneofTestAllTypes	*TestAllTypes	`json:"oneof_test_all_types,omitempty"`
	OneofString	string	`json:"oneof_string,omitempty"`
	OneofBytes	[]byte	`json:"oneof_bytes,omitempty"`
}

func (s *TestHugeFieldNumbers) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestHugeFieldNumbers) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.TestAllTypes != nil {
		structSize := s.TestAllTypes.XXX_PbContentSize()
		res.AppendBytesTag(wireTestHugeFieldNumbers_TestAllTypes, structSize)
		s.TestAllTypes.MarshalTo(res)
	}
	if s.OptionalInt32 != 0 {
		res.AppendInt32(wireTestHugeFieldNumbers_OptionalInt32, s.OptionalInt32)
	}
	if s.Fixed32 != 0 {
		res.AppendInt32(wireTestHugeFieldNumbers_Fixed32, s.Fixed32)
	}
	if len(s.RepeatedInt32) > 0 {
		if len(s.RepeatedInt32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedInt32 {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestHugeFieldNumbers_RepeatedInt32, listBytesSize)
			for _, entry := range s.RepeatedInt32 {
				res.AppendInt32WithoutTag(entry)
			}
		} else if len(s.RepeatedInt32) == 1 {
			res.AppendInt32(wireTestHugeFieldNumbers_RepeatedInt32, s.RepeatedInt32[0])
		}
	}
	if len(s.PackedInt32) > 0 {
		if len(s.PackedInt32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedInt32 {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireTestHugeFieldNumbers_PackedInt32, listBytesSize)
			for _, entry := range s.PackedInt32 {
				res.AppendInt32WithoutTag(entry)
			}
		} else if len(s.PackedInt32) == 1 {
			res.AppendInt32(wireTestHugeFieldNumbers_PackedInt32, s.PackedInt32[0])
		}
	}
	if s.OptionalEnum != 0 {
		res.AppendInt32(wireTestHugeFieldNumbers_OptionalEnum, int32(s.OptionalEnum))
	}
	if s.OptionalString != "" {
		res.AppendString(wireTestHugeFieldNumbers_OptionalString, s.OptionalString)
	}
	if len(s.OptionalBytes) != 0 {
		res.AppendBytes(wireTestHugeFieldNumbers_OptionalBytes, s.OptionalBytes)
	}
	if s.OptionalMessage != nil {
		structSize := s.OptionalMessage.XXX_PbContentSize()
		res.AppendBytesTag(wireTestHugeFieldNumbers_OptionalMessage, structSize)
		s.OptionalMessage.MarshalTo(res)
	}
	if len(s.StringStringMap) > 0 {
		for k, v := range s.StringStringMap {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeString(v)
			valueSize += gremlin.SizeUint64(uint64(valueSize)) + gremlin.SizeTag(2)
			mapEntrySize := keySize + valueSize
			res.AppendBytesTag(wireTestHugeFieldNumbers_StringStringMap, mapEntrySize)
			res.AppendString(1, k)
			res.AppendString(2, v)
		}
	}
	if s.OneofUint32 != 0 {
		res.AppendUint32(wireTestHugeFieldNumbers_OneofUint32, s.OneofUint32)
	}
	if s.OneofTestAllTypes != nil {
		structSize := s.OneofTestAllTypes.XXX_PbContentSize()
		res.AppendBytesTag(wireTestHugeFieldNumbers_OneofTestAllTypes, structSize)
		s.OneofTestAllTypes.MarshalTo(res)
	}
	if s.OneofString != "" {
		res.AppendString(wireTestHugeFieldNumbers_OneofString, s.OneofString)
	}
	if len(s.OneofBytes) != 0 {
		res.AppendBytes(wireTestHugeFieldNumbers_OneofBytes, s.OneofBytes)
	}
}

func (s *TestHugeFieldNumbers) Copy() *TestHugeFieldNumbers {
	if s == nil {
		return nil
	}
	res := &TestHugeFieldNumbers{}
	if s.TestAllTypes != nil {
		res.TestAllTypes = s.TestAllTypes.Copy()
	}
	res.OptionalInt32 = s.OptionalInt32
	res.Fixed32 = s.Fixed32
	res.RepeatedInt32 = s.RepeatedInt32
	res.PackedInt32 = s.PackedInt32
	res.OptionalEnum = s.OptionalEnum
	res.OptionalString = s.OptionalString
	res.OptionalBytes = s.OptionalBytes
	if s.OptionalMessage != nil {
		res.OptionalMessage = s.OptionalMessage.Copy()
	}
	res.StringStringMap = make(map[string]string, len(s.StringStringMap))
	for k, v := range s.StringStringMap {
		res.StringStringMap[k] = v
	}
	res.OneofUint32 = s.OneofUint32
	if s.OneofTestAllTypes != nil {
		res.OneofTestAllTypes = s.OneofTestAllTypes.Copy()
	}
	res.OneofString = s.OneofString
	res.OneofBytes = s.OneofBytes

	return res
}

func (s *TestHugeFieldNumbers) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.TestAllTypes != nil {
		var entrySize = 0
		entrySize = s.TestAllTypes.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestHugeFieldNumbers_TestAllTypes)
		
		size += entrySize
	}

	if s.OptionalInt32 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestHugeFieldNumbers_OptionalInt32) + gremlin.SizeInt32(s.OptionalInt32)
		size += entrySize
	}

	if s.Fixed32 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestHugeFieldNumbers_Fixed32) + gremlin.SizeInt32(s.Fixed32)
		size += entrySize
	}

	if len(s.RepeatedInt32) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.RepeatedInt32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.RepeatedInt32 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestHugeFieldNumbers_RepeatedInt32) + listBytesSize
		} else if len(s.RepeatedInt32) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestHugeFieldNumbers_RepeatedInt32) + gremlin.SizeInt32(s.RepeatedInt32[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.PackedInt32) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.PackedInt32) > 1 {
			var listBytesSize = 0
			for _, entry := range s.PackedInt32 {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireTestHugeFieldNumbers_PackedInt32) + listBytesSize
		} else if len(s.PackedInt32) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireTestHugeFieldNumbers_PackedInt32) + gremlin.SizeInt32(s.PackedInt32[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if s.OptionalEnum != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestHugeFieldNumbers_OptionalEnum) + gremlin.SizeInt32(int32(s.OptionalEnum))
		size += entrySize
	}

	if s.OptionalString != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.OptionalString)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestHugeFieldNumbers_OptionalString)
		size += entrySize
	}

	if len(s.OptionalBytes) != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeBytes(s.OptionalBytes)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestHugeFieldNumbers_OptionalBytes)
		size += entrySize
	}

	if s.OptionalMessage != nil {
		var entrySize = 0
		entrySize = s.OptionalMessage.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestHugeFieldNumbers_OptionalMessage)
		
		size += entrySize
	}

	if len(s.StringStringMap) > 0 {
		var entrySize = 0
		entrySize = 0
		for k, v := range s.StringStringMap {
			var keySize, valueSize int
			keySize = gremlin.SizeString(k)
			keySize += gremlin.SizeUint64(uint64(keySize)) + gremlin.SizeTag(1)
			valueSize = gremlin.SizeString(v)
			valueSize += gremlin.SizeUint64(uint64(valueSize)) + gremlin.SizeTag(2)
			var mapEntrySize = keySize + valueSize
			entrySize += mapEntrySize + gremlin.SizeTag(wireTestHugeFieldNumbers_StringStringMap) + gremlin.SizeUint64(uint64(mapEntrySize))
		}
		
		size += entrySize
	}

	if s.OneofUint32 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestHugeFieldNumbers_OneofUint32) + gremlin.SizeUint32(s.OneofUint32)
		size += entrySize
	}

	if s.OneofTestAllTypes != nil {
		var entrySize = 0
		entrySize = s.OneofTestAllTypes.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestHugeFieldNumbers_OneofTestAllTypes)
		
		size += entrySize
	}

	if s.OneofString != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.OneofString)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestHugeFieldNumbers_OneofString)
		size += entrySize
	}

	if len(s.OneofBytes) != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeBytes(s.OneofBytes)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireTestHugeFieldNumbers_OneofBytes)
		size += entrySize
	}

	return size
}

const (
	wireTestExtensionInsideTable_TestExtensionInsideTableExtension gremlin.ProtoWireNumber = 5
	wireTestExtensionInsideTable_Field1 gremlin.ProtoWireNumber = 1
	wireTestExtensionInsideTable_Field2 gremlin.ProtoWireNumber = 2
	wireTestExtensionInsideTable_Field3 gremlin.ProtoWireNumber = 3
	wireTestExtensionInsideTable_Field4 gremlin.ProtoWireNumber = 4
	wireTestExtensionInsideTable_Field6 gremlin.ProtoWireNumber = 6
	wireTestExtensionInsideTable_Field7 gremlin.ProtoWireNumber = 7
	wireTestExtensionInsideTable_Field8 gremlin.ProtoWireNumber = 8
	wireTestExtensionInsideTable_Field9 gremlin.ProtoWireNumber = 9
	wireTestExtensionInsideTable_Field10 gremlin.ProtoWireNumber = 10
)

type TestExtensionInsideTableReader struct {
	buf *gremlin.Reader

	dataTestExtensionInsideTableExtension     int32
	dataField1     int32
	dataField2     int32
	dataField3     int32
	dataField4     int32
	dataField6     int32
	dataField7     int32
	dataField8     int32
	dataField9     int32
	dataField10     int32

	offsetTestExtensionInsideTableExtension   int
	offsetField1   int
	offsetField2   int
	offsetField3   int
	offsetField4   int
	offsetField6   int
	offsetField7   int
	offsetField8   int
	offsetField9   int
	offsetField10   int

	parsedTestExtensionInsideTableExtension   bool
	parsedField1   bool
	parsedField2   bool
	parsedField3   bool
	parsedField4   bool
	parsedField6   bool
	parsedField7   bool
	parsedField8   bool
	parsedField9   bool
	parsedField10   bool
}

func NewTestExtensionInsideTableReader() *TestExtensionInsideTableReader {
	return &TestExtensionInsideTableReader{}
}

func (m *TestExtensionInsideTableReader) GetTestExtensionInsideTableExtension() int32 {
	if m == nil {
		return 0
	}
	return m.readTestExtensionInsideTableExtension()
}

func (m *TestExtensionInsideTableReader) readTestExtensionInsideTableExtension() int32 {
	if m.parsedTestExtensionInsideTableExtension {
		return m.dataTestExtensionInsideTableExtension
	}
	wOffset := m.offsetTestExtensionInsideTableExtension
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataTestExtensionInsideTableExtension = entry
	m.parsedTestExtensionInsideTableExtension = true
	return entry
}

func (m *TestExtensionInsideTableReader) GetField1() int32 {
	if m == nil {
		return 0
	}
	return m.readField1()
}

func (m *TestExtensionInsideTableReader) readField1() int32 {
	if m.parsedField1 {
		return m.dataField1
	}
	wOffset := m.offsetField1
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataField1 = entry
	m.parsedField1 = true
	return entry
}

func (m *TestExtensionInsideTableReader) GetField2() int32 {
	if m == nil {
		return 0
	}
	return m.readField2()
}

func (m *TestExtensionInsideTableReader) readField2() int32 {
	if m.parsedField2 {
		return m.dataField2
	}
	wOffset := m.offsetField2
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataField2 = entry
	m.parsedField2 = true
	return entry
}

func (m *TestExtensionInsideTableReader) GetField3() int32 {
	if m == nil {
		return 0
	}
	return m.readField3()
}

func (m *TestExtensionInsideTableReader) readField3() int32 {
	if m.parsedField3 {
		return m.dataField3
	}
	wOffset := m.offsetField3
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataField3 = entry
	m.parsedField3 = true
	return entry
}

func (m *TestExtensionInsideTableReader) GetField4() int32 {
	if m == nil {
		return 0
	}
	return m.readField4()
}

func (m *TestExtensionInsideTableReader) readField4() int32 {
	if m.parsedField4 {
		return m.dataField4
	}
	wOffset := m.offsetField4
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataField4 = entry
	m.parsedField4 = true
	return entry
}

func (m *TestExtensionInsideTableReader) GetField6() int32 {
	if m == nil {
		return 0
	}
	return m.readField6()
}

func (m *TestExtensionInsideTableReader) readField6() int32 {
	if m.parsedField6 {
		return m.dataField6
	}
	wOffset := m.offsetField6
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataField6 = entry
	m.parsedField6 = true
	return entry
}

func (m *TestExtensionInsideTableReader) GetField7() int32 {
	if m == nil {
		return 0
	}
	return m.readField7()
}

func (m *TestExtensionInsideTableReader) readField7() int32 {
	if m.parsedField7 {
		return m.dataField7
	}
	wOffset := m.offsetField7
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataField7 = entry
	m.parsedField7 = true
	return entry
}

func (m *TestExtensionInsideTableReader) GetField8() int32 {
	if m == nil {
		return 0
	}
	return m.readField8()
}

func (m *TestExtensionInsideTableReader) readField8() int32 {
	if m.parsedField8 {
		return m.dataField8
	}
	wOffset := m.offsetField8
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataField8 = entry
	m.parsedField8 = true
	return entry
}

func (m *TestExtensionInsideTableReader) GetField9() int32 {
	if m == nil {
		return 0
	}
	return m.readField9()
}

func (m *TestExtensionInsideTableReader) readField9() int32 {
	if m.parsedField9 {
		return m.dataField9
	}
	wOffset := m.offsetField9
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataField9 = entry
	m.parsedField9 = true
	return entry
}

func (m *TestExtensionInsideTableReader) GetField10() int32 {
	if m == nil {
		return 0
	}
	return m.readField10()
}

func (m *TestExtensionInsideTableReader) readField10() int32 {
	if m.parsedField10 {
		return m.dataField10
	}
	wOffset := m.offsetField10
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataField10 = entry
	m.parsedField10 = true
	return entry
}

func (m *TestExtensionInsideTableReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestExtensionInsideTable_TestExtensionInsideTableExtension:
			m.offsetTestExtensionInsideTableExtension = offset
		case wireTestExtensionInsideTable_Field1:
			m.offsetField1 = offset
		case wireTestExtensionInsideTable_Field2:
			m.offsetField2 = offset
		case wireTestExtensionInsideTable_Field3:
			m.offsetField3 = offset
		case wireTestExtensionInsideTable_Field4:
			m.offsetField4 = offset
		case wireTestExtensionInsideTable_Field6:
			m.offsetField6 = offset
		case wireTestExtensionInsideTable_Field7:
			m.offsetField7 = offset
		case wireTestExtensionInsideTable_Field8:
			m.offsetField8 = offset
		case wireTestExtensionInsideTable_Field9:
			m.offsetField9 = offset
		case wireTestExtensionInsideTable_Field10:
			m.offsetField10 = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestExtensionInsideTableReader) ToStruct() *TestExtensionInsideTable {
	if m == nil {
		return nil
	}
	res := &TestExtensionInsideTable{}
	res.TestExtensionInsideTableExtension = m.GetTestExtensionInsideTableExtension()
	res.Field1 = m.GetField1()
	res.Field2 = m.GetField2()
	res.Field3 = m.GetField3()
	res.Field4 = m.GetField4()
	res.Field6 = m.GetField6()
	res.Field7 = m.GetField7()
	res.Field8 = m.GetField8()
	res.Field9 = m.GetField9()
	res.Field10 = m.GetField10()

	return res
}

func (s *TestExtensionInsideTableReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestExtensionInsideTable struct {
	TestExtensionInsideTableExtension	int32	`json:"test_extension_inside_table_extension,omitempty"`
	Field1	int32	`json:"field1,omitempty"`
	Field2	int32	`json:"field2,omitempty"`
	Field3	int32	`json:"field3,omitempty"`
	Field4	int32	`json:"field4,omitempty"`
	Field6	int32	`json:"field6,omitempty"`
	Field7	int32	`json:"field7,omitempty"`
	Field8	int32	`json:"field8,omitempty"`
	Field9	int32	`json:"field9,omitempty"`
	Field10	int32	`json:"field10,omitempty"`
}

func (s *TestExtensionInsideTable) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestExtensionInsideTable) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.TestExtensionInsideTableExtension != 0 {
		res.AppendInt32(wireTestExtensionInsideTable_TestExtensionInsideTableExtension, s.TestExtensionInsideTableExtension)
	}
	if s.Field1 != 0 {
		res.AppendInt32(wireTestExtensionInsideTable_Field1, s.Field1)
	}
	if s.Field2 != 0 {
		res.AppendInt32(wireTestExtensionInsideTable_Field2, s.Field2)
	}
	if s.Field3 != 0 {
		res.AppendInt32(wireTestExtensionInsideTable_Field3, s.Field3)
	}
	if s.Field4 != 0 {
		res.AppendInt32(wireTestExtensionInsideTable_Field4, s.Field4)
	}
	if s.Field6 != 0 {
		res.AppendInt32(wireTestExtensionInsideTable_Field6, s.Field6)
	}
	if s.Field7 != 0 {
		res.AppendInt32(wireTestExtensionInsideTable_Field7, s.Field7)
	}
	if s.Field8 != 0 {
		res.AppendInt32(wireTestExtensionInsideTable_Field8, s.Field8)
	}
	if s.Field9 != 0 {
		res.AppendInt32(wireTestExtensionInsideTable_Field9, s.Field9)
	}
	if s.Field10 != 0 {
		res.AppendInt32(wireTestExtensionInsideTable_Field10, s.Field10)
	}
}

func (s *TestExtensionInsideTable) Copy() *TestExtensionInsideTable {
	if s == nil {
		return nil
	}
	res := &TestExtensionInsideTable{}
	res.TestExtensionInsideTableExtension = s.TestExtensionInsideTableExtension
	res.Field1 = s.Field1
	res.Field2 = s.Field2
	res.Field3 = s.Field3
	res.Field4 = s.Field4
	res.Field6 = s.Field6
	res.Field7 = s.Field7
	res.Field8 = s.Field8
	res.Field9 = s.Field9
	res.Field10 = s.Field10

	return res
}

func (s *TestExtensionInsideTable) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.TestExtensionInsideTableExtension != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionInsideTable_TestExtensionInsideTableExtension) + gremlin.SizeInt32(s.TestExtensionInsideTableExtension)
		size += entrySize
	}

	if s.Field1 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionInsideTable_Field1) + gremlin.SizeInt32(s.Field1)
		size += entrySize
	}

	if s.Field2 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionInsideTable_Field2) + gremlin.SizeInt32(s.Field2)
		size += entrySize
	}

	if s.Field3 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionInsideTable_Field3) + gremlin.SizeInt32(s.Field3)
		size += entrySize
	}

	if s.Field4 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionInsideTable_Field4) + gremlin.SizeInt32(s.Field4)
		size += entrySize
	}

	if s.Field6 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionInsideTable_Field6) + gremlin.SizeInt32(s.Field6)
		size += entrySize
	}

	if s.Field7 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionInsideTable_Field7) + gremlin.SizeInt32(s.Field7)
		size += entrySize
	}

	if s.Field8 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionInsideTable_Field8) + gremlin.SizeInt32(s.Field8)
		size += entrySize
	}

	if s.Field9 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionInsideTable_Field9) + gremlin.SizeInt32(s.Field9)
		size += entrySize
	}

	if s.Field10 != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionInsideTable_Field10) + gremlin.SizeInt32(s.Field10)
		size += entrySize
	}

	return size
}

const (
	wireTestExtensionRangeSerialize_FooOne gremlin.ProtoWireNumber = 1
	wireTestExtensionRangeSerialize_FooTwo gremlin.ProtoWireNumber = 6
	wireTestExtensionRangeSerialize_FooThree gremlin.ProtoWireNumber = 7
	wireTestExtensionRangeSerialize_FooFour gremlin.ProtoWireNumber = 13
)

type TestExtensionRangeSerializeReader struct {
	buf *gremlin.Reader

	dataFooOne     int32
	dataFooTwo     int32
	dataFooThree     int32
	dataFooFour     int32

	offsetFooOne   int
	offsetFooTwo   int
	offsetFooThree   int
	offsetFooFour   int

	parsedFooOne   bool
	parsedFooTwo   bool
	parsedFooThree   bool
	parsedFooFour   bool
}

func NewTestExtensionRangeSerializeReader() *TestExtensionRangeSerializeReader {
	return &TestExtensionRangeSerializeReader{}
}

func (m *TestExtensionRangeSerializeReader) GetFooOne() int32 {
	if m == nil {
		return 0
	}
	return m.readFooOne()
}

func (m *TestExtensionRangeSerializeReader) readFooOne() int32 {
	if m.parsedFooOne {
		return m.dataFooOne
	}
	wOffset := m.offsetFooOne
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataFooOne = entry
	m.parsedFooOne = true
	return entry
}

func (m *TestExtensionRangeSerializeReader) GetFooTwo() int32 {
	if m == nil {
		return 0
	}
	return m.readFooTwo()
}

func (m *TestExtensionRangeSerializeReader) readFooTwo() int32 {
	if m.parsedFooTwo {
		return m.dataFooTwo
	}
	wOffset := m.offsetFooTwo
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataFooTwo = entry
	m.parsedFooTwo = true
	return entry
}

func (m *TestExtensionRangeSerializeReader) GetFooThree() int32 {
	if m == nil {
		return 0
	}
	return m.readFooThree()
}

func (m *TestExtensionRangeSerializeReader) readFooThree() int32 {
	if m.parsedFooThree {
		return m.dataFooThree
	}
	wOffset := m.offsetFooThree
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataFooThree = entry
	m.parsedFooThree = true
	return entry
}

func (m *TestExtensionRangeSerializeReader) GetFooFour() int32 {
	if m == nil {
		return 0
	}
	return m.readFooFour()
}

func (m *TestExtensionRangeSerializeReader) readFooFour() int32 {
	if m.parsedFooFour {
		return m.dataFooFour
	}
	wOffset := m.offsetFooFour
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataFooFour = entry
	m.parsedFooFour = true
	return entry
}

func (m *TestExtensionRangeSerializeReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestExtensionRangeSerialize_FooOne:
			m.offsetFooOne = offset
		case wireTestExtensionRangeSerialize_FooTwo:
			m.offsetFooTwo = offset
		case wireTestExtensionRangeSerialize_FooThree:
			m.offsetFooThree = offset
		case wireTestExtensionRangeSerialize_FooFour:
			m.offsetFooFour = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestExtensionRangeSerializeReader) ToStruct() *TestExtensionRangeSerialize {
	if m == nil {
		return nil
	}
	res := &TestExtensionRangeSerialize{}
	res.FooOne = m.GetFooOne()
	res.FooTwo = m.GetFooTwo()
	res.FooThree = m.GetFooThree()
	res.FooFour = m.GetFooFour()

	return res
}

func (s *TestExtensionRangeSerializeReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestExtensionRangeSerialize struct {
	FooOne	int32	`json:"foo_one,omitempty"`
	FooTwo	int32	`json:"foo_two,omitempty"`
	FooThree	int32	`json:"foo_three,omitempty"`
	FooFour	int32	`json:"foo_four,omitempty"`
}

func (s *TestExtensionRangeSerialize) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestExtensionRangeSerialize) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.FooOne != 0 {
		res.AppendInt32(wireTestExtensionRangeSerialize_FooOne, s.FooOne)
	}
	if s.FooTwo != 0 {
		res.AppendInt32(wireTestExtensionRangeSerialize_FooTwo, s.FooTwo)
	}
	if s.FooThree != 0 {
		res.AppendInt32(wireTestExtensionRangeSerialize_FooThree, s.FooThree)
	}
	if s.FooFour != 0 {
		res.AppendInt32(wireTestExtensionRangeSerialize_FooFour, s.FooFour)
	}
}

func (s *TestExtensionRangeSerialize) Copy() *TestExtensionRangeSerialize {
	if s == nil {
		return nil
	}
	res := &TestExtensionRangeSerialize{}
	res.FooOne = s.FooOne
	res.FooTwo = s.FooTwo
	res.FooThree = s.FooThree
	res.FooFour = s.FooFour

	return res
}

func (s *TestExtensionRangeSerialize) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.FooOne != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionRangeSerialize_FooOne) + gremlin.SizeInt32(s.FooOne)
		size += entrySize
	}

	if s.FooTwo != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionRangeSerialize_FooTwo) + gremlin.SizeInt32(s.FooTwo)
		size += entrySize
	}

	if s.FooThree != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionRangeSerialize_FooThree) + gremlin.SizeInt32(s.FooThree)
		size += entrySize
	}

	if s.FooFour != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionRangeSerialize_FooFour) + gremlin.SizeInt32(s.FooFour)
		size += entrySize
	}

	return size
}

const (
	wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_BarOne gremlin.ProtoWireNumber = 2
	wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_BarTwo gremlin.ProtoWireNumber = 4
	wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_BarThree gremlin.ProtoWireNumber = 10
	wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_BarFour gremlin.ProtoWireNumber = 15
	wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_BarFive gremlin.ProtoWireNumber = 19
	wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_FooOne gremlin.ProtoWireNumber = 1
	wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_FooTwo gremlin.ProtoWireNumber = 6
	wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_FooThree gremlin.ProtoWireNumber = 7
	wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_FooFour gremlin.ProtoWireNumber = 13
)

type TestExtensionRangeSerialize_TestExtensionRangeSerializeReader struct {
	buf *gremlin.Reader

	dataBarOne     int32
	dataBarTwo     int32
	dataBarThree     int32
	dataBarFour     int32
	dataBarFive     int32
	dataFooOne     int32
	dataFooTwo     int32
	dataFooThree     int32
	dataFooFour     int32

	offsetBarOne   int
	offsetBarTwo   int
	offsetBarThree   int
	offsetBarFour   int
	offsetBarFive   int
	offsetFooOne   int
	offsetFooTwo   int
	offsetFooThree   int
	offsetFooFour   int

	parsedBarOne   bool
	parsedBarTwo   bool
	parsedBarThree   bool
	parsedBarFour   bool
	parsedBarFive   bool
	parsedFooOne   bool
	parsedFooTwo   bool
	parsedFooThree   bool
	parsedFooFour   bool
}

func NewTestExtensionRangeSerialize_TestExtensionRangeSerializeReader() *TestExtensionRangeSerialize_TestExtensionRangeSerializeReader {
	return &TestExtensionRangeSerialize_TestExtensionRangeSerializeReader{}
}

func (m *TestExtensionRangeSerialize_TestExtensionRangeSerializeReader) GetBarOne() int32 {
	if m == nil {
		return 0
	}
	return m.readBarOne()
}

func (m *TestExtensionRangeSerialize_TestExtensionRangeSerializeReader) readBarOne() int32 {
	if m.parsedBarOne {
		return m.dataBarOne
	}
	wOffset := m.offsetBarOne
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataBarOne = entry
	m.parsedBarOne = true
	return entry
}

func (m *TestExtensionRangeSerialize_TestExtensionRangeSerializeReader) GetBarTwo() int32 {
	if m == nil {
		return 0
	}
	return m.readBarTwo()
}

func (m *TestExtensionRangeSerialize_TestExtensionRangeSerializeReader) readBarTwo() int32 {
	if m.parsedBarTwo {
		return m.dataBarTwo
	}
	wOffset := m.offsetBarTwo
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataBarTwo = entry
	m.parsedBarTwo = true
	return entry
}

func (m *TestExtensionRangeSerialize_TestExtensionRangeSerializeReader) GetBarThree() int32 {
	if m == nil {
		return 0
	}
	return m.readBarThree()
}

func (m *TestExtensionRangeSerialize_TestExtensionRangeSerializeReader) readBarThree() int32 {
	if m.parsedBarThree {
		return m.dataBarThree
	}
	wOffset := m.offsetBarThree
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataBarThree = entry
	m.parsedBarThree = true
	return entry
}

func (m *TestExtensionRangeSerialize_TestExtensionRangeSerializeReader) GetBarFour() int32 {
	if m == nil {
		return 0
	}
	return m.readBarFour()
}

func (m *TestExtensionRangeSerialize_TestExtensionRangeSerializeReader) readBarFour() int32 {
	if m.parsedBarFour {
		return m.dataBarFour
	}
	wOffset := m.offsetBarFour
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataBarFour = entry
	m.parsedBarFour = true
	return entry
}

func (m *TestExtensionRangeSerialize_TestExtensionRangeSerializeReader) GetBarFive() int32 {
	if m == nil {
		return 0
	}
	return m.readBarFive()
}

func (m *TestExtensionRangeSerialize_TestExtensionRangeSerializeReader) readBarFive() int32 {
	if m.parsedBarFive {
		return m.dataBarFive
	}
	wOffset := m.offsetBarFive
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataBarFive = entry
	m.parsedBarFive = true
	return entry
}

func (m *TestExtensionRangeSerialize_TestExtensionRangeSerializeReader) GetFooOne() int32 {
	if m == nil {
		return 0
	}
	return m.readFooOne()
}

func (m *TestExtensionRangeSerialize_TestExtensionRangeSerializeReader) readFooOne() int32 {
	if m.parsedFooOne {
		return m.dataFooOne
	}
	wOffset := m.offsetFooOne
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataFooOne = entry
	m.parsedFooOne = true
	return entry
}

func (m *TestExtensionRangeSerialize_TestExtensionRangeSerializeReader) GetFooTwo() int32 {
	if m == nil {
		return 0
	}
	return m.readFooTwo()
}

func (m *TestExtensionRangeSerialize_TestExtensionRangeSerializeReader) readFooTwo() int32 {
	if m.parsedFooTwo {
		return m.dataFooTwo
	}
	wOffset := m.offsetFooTwo
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataFooTwo = entry
	m.parsedFooTwo = true
	return entry
}

func (m *TestExtensionRangeSerialize_TestExtensionRangeSerializeReader) GetFooThree() int32 {
	if m == nil {
		return 0
	}
	return m.readFooThree()
}

func (m *TestExtensionRangeSerialize_TestExtensionRangeSerializeReader) readFooThree() int32 {
	if m.parsedFooThree {
		return m.dataFooThree
	}
	wOffset := m.offsetFooThree
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataFooThree = entry
	m.parsedFooThree = true
	return entry
}

func (m *TestExtensionRangeSerialize_TestExtensionRangeSerializeReader) GetFooFour() int32 {
	if m == nil {
		return 0
	}
	return m.readFooFour()
}

func (m *TestExtensionRangeSerialize_TestExtensionRangeSerializeReader) readFooFour() int32 {
	if m.parsedFooFour {
		return m.dataFooFour
	}
	wOffset := m.offsetFooFour
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataFooFour = entry
	m.parsedFooFour = true
	return entry
}

func (m *TestExtensionRangeSerialize_TestExtensionRangeSerializeReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_BarOne:
			m.offsetBarOne = offset
		case wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_BarTwo:
			m.offsetBarTwo = offset
		case wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_BarThree:
			m.offsetBarThree = offset
		case wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_BarFour:
			m.offsetBarFour = offset
		case wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_BarFive:
			m.offsetBarFive = offset
		case wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_FooOne:
			m.offsetFooOne = offset
		case wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_FooTwo:
			m.offsetFooTwo = offset
		case wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_FooThree:
			m.offsetFooThree = offset
		case wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_FooFour:
			m.offsetFooFour = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *TestExtensionRangeSerialize_TestExtensionRangeSerializeReader) ToStruct() *TestExtensionRangeSerialize_TestExtensionRangeSerialize {
	if m == nil {
		return nil
	}
	res := &TestExtensionRangeSerialize_TestExtensionRangeSerialize{}
	res.BarOne = m.GetBarOne()
	res.BarTwo = m.GetBarTwo()
	res.BarThree = m.GetBarThree()
	res.BarFour = m.GetBarFour()
	res.BarFive = m.GetBarFive()
	res.FooOne = m.GetFooOne()
	res.FooTwo = m.GetFooTwo()
	res.FooThree = m.GetFooThree()
	res.FooFour = m.GetFooFour()

	return res
}

func (s *TestExtensionRangeSerialize_TestExtensionRangeSerializeReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type TestExtensionRangeSerialize_TestExtensionRangeSerialize struct {
	BarOne	int32	`json:"bar_one,omitempty"`
	BarTwo	int32	`json:"bar_two,omitempty"`
	BarThree	int32	`json:"bar_three,omitempty"`
	BarFour	int32	`json:"bar_four,omitempty"`
	BarFive	int32	`json:"bar_five,omitempty"`
	FooOne	int32	`json:"foo_one,omitempty"`
	FooTwo	int32	`json:"foo_two,omitempty"`
	FooThree	int32	`json:"foo_three,omitempty"`
	FooFour	int32	`json:"foo_four,omitempty"`
}

func (s *TestExtensionRangeSerialize_TestExtensionRangeSerialize) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *TestExtensionRangeSerialize_TestExtensionRangeSerialize) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.BarOne != 0 {
		res.AppendInt32(wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_BarOne, s.BarOne)
	}
	if s.BarTwo != 0 {
		res.AppendInt32(wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_BarTwo, s.BarTwo)
	}
	if s.BarThree != 0 {
		res.AppendInt32(wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_BarThree, s.BarThree)
	}
	if s.BarFour != 0 {
		res.AppendInt32(wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_BarFour, s.BarFour)
	}
	if s.BarFive != 0 {
		res.AppendInt32(wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_BarFive, s.BarFive)
	}
	if s.FooOne != 0 {
		res.AppendInt32(wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_FooOne, s.FooOne)
	}
	if s.FooTwo != 0 {
		res.AppendInt32(wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_FooTwo, s.FooTwo)
	}
	if s.FooThree != 0 {
		res.AppendInt32(wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_FooThree, s.FooThree)
	}
	if s.FooFour != 0 {
		res.AppendInt32(wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_FooFour, s.FooFour)
	}
}

func (s *TestExtensionRangeSerialize_TestExtensionRangeSerialize) Copy() *TestExtensionRangeSerialize_TestExtensionRangeSerialize {
	if s == nil {
		return nil
	}
	res := &TestExtensionRangeSerialize_TestExtensionRangeSerialize{}
	res.BarOne = s.BarOne
	res.BarTwo = s.BarTwo
	res.BarThree = s.BarThree
	res.BarFour = s.BarFour
	res.BarFive = s.BarFive
	res.FooOne = s.FooOne
	res.FooTwo = s.FooTwo
	res.FooThree = s.FooThree
	res.FooFour = s.FooFour

	return res
}

func (s *TestExtensionRangeSerialize_TestExtensionRangeSerialize) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.BarOne != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_BarOne) + gremlin.SizeInt32(s.BarOne)
		size += entrySize
	}

	if s.BarTwo != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_BarTwo) + gremlin.SizeInt32(s.BarTwo)
		size += entrySize
	}

	if s.BarThree != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_BarThree) + gremlin.SizeInt32(s.BarThree)
		size += entrySize
	}

	if s.BarFour != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_BarFour) + gremlin.SizeInt32(s.BarFour)
		size += entrySize
	}

	if s.BarFive != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_BarFive) + gremlin.SizeInt32(s.BarFive)
		size += entrySize
	}

	if s.FooOne != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_FooOne) + gremlin.SizeInt32(s.FooOne)
		size += entrySize
	}

	if s.FooTwo != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_FooTwo) + gremlin.SizeInt32(s.FooTwo)
		size += entrySize
	}

	if s.FooThree != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_FooThree) + gremlin.SizeInt32(s.FooThree)
		size += entrySize
	}

	if s.FooFour != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireTestExtensionRangeSerialize_TestExtensionRangeSerialize_FooFour) + gremlin.SizeInt32(s.FooFour)
		size += entrySize
	}

	return size
}

const (
	wireDefaultBoolTest_DefaultBool gremlin.ProtoWireNumber = 73
)

type DefaultBoolTestReader struct {
	buf *gremlin.Reader

	dataDefaultBool     bool

	offsetDefaultBool   int

	parsedDefaultBool   bool
}

func NewDefaultBoolTestReader() *DefaultBoolTestReader {
	return &DefaultBoolTestReader{}
}

func (m *DefaultBoolTestReader) GetDefaultBool() bool {
	if m == nil {
		return true
	}
	return m.readDefaultBool()
}

func (m *DefaultBoolTestReader) readDefaultBool() bool {
	if m.parsedDefaultBool {
		return m.dataDefaultBool
	}
	wOffset := m.offsetDefaultBool
	
	var entry bool
	if wOffset > 0 {
		entry = m.buf.ReadBool(wOffset)
	} else {
		entry = true
	}
	
	m.dataDefaultBool = entry
	m.parsedDefaultBool = true
	return entry
}

func (m *DefaultBoolTestReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireDefaultBoolTest_DefaultBool:
			m.offsetDefaultBool = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *DefaultBoolTestReader) ToStruct() *DefaultBoolTest {
	if m == nil {
		return nil
	}
	res := &DefaultBoolTest{}
	res.DefaultBool = m.GetDefaultBool()

	return res
}

func (s *DefaultBoolTestReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type DefaultBoolTest struct {
	DefaultBool	bool	`json:"default_bool,omitempty"`
}

func (s *DefaultBoolTest) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *DefaultBoolTest) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.DefaultBool != true {
		res.AppendBool(wireDefaultBoolTest_DefaultBool, s.DefaultBool)
	}
}

func (s *DefaultBoolTest) Copy() *DefaultBoolTest {
	if s == nil {
		return nil
	}
	res := &DefaultBoolTest{}
	res.DefaultBool = s.DefaultBool

	return res
}

func (s *DefaultBoolTest) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.DefaultBool != true {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireDefaultBoolTest_DefaultBool) + gremlin.SizeBool(s.DefaultBool)
		size += entrySize
	}

	return size
}
