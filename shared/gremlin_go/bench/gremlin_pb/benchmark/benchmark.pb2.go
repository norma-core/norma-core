// Code generated by gremlin. DO NOT EDIT.
// source: benchmark.proto

package google_pb

import gremlin "github.com/norma-core/norma-core/shared/gremlin_go"

const (
	wireLevel4_Value gremlin.ProtoWireNumber = 1
	wireLevel4_Data gremlin.ProtoWireNumber = 2
	wireLevel4_Numbers gremlin.ProtoWireNumber = 3
)

type Level4Reader struct {
	buf *gremlin.Reader

	dataValue     int32
	dataData     string
	dataNumbers     []int32

	offsetValue   int
	offsetData   int
	offsetNumbers   []int
	wireTypeNumbers []gremlin.ProtoWireType

	parsedValue   bool
	parsedData   bool
	parsedNumbers   bool
}

func NewLevel4Reader() *Level4Reader {
	return &Level4Reader{}
}

func (m *Level4Reader) GetValue() int32 {
	if m == nil {
		return 0
	}
	return m.readValue()
}

func (m *Level4Reader) readValue() int32 {
	if m.parsedValue {
		return m.dataValue
	}
	wOffset := m.offsetValue
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataValue = entry
	m.parsedValue = true
	return entry
}

func (m *Level4Reader) GetData() string {
	if m == nil {
		return ""
	}
	return m.readData()
}

func (m *Level4Reader) readData() string {
	if m.parsedData {
		return m.dataData
	}
	wOffset := m.offsetData
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataData = entry
	m.parsedData = true
	return entry
}

func (m *Level4Reader) GetNumbers() []int32 {
	if m == nil {
		return nil
	}
	return m.readNumbers()
}

func (m *Level4Reader) readNumbers() []int32 {
	if m.parsedNumbers {
		return m.dataNumbers
	}
	wOffset := m.offsetNumbers
	var wType = m.wireTypeNumbers
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadInt32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataNumbers = entry
	m.parsedNumbers = true
	return entry
}

func (m *Level4Reader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireLevel4_Value:
			m.offsetValue = offset
		case wireLevel4_Data:
			m.offsetData = offset
		case wireLevel4_Numbers:
			m.offsetNumbers = append(m.offsetNumbers, offset)
			m.wireTypeNumbers = append(m.wireTypeNumbers, wire)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *Level4Reader) ToStruct() *Level4 {
	if m == nil {
		return nil
	}
	res := &Level4{}
	res.Value = m.GetValue()
	res.Data = m.GetData()
	res.Numbers = m.GetNumbers()

	return res
}

func (s *Level4Reader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type Level4 struct {
	Value	int32	`json:"value,omitempty"`
	Data	string	`json:"data,omitempty"`
	Numbers	[]int32	`json:"numbers,omitempty"`
}

func (s *Level4) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *Level4) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Value != 0 {
		res.AppendInt32(wireLevel4_Value, s.Value)
	}
	if s.Data != "" {
		res.AppendString(wireLevel4_Data, s.Data)
	}
	if len(s.Numbers) > 0 {
		if len(s.Numbers) > 1 {
			var listBytesSize = 0
			for _, entry := range s.Numbers {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireLevel4_Numbers, listBytesSize)
			for _, entry := range s.Numbers {
				res.AppendInt32WithoutTag(entry)
			}
		} else if len(s.Numbers) == 1 {
			res.AppendInt32(wireLevel4_Numbers, s.Numbers[0])
		}
	}
}

func (s *Level4) Copy() *Level4 {
	if s == nil {
		return nil
	}
	res := &Level4{}
	res.Value = s.Value
	res.Data = s.Data
	res.Numbers = s.Numbers

	return res
}

func (s *Level4) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Value != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireLevel4_Value) + gremlin.SizeInt32(s.Value)
		size += entrySize
	}

	if s.Data != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Data)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireLevel4_Data)
		size += entrySize
	}

	if len(s.Numbers) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.Numbers) > 1 {
			var listBytesSize = 0
			for _, entry := range s.Numbers {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireLevel4_Numbers) + listBytesSize
		} else if len(s.Numbers) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireLevel4_Numbers) + gremlin.SizeInt32(s.Numbers[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	return size
}

const (
	wireLevel3_Id gremlin.ProtoWireNumber = 1
	wireLevel3_Name gremlin.ProtoWireNumber = 2
	wireLevel3_Nested gremlin.ProtoWireNumber = 3
	wireLevel3_Items gremlin.ProtoWireNumber = 4
)

type Level3Reader struct {
	buf *gremlin.Reader

	dataId     int32
	dataName     string
	dataNested     *Level4Reader
	dataItems     []*Level4Reader

	offsetId   int
	offsetName   int
	offsetNested   int
	offsetItems   []int

	parsedId   bool
	parsedName   bool
	parsedNested   bool
	parsedItems   bool
}

func NewLevel3Reader() *Level3Reader {
	return &Level3Reader{}
}

func (m *Level3Reader) GetId() int32 {
	if m == nil {
		return 0
	}
	return m.readId()
}

func (m *Level3Reader) readId() int32 {
	if m.parsedId {
		return m.dataId
	}
	wOffset := m.offsetId
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataId = entry
	m.parsedId = true
	return entry
}

func (m *Level3Reader) GetName() string {
	if m == nil {
		return ""
	}
	return m.readName()
}

func (m *Level3Reader) readName() string {
	if m.parsedName {
		return m.dataName
	}
	wOffset := m.offsetName
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataName = entry
	m.parsedName = true
	return entry
}

func (m *Level3Reader) GetNested() *Level4Reader {
	if m == nil {
		return nil
	}
	return m.readNested()
}

func (m *Level3Reader) readNested() *Level4Reader {
	if m.parsedNested {
		return m.dataNested
	}
	wOffset := m.offsetNested
	
	var entry *Level4Reader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewLevel4Reader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataNested = entry
	m.parsedNested = true
	return entry
}

func (m *Level3Reader) GetItems() []*Level4Reader {
	if m == nil {
		return nil
	}
	return m.readItems()
}

func (m *Level3Reader) readItems() []*Level4Reader {
	if m.parsedItems {
		return m.dataItems
	}
	wOffset := m.offsetItems
	
	var entry []*Level4Reader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *Level4Reader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewLevel4Reader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataItems = entry
	m.parsedItems = true
	return entry
}

func (m *Level3Reader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireLevel3_Id:
			m.offsetId = offset
		case wireLevel3_Name:
			m.offsetName = offset
		case wireLevel3_Nested:
			m.offsetNested = offset
		case wireLevel3_Items:
			m.offsetItems = append(m.offsetItems, offset)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *Level3Reader) ToStruct() *Level3 {
	if m == nil {
		return nil
	}
	res := &Level3{}
	res.Id = m.GetId()
	res.Name = m.GetName()

	{
		var data = m.GetNested()
		var structData *Level4
		if data != nil {
			structData = data.ToStruct()
		}
		res.Nested = structData
	}

	{
		var data = m.GetItems()
		var structData []*Level4
		if len(data) > 0 {
			structData = make([]*Level4, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.Items = structData
	}

	return res
}

func (s *Level3Reader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type Level3 struct {
	Id	int32	`json:"id,omitempty"`
	Name	string	`json:"name,omitempty"`
	Nested	*Level4	`json:"nested,omitempty"`
	Items	[]*Level4	`json:"items,omitempty"`
}

func (s *Level3) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *Level3) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Id != 0 {
		res.AppendInt32(wireLevel3_Id, s.Id)
	}
	if s.Name != "" {
		res.AppendString(wireLevel3_Name, s.Name)
	}
	if s.Nested != nil {
		structSize := s.Nested.XXX_PbContentSize()
		res.AppendBytesTag(wireLevel3_Nested, structSize)
		s.Nested.MarshalTo(res)
	}
	if len(s.Items) > 0 {
		for _, entry := range s.Items {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireLevel3_Items, structSize)
			entry.MarshalTo(res)
		}
	}
}

func (s *Level3) Copy() *Level3 {
	if s == nil {
		return nil
	}
	res := &Level3{}
	res.Id = s.Id
	res.Name = s.Name
	if s.Nested != nil {
		res.Nested = s.Nested.Copy()
	}
	res.Items = make([]*Level4, len(s.Items))
	for i := range s.Items {
		if s.Items[i] != nil {
			res.Items[i] = s.Items[i].Copy()
		}
	}

	return res
}

func (s *Level3) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Id != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireLevel3_Id) + gremlin.SizeInt32(s.Id)
		size += entrySize
	}

	if s.Name != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Name)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireLevel3_Name)
		size += entrySize
	}

	if s.Nested != nil {
		var entrySize = 0
		entrySize = s.Nested.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireLevel3_Nested)
		
		size += entrySize
	}

	if len(s.Items) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.Items {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireLevel3_Items)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	return size
}

const (
	wireLevel2_Id gremlin.ProtoWireNumber = 1
	wireLevel2_Description gremlin.ProtoWireNumber = 2
	wireLevel2_Nested gremlin.ProtoWireNumber = 3
	wireLevel2_Items gremlin.ProtoWireNumber = 4
	wireLevel2_Payload gremlin.ProtoWireNumber = 5
)

type Level2Reader struct {
	buf *gremlin.Reader

	dataId     int32
	dataDescription     string
	dataNested     *Level3Reader
	dataItems     []*Level3Reader
	dataPayload     []byte

	offsetId   int
	offsetDescription   int
	offsetNested   int
	offsetItems   []int
	offsetPayload   int

	parsedId   bool
	parsedDescription   bool
	parsedNested   bool
	parsedItems   bool
	parsedPayload   bool
}

func NewLevel2Reader() *Level2Reader {
	return &Level2Reader{}
}

func (m *Level2Reader) GetId() int32 {
	if m == nil {
		return 0
	}
	return m.readId()
}

func (m *Level2Reader) readId() int32 {
	if m.parsedId {
		return m.dataId
	}
	wOffset := m.offsetId
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataId = entry
	m.parsedId = true
	return entry
}

func (m *Level2Reader) GetDescription() string {
	if m == nil {
		return ""
	}
	return m.readDescription()
}

func (m *Level2Reader) readDescription() string {
	if m.parsedDescription {
		return m.dataDescription
	}
	wOffset := m.offsetDescription
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataDescription = entry
	m.parsedDescription = true
	return entry
}

func (m *Level2Reader) GetNested() *Level3Reader {
	if m == nil {
		return nil
	}
	return m.readNested()
}

func (m *Level2Reader) readNested() *Level3Reader {
	if m.parsedNested {
		return m.dataNested
	}
	wOffset := m.offsetNested
	
	var entry *Level3Reader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewLevel3Reader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataNested = entry
	m.parsedNested = true
	return entry
}

func (m *Level2Reader) GetItems() []*Level3Reader {
	if m == nil {
		return nil
	}
	return m.readItems()
}

func (m *Level2Reader) readItems() []*Level3Reader {
	if m.parsedItems {
		return m.dataItems
	}
	wOffset := m.offsetItems
	
	var entry []*Level3Reader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *Level3Reader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewLevel3Reader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataItems = entry
	m.parsedItems = true
	return entry
}

func (m *Level2Reader) GetPayload() []byte {
	if m == nil {
		return nil
	}
	return m.readPayload()
}

func (m *Level2Reader) readPayload() []byte {
	if m.parsedPayload {
		return m.dataPayload
	}
	wOffset := m.offsetPayload
	
	var entry []byte
	if wOffset > 0 {
		entry = m.buf.ReadBytes(wOffset)
	}
	
	m.dataPayload = entry
	m.parsedPayload = true
	return entry
}

func (m *Level2Reader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireLevel2_Id:
			m.offsetId = offset
		case wireLevel2_Description:
			m.offsetDescription = offset
		case wireLevel2_Nested:
			m.offsetNested = offset
		case wireLevel2_Items:
			m.offsetItems = append(m.offsetItems, offset)
		case wireLevel2_Payload:
			m.offsetPayload = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *Level2Reader) ToStruct() *Level2 {
	if m == nil {
		return nil
	}
	res := &Level2{}
	res.Id = m.GetId()
	res.Description = m.GetDescription()

	{
		var data = m.GetNested()
		var structData *Level3
		if data != nil {
			structData = data.ToStruct()
		}
		res.Nested = structData
	}

	{
		var data = m.GetItems()
		var structData []*Level3
		if len(data) > 0 {
			structData = make([]*Level3, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.Items = structData
	}
	res.Payload = m.GetPayload()

	return res
}

func (s *Level2Reader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type Level2 struct {
	Id	int32	`json:"id,omitempty"`
	Description	string	`json:"description,omitempty"`
	Nested	*Level3	`json:"nested,omitempty"`
	Items	[]*Level3	`json:"items,omitempty"`
	Payload	[]byte	`json:"payload,omitempty"`
}

func (s *Level2) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *Level2) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Id != 0 {
		res.AppendInt32(wireLevel2_Id, s.Id)
	}
	if s.Description != "" {
		res.AppendString(wireLevel2_Description, s.Description)
	}
	if s.Nested != nil {
		structSize := s.Nested.XXX_PbContentSize()
		res.AppendBytesTag(wireLevel2_Nested, structSize)
		s.Nested.MarshalTo(res)
	}
	if len(s.Items) > 0 {
		for _, entry := range s.Items {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireLevel2_Items, structSize)
			entry.MarshalTo(res)
		}
	}
	if len(s.Payload) != 0 {
		res.AppendBytes(wireLevel2_Payload, s.Payload)
	}
}

func (s *Level2) Copy() *Level2 {
	if s == nil {
		return nil
	}
	res := &Level2{}
	res.Id = s.Id
	res.Description = s.Description
	if s.Nested != nil {
		res.Nested = s.Nested.Copy()
	}
	res.Items = make([]*Level3, len(s.Items))
	for i := range s.Items {
		if s.Items[i] != nil {
			res.Items[i] = s.Items[i].Copy()
		}
	}
	res.Payload = s.Payload

	return res
}

func (s *Level2) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Id != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireLevel2_Id) + gremlin.SizeInt32(s.Id)
		size += entrySize
	}

	if s.Description != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Description)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireLevel2_Description)
		size += entrySize
	}

	if s.Nested != nil {
		var entrySize = 0
		entrySize = s.Nested.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireLevel2_Nested)
		
		size += entrySize
	}

	if len(s.Items) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.Items {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireLevel2_Items)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.Payload) != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeBytes(s.Payload)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireLevel2_Payload)
		size += entrySize
	}

	return size
}

const (
	wireLevel1_Id gremlin.ProtoWireNumber = 1
	wireLevel1_Title gremlin.ProtoWireNumber = 2
	wireLevel1_Nested gremlin.ProtoWireNumber = 3
	wireLevel1_Items gremlin.ProtoWireNumber = 4
	wireLevel1_Score gremlin.ProtoWireNumber = 5
)

type Level1Reader struct {
	buf *gremlin.Reader

	dataId     int32
	dataTitle     string
	dataNested     *Level2Reader
	dataItems     []*Level2Reader
	dataScore     float64

	offsetId   int
	offsetTitle   int
	offsetNested   int
	offsetItems   []int
	offsetScore   int

	parsedId   bool
	parsedTitle   bool
	parsedNested   bool
	parsedItems   bool
	parsedScore   bool
}

func NewLevel1Reader() *Level1Reader {
	return &Level1Reader{}
}

func (m *Level1Reader) GetId() int32 {
	if m == nil {
		return 0
	}
	return m.readId()
}

func (m *Level1Reader) readId() int32 {
	if m.parsedId {
		return m.dataId
	}
	wOffset := m.offsetId
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataId = entry
	m.parsedId = true
	return entry
}

func (m *Level1Reader) GetTitle() string {
	if m == nil {
		return ""
	}
	return m.readTitle()
}

func (m *Level1Reader) readTitle() string {
	if m.parsedTitle {
		return m.dataTitle
	}
	wOffset := m.offsetTitle
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataTitle = entry
	m.parsedTitle = true
	return entry
}

func (m *Level1Reader) GetNested() *Level2Reader {
	if m == nil {
		return nil
	}
	return m.readNested()
}

func (m *Level1Reader) readNested() *Level2Reader {
	if m.parsedNested {
		return m.dataNested
	}
	wOffset := m.offsetNested
	
	var entry *Level2Reader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewLevel2Reader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataNested = entry
	m.parsedNested = true
	return entry
}

func (m *Level1Reader) GetItems() []*Level2Reader {
	if m == nil {
		return nil
	}
	return m.readItems()
}

func (m *Level1Reader) readItems() []*Level2Reader {
	if m.parsedItems {
		return m.dataItems
	}
	wOffset := m.offsetItems
	
	var entry []*Level2Reader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *Level2Reader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewLevel2Reader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataItems = entry
	m.parsedItems = true
	return entry
}

func (m *Level1Reader) GetScore() float64 {
	if m == nil {
		return 0
	}
	return m.readScore()
}

func (m *Level1Reader) readScore() float64 {
	if m.parsedScore {
		return m.dataScore
	}
	wOffset := m.offsetScore
	
	var entry float64
	if wOffset > 0 {
		entry = m.buf.ReadFloat64(wOffset)
	}
	
	m.dataScore = entry
	m.parsedScore = true
	return entry
}

func (m *Level1Reader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireLevel1_Id:
			m.offsetId = offset
		case wireLevel1_Title:
			m.offsetTitle = offset
		case wireLevel1_Nested:
			m.offsetNested = offset
		case wireLevel1_Items:
			m.offsetItems = append(m.offsetItems, offset)
		case wireLevel1_Score:
			m.offsetScore = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *Level1Reader) ToStruct() *Level1 {
	if m == nil {
		return nil
	}
	res := &Level1{}
	res.Id = m.GetId()
	res.Title = m.GetTitle()

	{
		var data = m.GetNested()
		var structData *Level2
		if data != nil {
			structData = data.ToStruct()
		}
		res.Nested = structData
	}

	{
		var data = m.GetItems()
		var structData []*Level2
		if len(data) > 0 {
			structData = make([]*Level2, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.Items = structData
	}
	res.Score = m.GetScore()

	return res
}

func (s *Level1Reader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type Level1 struct {
	Id	int32	`json:"id,omitempty"`
	Title	string	`json:"title,omitempty"`
	Nested	*Level2	`json:"nested,omitempty"`
	Items	[]*Level2	`json:"items,omitempty"`
	Score	float64	`json:"score,omitempty"`
}

func (s *Level1) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *Level1) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Id != 0 {
		res.AppendInt32(wireLevel1_Id, s.Id)
	}
	if s.Title != "" {
		res.AppendString(wireLevel1_Title, s.Title)
	}
	if s.Nested != nil {
		structSize := s.Nested.XXX_PbContentSize()
		res.AppendBytesTag(wireLevel1_Nested, structSize)
		s.Nested.MarshalTo(res)
	}
	if len(s.Items) > 0 {
		for _, entry := range s.Items {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireLevel1_Items, structSize)
			entry.MarshalTo(res)
		}
	}
	if s.Score != 0 {
		res.AppendFloat64(wireLevel1_Score, s.Score)
	}
}

func (s *Level1) Copy() *Level1 {
	if s == nil {
		return nil
	}
	res := &Level1{}
	res.Id = s.Id
	res.Title = s.Title
	if s.Nested != nil {
		res.Nested = s.Nested.Copy()
	}
	res.Items = make([]*Level2, len(s.Items))
	for i := range s.Items {
		if s.Items[i] != nil {
			res.Items[i] = s.Items[i].Copy()
		}
	}
	res.Score = s.Score

	return res
}

func (s *Level1) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Id != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireLevel1_Id) + gremlin.SizeInt32(s.Id)
		size += entrySize
	}

	if s.Title != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Title)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireLevel1_Title)
		size += entrySize
	}

	if s.Nested != nil {
		var entrySize = 0
		entrySize = s.Nested.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireLevel1_Nested)
		
		size += entrySize
	}

	if len(s.Items) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.Items {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireLevel1_Items)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if s.Score != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireLevel1_Score) + gremlin.SizeFloat64(s.Score)
		size += entrySize
	}

	return size
}

const (
	wireDeepNested_RootId gremlin.ProtoWireNumber = 1
	wireDeepNested_RootName gremlin.ProtoWireNumber = 2
	wireDeepNested_Nested gremlin.ProtoWireNumber = 3
	wireDeepNested_Items gremlin.ProtoWireNumber = 4
	wireDeepNested_Active gremlin.ProtoWireNumber = 5
	wireDeepNested_Tags gremlin.ProtoWireNumber = 6
)

type DeepNestedReader struct {
	buf *gremlin.Reader

	dataRootId     int32
	dataRootName     string
	dataNested     *Level1Reader
	dataItems     []*Level1Reader
	dataActive     bool
	dataTags     []string

	offsetRootId   int
	offsetRootName   int
	offsetNested   int
	offsetItems   []int
	offsetActive   int
	offsetTags   []int

	parsedRootId   bool
	parsedRootName   bool
	parsedNested   bool
	parsedItems   bool
	parsedActive   bool
	parsedTags   bool
}

func NewDeepNestedReader() *DeepNestedReader {
	return &DeepNestedReader{}
}

func (m *DeepNestedReader) GetRootId() int32 {
	if m == nil {
		return 0
	}
	return m.readRootId()
}

func (m *DeepNestedReader) readRootId() int32 {
	if m.parsedRootId {
		return m.dataRootId
	}
	wOffset := m.offsetRootId
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataRootId = entry
	m.parsedRootId = true
	return entry
}

func (m *DeepNestedReader) GetRootName() string {
	if m == nil {
		return ""
	}
	return m.readRootName()
}

func (m *DeepNestedReader) readRootName() string {
	if m.parsedRootName {
		return m.dataRootName
	}
	wOffset := m.offsetRootName
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataRootName = entry
	m.parsedRootName = true
	return entry
}

func (m *DeepNestedReader) GetNested() *Level1Reader {
	if m == nil {
		return nil
	}
	return m.readNested()
}

func (m *DeepNestedReader) readNested() *Level1Reader {
	if m.parsedNested {
		return m.dataNested
	}
	wOffset := m.offsetNested
	
	var entry *Level1Reader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewLevel1Reader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataNested = entry
	m.parsedNested = true
	return entry
}

func (m *DeepNestedReader) GetItems() []*Level1Reader {
	if m == nil {
		return nil
	}
	return m.readItems()
}

func (m *DeepNestedReader) readItems() []*Level1Reader {
	if m.parsedItems {
		return m.dataItems
	}
	wOffset := m.offsetItems
	
	var entry []*Level1Reader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *Level1Reader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewLevel1Reader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataItems = entry
	m.parsedItems = true
	return entry
}

func (m *DeepNestedReader) GetActive() bool {
	if m == nil {
		return false
	}
	return m.readActive()
}

func (m *DeepNestedReader) readActive() bool {
	if m.parsedActive {
		return m.dataActive
	}
	wOffset := m.offsetActive
	
	var entry bool
	if wOffset > 0 {
		entry = m.buf.ReadBool(wOffset)
	}
	
	m.dataActive = entry
	m.parsedActive = true
	return entry
}

func (m *DeepNestedReader) GetTags() []string {
	if m == nil {
		return nil
	}
	return m.readTags()
}

func (m *DeepNestedReader) readTags() []string {
	if m.parsedTags {
		return m.dataTags
	}
	wOffset := m.offsetTags
	
	var entry []string
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry string
		if wOffset > 0 {
			listEntry = m.buf.ReadString(wOffset)
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataTags = entry
	m.parsedTags = true
	return entry
}

func (m *DeepNestedReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireDeepNested_RootId:
			m.offsetRootId = offset
		case wireDeepNested_RootName:
			m.offsetRootName = offset
		case wireDeepNested_Nested:
			m.offsetNested = offset
		case wireDeepNested_Items:
			m.offsetItems = append(m.offsetItems, offset)
		case wireDeepNested_Active:
			m.offsetActive = offset
		case wireDeepNested_Tags:
			m.offsetTags = append(m.offsetTags, offset)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *DeepNestedReader) ToStruct() *DeepNested {
	if m == nil {
		return nil
	}
	res := &DeepNested{}
	res.RootId = m.GetRootId()
	res.RootName = m.GetRootName()

	{
		var data = m.GetNested()
		var structData *Level1
		if data != nil {
			structData = data.ToStruct()
		}
		res.Nested = structData
	}

	{
		var data = m.GetItems()
		var structData []*Level1
		if len(data) > 0 {
			structData = make([]*Level1, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.Items = structData
	}
	res.Active = m.GetActive()
	res.Tags = m.GetTags()

	return res
}

func (s *DeepNestedReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type DeepNested struct {
	RootId	int32	`json:"root_id,omitempty"`
	RootName	string	`json:"root_name,omitempty"`
	Nested	*Level1	`json:"nested,omitempty"`
	Items	[]*Level1	`json:"items,omitempty"`
	Active	bool	`json:"active,omitempty"`
	Tags	[]string	`json:"tags,omitempty"`
}

func (s *DeepNested) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *DeepNested) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.RootId != 0 {
		res.AppendInt32(wireDeepNested_RootId, s.RootId)
	}
	if s.RootName != "" {
		res.AppendString(wireDeepNested_RootName, s.RootName)
	}
	if s.Nested != nil {
		structSize := s.Nested.XXX_PbContentSize()
		res.AppendBytesTag(wireDeepNested_Nested, structSize)
		s.Nested.MarshalTo(res)
	}
	if len(s.Items) > 0 {
		for _, entry := range s.Items {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireDeepNested_Items, structSize)
			entry.MarshalTo(res)
		}
	}
	if s.Active {
		res.AppendBool(wireDeepNested_Active, s.Active)
	}
	if len(s.Tags) > 0 {
		for _, entry := range s.Tags {
			res.AppendString(wireDeepNested_Tags, entry)
		}
	}
}

func (s *DeepNested) Copy() *DeepNested {
	if s == nil {
		return nil
	}
	res := &DeepNested{}
	res.RootId = s.RootId
	res.RootName = s.RootName
	if s.Nested != nil {
		res.Nested = s.Nested.Copy()
	}
	res.Items = make([]*Level1, len(s.Items))
	for i := range s.Items {
		if s.Items[i] != nil {
			res.Items[i] = s.Items[i].Copy()
		}
	}
	res.Active = s.Active
	res.Tags = s.Tags

	return res
}

func (s *DeepNested) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.RootId != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireDeepNested_RootId) + gremlin.SizeInt32(s.RootId)
		size += entrySize
	}

	if s.RootName != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.RootName)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireDeepNested_RootName)
		size += entrySize
	}

	if s.Nested != nil {
		var entrySize = 0
		entrySize = s.Nested.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireDeepNested_Nested)
		
		size += entrySize
	}

	if len(s.Items) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.Items {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireDeepNested_Items)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if s.Active {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireDeepNested_Active) + gremlin.SizeBool(s.Active)
		size += entrySize
	}

	if len(s.Tags) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.Tags {
			var listEntrySize int
			listEntrySize = gremlin.SizeString(val)
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireDeepNested_Tags)
			entrySize += listEntrySize
		}
		size += entrySize
	}

	return size
}

const (
	wireFlatMessage_Id gremlin.ProtoWireNumber = 1
	wireFlatMessage_Name gremlin.ProtoWireNumber = 2
	wireFlatMessage_Value gremlin.ProtoWireNumber = 3
	wireFlatMessage_Score gremlin.ProtoWireNumber = 4
	wireFlatMessage_Numbers gremlin.ProtoWireNumber = 5
	wireFlatMessage_Tags gremlin.ProtoWireNumber = 6
)

type FlatMessageReader struct {
	buf *gremlin.Reader

	dataId     int32
	dataName     string
	dataValue     int32
	dataScore     float64
	dataNumbers     []int32
	dataTags     []string

	offsetId   int
	offsetName   int
	offsetValue   int
	offsetScore   int
	offsetNumbers   []int
	wireTypeNumbers []gremlin.ProtoWireType
	offsetTags   []int

	parsedId   bool
	parsedName   bool
	parsedValue   bool
	parsedScore   bool
	parsedNumbers   bool
	parsedTags   bool
}

func NewFlatMessageReader() *FlatMessageReader {
	return &FlatMessageReader{}
}

func (m *FlatMessageReader) GetId() int32 {
	if m == nil {
		return 0
	}
	return m.readId()
}

func (m *FlatMessageReader) readId() int32 {
	if m.parsedId {
		return m.dataId
	}
	wOffset := m.offsetId
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataId = entry
	m.parsedId = true
	return entry
}

func (m *FlatMessageReader) GetName() string {
	if m == nil {
		return ""
	}
	return m.readName()
}

func (m *FlatMessageReader) readName() string {
	if m.parsedName {
		return m.dataName
	}
	wOffset := m.offsetName
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataName = entry
	m.parsedName = true
	return entry
}

func (m *FlatMessageReader) GetValue() int32 {
	if m == nil {
		return 0
	}
	return m.readValue()
}

func (m *FlatMessageReader) readValue() int32 {
	if m.parsedValue {
		return m.dataValue
	}
	wOffset := m.offsetValue
	
	var entry int32
	if wOffset > 0 {
		entry = m.buf.ReadInt32(wOffset)
	}
	
	m.dataValue = entry
	m.parsedValue = true
	return entry
}

func (m *FlatMessageReader) GetScore() float64 {
	if m == nil {
		return 0
	}
	return m.readScore()
}

func (m *FlatMessageReader) readScore() float64 {
	if m.parsedScore {
		return m.dataScore
	}
	wOffset := m.offsetScore
	
	var entry float64
	if wOffset > 0 {
		entry = m.buf.ReadFloat64(wOffset)
	}
	
	m.dataScore = entry
	m.parsedScore = true
	return entry
}

func (m *FlatMessageReader) GetNumbers() []int32 {
	if m == nil {
		return nil
	}
	return m.readNumbers()
}

func (m *FlatMessageReader) readNumbers() []int32 {
	if m.parsedNumbers {
		return m.dataNumbers
	}
	wOffset := m.offsetNumbers
	var wType = m.wireTypeNumbers
	
	var entry []int32
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		wType := wType[i]
		if wType == gremlin.BytesType {
			size, sizeSize := m.buf.SizedReadVarInt(wOffset)
			offset := 0
			for offset < int(size) {
				wOffset := wOffset + sizeSize + offset
				
				var listEntry int32
				var listEntrySize int
				if wOffset > 0 {
					listEntry, listEntrySize = m.buf.SizedReadInt32(wOffset)
				}
				
				entry = append(entry, listEntry)
				offset += listEntrySize
			}
		} else {
			
			var listEntry int32
			if wOffset > 0 {
				listEntry = m.buf.ReadInt32(wOffset)
			}
			
			entry = append(entry, listEntry)
		}
	}
	
	m.dataNumbers = entry
	m.parsedNumbers = true
	return entry
}

func (m *FlatMessageReader) GetTags() []string {
	if m == nil {
		return nil
	}
	return m.readTags()
}

func (m *FlatMessageReader) readTags() []string {
	if m.parsedTags {
		return m.dataTags
	}
	wOffset := m.offsetTags
	
	var entry []string
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry string
		if wOffset > 0 {
			listEntry = m.buf.ReadString(wOffset)
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataTags = entry
	m.parsedTags = true
	return entry
}

func (m *FlatMessageReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireFlatMessage_Id:
			m.offsetId = offset
		case wireFlatMessage_Name:
			m.offsetName = offset
		case wireFlatMessage_Value:
			m.offsetValue = offset
		case wireFlatMessage_Score:
			m.offsetScore = offset
		case wireFlatMessage_Numbers:
			m.offsetNumbers = append(m.offsetNumbers, offset)
			m.wireTypeNumbers = append(m.wireTypeNumbers, wire)
		case wireFlatMessage_Tags:
			m.offsetTags = append(m.offsetTags, offset)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *FlatMessageReader) ToStruct() *FlatMessage {
	if m == nil {
		return nil
	}
	res := &FlatMessage{}
	res.Id = m.GetId()
	res.Name = m.GetName()
	res.Value = m.GetValue()
	res.Score = m.GetScore()
	res.Numbers = m.GetNumbers()
	res.Tags = m.GetTags()

	return res
}

func (s *FlatMessageReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type FlatMessage struct {
	Id	int32	`json:"id,omitempty"`
	Name	string	`json:"name,omitempty"`
	Value	int32	`json:"value,omitempty"`
	Score	float64	`json:"score,omitempty"`
	Numbers	[]int32	`json:"numbers,omitempty"`
	Tags	[]string	`json:"tags,omitempty"`
}

func (s *FlatMessage) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *FlatMessage) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Id != 0 {
		res.AppendInt32(wireFlatMessage_Id, s.Id)
	}
	if s.Name != "" {
		res.AppendString(wireFlatMessage_Name, s.Name)
	}
	if s.Value != 0 {
		res.AppendInt32(wireFlatMessage_Value, s.Value)
	}
	if s.Score != 0 {
		res.AppendFloat64(wireFlatMessage_Score, s.Score)
	}
	if len(s.Numbers) > 0 {
		if len(s.Numbers) > 1 {
			var listBytesSize = 0
			for _, entry := range s.Numbers {
				var entrySize = 0
				entrySize = gremlin.SizeInt32(entry)
				listBytesSize += entrySize
			}
			res.AppendBytesTag(wireFlatMessage_Numbers, listBytesSize)
			for _, entry := range s.Numbers {
				res.AppendInt32WithoutTag(entry)
			}
		} else if len(s.Numbers) == 1 {
			res.AppendInt32(wireFlatMessage_Numbers, s.Numbers[0])
		}
	}
	if len(s.Tags) > 0 {
		for _, entry := range s.Tags {
			res.AppendString(wireFlatMessage_Tags, entry)
		}
	}
}

func (s *FlatMessage) Copy() *FlatMessage {
	if s == nil {
		return nil
	}
	res := &FlatMessage{}
	res.Id = s.Id
	res.Name = s.Name
	res.Value = s.Value
	res.Score = s.Score
	res.Numbers = s.Numbers
	res.Tags = s.Tags

	return res
}

func (s *FlatMessage) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Id != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireFlatMessage_Id) + gremlin.SizeInt32(s.Id)
		size += entrySize
	}

	if s.Name != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.Name)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireFlatMessage_Name)
		size += entrySize
	}

	if s.Value != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireFlatMessage_Value) + gremlin.SizeInt32(s.Value)
		size += entrySize
	}

	if s.Score != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireFlatMessage_Score) + gremlin.SizeFloat64(s.Score)
		size += entrySize
	}

	if len(s.Numbers) > 0 {
		var entrySize = 0
		entrySize = 0
		if len(s.Numbers) > 1 {
			var listBytesSize = 0
			for _, entry := range s.Numbers {
				var listEntrySize = 0
				listEntrySize = gremlin.SizeInt32(entry)
				listBytesSize += listEntrySize
			}
			entrySize += gremlin.SizeUint64(uint64(listBytesSize)) + gremlin.SizeTag(wireFlatMessage_Numbers) + listBytesSize
		} else if len(s.Numbers) == 1 {
			var listEntrySize = 0
			listEntrySize = gremlin.SizeTag(wireFlatMessage_Numbers) + gremlin.SizeInt32(s.Numbers[0])
			entrySize += listEntrySize
		}
		size += entrySize
	}

	if len(s.Tags) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.Tags {
			var listEntrySize int
			listEntrySize = gremlin.SizeString(val)
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireFlatMessage_Tags)
			entrySize += listEntrySize
		}
		size += entrySize
	}

	return size
}
